{"version":3,"sources":["../src/buffer.ts","../src/sampling.ts","../src/sdk.ts","../src/config.ts","../src/types.ts","../src/exporter.ts","../src/wrap.ts","../versions.json","../src/spanprocessor.ts","../src/provider.ts","../src/context.ts","../src/tracer.ts","../src/span.ts","../src/instrumentation/fetch.ts","../src/instrumentation/cache.ts","../src/instrumentation/queue.ts","../src/instrumentation/do.ts","../src/instrumentation/kv.ts","../src/instrumentation/service.ts","../src/instrumentation/d1.ts","../src/instrumentation/analytics-engine.ts","../src/instrumentation/env.ts","../src/instrumentation/do-storage.ts","../src/instrumentation/scheduled.ts","../src/instrumentation/version.ts","../src/instrumentation/common.ts","../src/instrumentation/email.ts","../src/instrumentation/page.ts","../src/instrumentation/entrypoint.ts","../src/multiexporter.ts"],"sourcesContent":["//@ts-ignore\nimport { Buffer } from 'node:buffer'\n//@ts-ignore\nglobalThis.Buffer = Buffer\n","import { TraceFlags, SpanStatusCode } from '@opentelemetry/api'\nimport { ParentBasedSampler, ReadableSpan, Sampler, TraceIdRatioBasedSampler } from '@opentelemetry/sdk-trace-base'\nimport { ParentRatioSamplingConfig } from './types'\n\nexport interface LocalTrace {\n\treadonly traceId: string\n\treadonly localRootSpan: ReadableSpan\n\treadonly spans: ReadableSpan[]\n}\n\nexport type TailSampleFn = (traceInfo: LocalTrace) => boolean\n\nexport function multiTailSampler(samplers: TailSampleFn[]): TailSampleFn {\n\treturn (traceInfo) => {\n\t\treturn samplers.reduce((result, sampler) => result || sampler(traceInfo), false)\n\t}\n}\n\nexport const isHeadSampled: TailSampleFn = (traceInfo) => {\n\tconst localRootSpan = traceInfo.localRootSpan\n\treturn (localRootSpan.spanContext().traceFlags & TraceFlags.SAMPLED) === TraceFlags.SAMPLED\n}\n\nexport const isRootErrorSpan: TailSampleFn = (traceInfo) => {\n\tconst localRootSpan = traceInfo.localRootSpan\n\treturn localRootSpan.status.code === SpanStatusCode.ERROR\n}\n\nexport function createSampler(conf: ParentRatioSamplingConfig): Sampler {\n\tconst ratioSampler = new TraceIdRatioBasedSampler(conf.ratio)\n\tif (typeof conf.acceptRemote === 'boolean' && !conf.acceptRemote) {\n\t\treturn new ParentBasedSampler({\n\t\t\troot: ratioSampler,\n\t\t\tremoteParentSampled: ratioSampler,\n\t\t\tremoteParentNotSampled: ratioSampler,\n\t\t})\n\t} else {\n\t\treturn new ParentBasedSampler({ root: ratioSampler })\n\t}\n}\n","import { context as api_context, Exception, propagation, SpanStatusCode, trace } from '@opentelemetry/api'\nimport { Resource, resourceFromAttributes } from '@opentelemetry/resources'\n\nimport { Initialiser, parseConfig, setConfig } from './config.js'\nimport { WorkerTracerProvider } from './provider.js'\nimport { Trigger, ResolvedTraceConfig, OrPromise, HandlerInstrumentation, ConfigurationOption } from './types.js'\nimport { unwrap } from './wrap.js'\nimport { WorkerTracer } from './tracer.js'\n\nimport { fetchInstrumentation, instrumentGlobalFetch } from './instrumentation/fetch.js'\nimport { instrumentGlobalCache } from './instrumentation/cache.js'\nimport { QueueInstrumentation } from './instrumentation/queue.js'\nimport { DOClass, instrumentDOClass } from './instrumentation/do.js'\nimport { scheduledInstrumentation } from './instrumentation/scheduled.js'\nimport { instrumentEnv } from './instrumentation/env.js'\nimport { versionAttributes } from './instrumentation/version.js'\nimport { PromiseTracker, proxyExecutionContext } from './instrumentation/common.js'\nimport { emailInstrumentation } from './instrumentation/email.js'\n\n//@ts-ignore\nimport * as versions from '../versions.json'\n//@ts-ignore\nimport { env } from 'cloudflare:workers'\nimport { createPageHandler, ExportedSvelteEventHandler } from './instrumentation/page.js'\nimport { createEntrypointHandler } from './instrumentation/entrypoint.js'\n\ntype FetchHandler = ExportedHandlerFetchHandler<unknown, unknown>\ntype ScheduledHandler = ExportedHandlerScheduledHandler<unknown>\ntype QueueHandler = ExportedHandlerQueueHandler\ntype EmailHandler = EmailExportedHandler\n\ntype Env = Record<string, any>\ntype HandlerFn<T extends Trigger, E extends Env, R extends any> = (\n\ttrigger: T,\n\tenv: E,\n\tctx: ExecutionContext,\n) => R | Promise<R>\n\nexport { InstrumentedEntrypoint } from './instrumentation/entrypoint.js'\n\nexport function isRequest(trigger: Trigger): trigger is Request {\n\treturn trigger instanceof Request\n}\n\nexport function isMessageBatch(trigger: Trigger): trigger is MessageBatch {\n\treturn !!(trigger as MessageBatch).ackAll\n}\n\nexport function isAlarm(trigger: Trigger): trigger is 'do-alarm' {\n\treturn trigger === 'do-alarm'\n}\n\nfunction findVersionMeta(): WorkerVersionMetadata | undefined {\n\treturn Object.values(env).find((binding: any) => {\n\t\treturn (\n\t\t\tObject.getPrototypeOf(binding).constructor.name === 'Object' &&\n\t\t\tbinding.id !== undefined &&\n\t\t\tbinding.tag !== undefined\n\t\t)\n\t})\n}\n\nconst createResource = (config: ResolvedTraceConfig, versionMeta?: WorkerVersionMetadata): Resource => {\n\tconsole.log({ versionMeta })\n\tconst workerResourceAttrs = {\n\t\t'cloud.provider': 'cloudflare',\n\t\t'cloud.platform': 'cloudflare.workers',\n\t\t'cloud.region': 'earth',\n\t\t'faas.max_memory': 134217728,\n\t\t'telemetry.sdk.language': 'js',\n\t\t'telemetry.sdk.name': '@microlabs/otel-cf-workers',\n\t\t'telemetry.sdk.version': versions['@microlabs/otel-cf-workers'],\n\t\t'telemetry.sdk.build.node_version': versions['node'],\n\t\t'cf.worker.version.id': versionMeta?.id,\n\t\t'cf.worker.version.tag': versionMeta?.tag,\n\t\t'cf.worker.version.timestamp': versionMeta?.timestamp,\n\t}\n\tconst serviceResource = resourceFromAttributes({\n\t\t'service.name': config.service.name,\n\t\t'service.namespace': config.service.namespace,\n\t\t'service.version': config.service.version,\n\t})\n\tconst resource = resourceFromAttributes(workerResourceAttrs)\n\treturn resource.merge(serviceResource)\n}\n\nlet initialised = false\nfunction init(config: ResolvedTraceConfig): void {\n\tif (!initialised) {\n\t\tif (config.instrumentation.instrumentGlobalCache) {\n\t\t\tinstrumentGlobalCache()\n\t\t}\n\t\tif (config.instrumentation.instrumentGlobalFetch) {\n\t\t\tinstrumentGlobalFetch()\n\t\t}\n\t\tpropagation.setGlobalPropagator(config.propagator)\n\t\tconst resource = createResource(config, findVersionMeta())\n\n\t\tconst provider = new WorkerTracerProvider(config.spanProcessors, resource)\n\t\tprovider.register()\n\t\tinitialised = true\n\t}\n}\n\nfunction createInitialiser(config: ConfigurationOption): Initialiser {\n\tif (typeof config === 'function') {\n\t\treturn (env, trigger) => {\n\t\t\tconst conf = parseConfig(config(env, trigger))\n\t\t\tinit(conf)\n\t\t\treturn conf\n\t\t}\n\t} else {\n\t\treturn () => {\n\t\t\tconst conf = parseConfig(config)\n\t\t\tinit(conf)\n\t\t\treturn conf\n\t\t}\n\t}\n}\n\nexport function instrumentEntrypoint(config: ConfigurationOption): MethodDecorator {\n\tconst initialiser = createInitialiser(config)\n\treturn createEntrypointHandler(initialiser)\n}\n\nexport async function exportSpans(traceId: string, tracker?: PromiseTracker) {\n\tconst tracer = trace.getTracer('export')\n\tif (tracer instanceof WorkerTracer) {\n\t\tawait scheduler.wait(1)\n\t\tawait tracker?.wait()\n\t\tawait tracer.forceFlush(traceId)\n\t} else {\n\t\tconsole.error('The global tracer is not of type WorkerTracer and can not export spans')\n\t}\n}\n\ntype HandlerFnArgs<T extends Trigger, E extends Env> = (T | E | ExecutionContext)[]\ntype OrderedHandlerFnArgs<T extends Trigger, E extends Env> = [trigger: T, env: E, ctx: ExecutionContext]\n\nlet cold_start = true\nfunction createHandlerFlowFn<T extends Trigger, E extends Env, R extends any>(\n\tinstrumentation: HandlerInstrumentation<T, R>,\n): (handlerFn: HandlerFn<T, E, R>, [trigger, env, context]: HandlerFnArgs<T, E>) => ReturnType<HandlerFn<T, E, R>> {\n\treturn (handlerFn, args) => {\n\t\tconst [trigger, env, context] = args as OrderedHandlerFnArgs<T, E>\n\t\tconst proxiedEnv = instrumentEnv(env)\n\t\tconst { ctx: proxiedCtx, tracker } = proxyExecutionContext(context)\n\n\t\tconst instrumentedTrigger = instrumentation.instrumentTrigger ? instrumentation.instrumentTrigger(trigger) : trigger\n\n\t\tconst tracer = trace.getTracer('handler') as WorkerTracer\n\n\t\tconst { name, options, context: spanContext } = instrumentation.getInitialSpanInfo(trigger)\n\t\tconst attrs = options.attributes || {}\n\t\tattrs['faas.coldstart'] = cold_start\n\t\toptions.attributes = attrs\n\t\tObject.assign(attrs, versionAttributes(env))\n\t\tcold_start = false\n\n\t\tconst parentContext = spanContext || api_context.active()\n\t\tconst result = tracer.startActiveSpan(name, options, parentContext, async (span) => {\n\t\t\ttry {\n\t\t\t\tconst result = await handlerFn(instrumentedTrigger, proxiedEnv, proxiedCtx)\n\n\t\t\t\tif (instrumentation.getAttributesFromResult) {\n\t\t\t\t\tconst attributes = instrumentation.getAttributesFromResult(result)\n\t\t\t\t\tspan.setAttributes(attributes)\n\t\t\t\t}\n\n\t\t\t\tif (instrumentation.executionSucces) {\n\t\t\t\t\tinstrumentation.executionSucces(span, trigger, result)\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t} catch (error) {\n\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\tif (instrumentation.executionFailed) {\n\t\t\t\t\tinstrumentation.executionFailed(span, trigger, error)\n\t\t\t\t}\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\tspan.end()\n\t\t\t\tcontext.waitUntil(exportSpans(span.spanContext().traceId, tracker))\n\t\t\t}\n\t\t})\n\n\t\treturn result\n\t}\n}\n\nfunction createHandlerProxy<T extends Trigger, E extends Env, R extends OrPromise<any>>(\n\thandler: unknown,\n\thandlerFn: HandlerFn<T, E, R>,\n\tinitialiser: Initialiser,\n\tinstrumentation: HandlerInstrumentation<T, R>,\n): HandlerFn<T, E, R> {\n\treturn (trigger: T, env: E, ctx: ExecutionContext): ReturnType<HandlerFn<T, E, R>> => {\n\t\tconst config = initialiser(env, trigger)\n\t\tconst context = setConfig(config)\n\n\t\tconst flowFn = createHandlerFlowFn<T, E, R>(instrumentation)\n\t\treturn api_context.with(context, flowFn, handler, handlerFn, [trigger, env, ctx]) as R\n\t}\n}\n\nexport function instrument<E extends Env, Q, C>(\n\thandler: ExportedHandler<E, Q, C>,\n\tconfig: ConfigurationOption,\n): ExportedHandler<E, Q, C> {\n\tconst initialiser = createInitialiser(config)\n\n\tif (handler.fetch) {\n\t\tconst fetcher = unwrap(handler.fetch) as FetchHandler\n\t\thandler.fetch = createHandlerProxy(handler, fetcher, initialiser, fetchInstrumentation)\n\t}\n\n\tif (handler.scheduled) {\n\t\tconst scheduler = unwrap(handler.scheduled) as ScheduledHandler\n\t\thandler.scheduled = createHandlerProxy(handler, scheduler, initialiser, scheduledInstrumentation)\n\t}\n\n\tif (handler.queue) {\n\t\tconst queuer = unwrap(handler.queue) as QueueHandler\n\t\thandler.queue = createHandlerProxy(handler, queuer, initialiser, new QueueInstrumentation())\n\t}\n\n\tif (handler.email) {\n\t\tconst emailer = unwrap(handler.email) as EmailHandler\n\t\thandler.email = createHandlerProxy(handler, emailer, initialiser, emailInstrumentation)\n\t}\n\n\treturn handler\n}\n\nexport function instrumentDO(doClass: DOClass, config: ConfigurationOption) {\n\tconst initialiser = createInitialiser(config)\n\n\treturn instrumentDOClass(doClass, initialiser)\n}\n\nexport function instrumentPage(\n\teventHandler: ExportedSvelteEventHandler,\n\tconfig: ConfigurationOption,\n): ExportedSvelteEventHandler {\n\tconst initialiser = createInitialiser(config)\n\teventHandler = createPageHandler(eventHandler, initialiser)\n\treturn eventHandler\n}\n\nexport const __unwrappedFetch = unwrap(fetch)\n","import { context } from '@opentelemetry/api'\nimport {\n\tExporterConfig,\n\tisSpanProcessorConfig,\n\tParentRatioSamplingConfig,\n\tResolvedTraceConfig,\n\tTraceConfig,\n\tTrigger,\n} from './types.js'\nimport { W3CTraceContextPropagator } from '@opentelemetry/core'\nimport { ReadableSpan, Sampler, SpanExporter } from '@opentelemetry/sdk-trace-base'\n\nimport { OTLPExporter } from './exporter.js'\nimport { multiTailSampler, isHeadSampled, isRootErrorSpan, createSampler } from './sampling.js'\nimport { BatchTraceSpanProcessor } from './spanprocessor.js'\n\nconst configSymbol = Symbol('Otel Workers Tracing Configuration')\n\nexport type Initialiser = (env: Record<string, unknown>, trigger: Trigger) => ResolvedTraceConfig\n\nexport function setConfig(config: ResolvedTraceConfig, ctx = context.active()) {\n\treturn ctx.setValue(configSymbol, config)\n}\n\nexport function getActiveConfig(): ResolvedTraceConfig | undefined {\n\tconst config = context.active().getValue(configSymbol) as ResolvedTraceConfig\n\treturn config || undefined\n}\n\nfunction isSpanExporter(exporterConfig: ExporterConfig): exporterConfig is SpanExporter {\n\treturn !!(exporterConfig as SpanExporter).export\n}\n\nfunction isSampler(sampler: Sampler | ParentRatioSamplingConfig): sampler is Sampler {\n\treturn !!(sampler as Sampler).shouldSample\n}\n\nexport function parseConfig(supplied: TraceConfig): ResolvedTraceConfig {\n\tif (isSpanProcessorConfig(supplied)) {\n\t\tconst headSampleConf = supplied.sampling?.headSampler || { ratio: 1 }\n\t\tconst headSampler = isSampler(headSampleConf) ? headSampleConf : createSampler(headSampleConf)\n\t\tconst spanProcessors = Array.isArray(supplied.spanProcessors) ? supplied.spanProcessors : [supplied.spanProcessors]\n\t\tif (spanProcessors.length === 0) {\n\t\t\tconsole.log(\n\t\t\t\t'Warning! You must either specify an exporter or your own SpanProcessor(s)/Exporter combination in the open-telemetry configuration.',\n\t\t\t)\n\t\t}\n\t\treturn {\n\t\t\tfetch: {\n\t\t\t\tincludeTraceContext: supplied.fetch?.includeTraceContext ?? true,\n\t\t\t},\n\t\t\thandlers: {\n\t\t\t\tfetch: {\n\t\t\t\t\tacceptTraceContext: supplied.handlers?.fetch?.acceptTraceContext ?? true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tpostProcessor: supplied.postProcessor || ((spans: ReadableSpan[]) => spans),\n\t\t\tsampling: {\n\t\t\t\theadSampler,\n\t\t\t\ttailSampler: supplied.sampling?.tailSampler || multiTailSampler([isHeadSampled, isRootErrorSpan]),\n\t\t\t},\n\t\t\tservice: supplied.service,\n\t\t\tspanProcessors,\n\t\t\tpropagator: supplied.propagator || new W3CTraceContextPropagator(),\n\t\t\tinstrumentation: {\n\t\t\t\tinstrumentGlobalCache: supplied.instrumentation?.instrumentGlobalCache ?? true,\n\t\t\t\tinstrumentGlobalFetch: supplied.instrumentation?.instrumentGlobalFetch ?? true,\n\t\t\t},\n\t\t}\n\t} else {\n\t\tconst exporter = isSpanExporter(supplied.exporter) ? supplied.exporter : new OTLPExporter(supplied.exporter)\n\t\tconst spanProcessors = [new BatchTraceSpanProcessor(exporter)]\n\t\tconst newConfig = Object.assign(supplied, { exporter: undefined, spanProcessors }) as TraceConfig\n\t\treturn parseConfig(newConfig)\n\t}\n}\n","import { Attributes, Context, SpanOptions, TextMapPropagator, Span } from '@opentelemetry/api'\nimport { ReadableSpan, Sampler, SpanExporter, SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { OTLPExporterConfig } from './exporter.js'\nimport { FetchHandlerConfig, FetcherConfig } from './instrumentation/fetch.js'\nimport { TailSampleFn } from './sampling.js'\n\nexport type OrPromise<T extends any> = T | Promise<T>\n\nexport type ResolveConfigFn<Env = any> = (env: Env, trigger: Trigger) => TraceConfig\nexport type ConfigurationOption = TraceConfig | ResolveConfigFn\n\nexport type PostProcessorFn = (spans: ReadableSpan[]) => ReadableSpan[]\n\nexport type ExporterConfig = OTLPExporterConfig | SpanExporter\n\nexport interface InitialSpanInfo {\n\tname: string\n\toptions: SpanOptions\n\tcontext?: Context\n}\n\nexport interface HandlerInstrumentation<T extends Trigger, R extends any> {\n\tgetInitialSpanInfo: (trigger: T) => InitialSpanInfo\n\tgetAttributesFromResult?: (result: Awaited<R>) => Attributes\n\tinstrumentTrigger?: (trigger: T) => T\n\texecutionSucces?: (span: Span, trigger: T, result: Awaited<R>) => void\n\texecutionFailed?: (span: Span, trigger: T, error?: any) => void\n}\n\nexport type TraceFlushableSpanProcessor = SpanProcessor & { forceFlush: (traceId?: string) => Promise<void> }\n\nexport interface HandlerConfig {\n\tfetch?: FetchHandlerConfig\n}\n\nexport interface ServiceConfig {\n\tname: string\n\tnamespace?: string\n\tversion?: string\n}\n\nexport interface ParentRatioSamplingConfig {\n\tacceptRemote?: boolean\n\tratio: number\n}\n\ntype HeadSamplerConf = Sampler | ParentRatioSamplingConfig\nexport interface SamplingConfig<HS extends HeadSamplerConf = HeadSamplerConf> {\n\theadSampler?: HS\n\ttailSampler?: TailSampleFn\n}\n\nexport interface InstrumentationOptions {\n\tinstrumentGlobalFetch?: boolean\n\tinstrumentGlobalCache?: boolean\n}\n\ninterface TraceConfigBase {\n\tservice: ServiceConfig\n\thandlers?: HandlerConfig\n\tfetch?: FetcherConfig\n\tpostProcessor?: PostProcessorFn\n\tsampling?: SamplingConfig\n\tpropagator?: TextMapPropagator\n\tinstrumentation?: InstrumentationOptions\n}\n\ninterface TraceConfigExporter extends TraceConfigBase {\n\texporter: ExporterConfig\n}\n\ninterface TraceConfigSpanProcessors extends TraceConfigBase {\n\tspanProcessors: SpanProcessor | SpanProcessor[]\n}\n\nexport type TraceConfig = TraceConfigExporter | TraceConfigSpanProcessors\n\nexport function isSpanProcessorConfig(config: TraceConfig): config is TraceConfigSpanProcessors {\n\treturn !!(config as TraceConfigSpanProcessors).spanProcessors\n}\n\nexport interface ResolvedTraceConfig extends TraceConfigBase {\n\thandlers: Required<HandlerConfig>\n\tfetch: Required<FetcherConfig>\n\tpostProcessor: PostProcessorFn\n\tsampling: Required<SamplingConfig<Sampler>>\n\tspanProcessors: SpanProcessor[]\n\tpropagator: TextMapPropagator\n\tinstrumentation: InstrumentationOptions\n}\n\nexport interface DOConstructorTrigger {\n\tid: string\n\tname?: string\n}\n\nexport type Trigger =\n\t| Request\n\t| MessageBatch\n\t| ScheduledController\n\t| DOConstructorTrigger\n\t| 'do-alarm'\n\t| ForwardableEmailMessage\n\t| PropertyDescriptor\n","import { ExportResult, ExportResultCode } from '@opentelemetry/core'\nimport { OTLPExporterError } from '@opentelemetry/otlp-exporter-base'\nimport { JsonTraceSerializer } from '@opentelemetry/otlp-transformer'\nimport { SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport { unwrap } from './wrap.js'\n\n//@ts-ignore\nimport * as versions from '../versions.json'\n\nexport interface OTLPExporterConfig {\n\turl: string\n\theaders?: Record<string, string>\n}\n\nconst defaultHeaders: Record<string, string> = {\n\taccept: 'application/json',\n\t'content-type': 'application/json',\n\t'user-agent': `Cloudflare Worker @microlabs/otel-cf-workers v${versions['@microlabs/otel-cf-workers']}`,\n}\n\nexport class OTLPExporter implements SpanExporter {\n\tprivate headers: Record<string, string>\n\tprivate url: string\n\tconstructor(config: OTLPExporterConfig) {\n\t\tthis.url = config.url\n\t\tthis.headers = Object.assign({}, defaultHeaders, config.headers)\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tthis._export(items)\n\t\t\t.then(() => {\n\t\t\t\tresultCallback({ code: ExportResultCode.SUCCESS })\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tresultCallback({ code: ExportResultCode.FAILED, error })\n\t\t\t})\n\t}\n\n\tprivate _export(items: any[]): Promise<unknown> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tthis.send(items, resolve, reject)\n\t\t\t} catch (e) {\n\t\t\t\treject(e)\n\t\t\t}\n\t\t})\n\t}\n\n\tsend(items: any[], onSuccess: () => void, onError: (error: OTLPExporterError) => void): void {\n\t\tconst decoder = new TextDecoder()\n\t\tconst exportMessage = JsonTraceSerializer.serializeRequest(items)\n\n\t\tconst body = decoder.decode(exportMessage)\n\t\tconst params: RequestInit = {\n\t\t\tmethod: 'POST',\n\t\t\theaders: this.headers,\n\t\t\tbody,\n\t\t}\n\n\t\tunwrap(fetch)(this.url, params)\n\t\t\t.then((response) => {\n\t\t\t\tif (response.ok) {\n\t\t\t\t\tonSuccess()\n\t\t\t\t} else {\n\t\t\t\t\tonError(new OTLPExporterError(`Exporter received a statusCode: ${response.status}`))\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tonError(new OTLPExporterError(`Exception during export: ${error.toString()}`, error.code, error.stack))\n\t\t\t})\n\t}\n\n\tasync shutdown(): Promise<void> {}\n}\n","const unwrapSymbol = Symbol('unwrap')\n\ntype Wrapped<T> = { [unwrapSymbol]: T } & T\n\nexport function isWrapped<T>(item: T): item is Wrapped<T> {\n\treturn item && !!(item as Wrapped<T>)[unwrapSymbol]\n}\n\nexport function isProxyable(item: any) {\n\treturn (item !== null && typeof item === 'object') || typeof item === 'function'\n}\n\nexport function wrap<T extends object>(item: T, handler: ProxyHandler<T>, autoPassthrough: boolean = true): T {\n\tif (isWrapped(item) || !isProxyable(item)) {\n\t\treturn item\n\t}\n\tconst proxyHandler = Object.assign({}, handler)\n\tproxyHandler.get = (target, prop, receiver) => {\n\t\tif (prop === unwrapSymbol) {\n\t\t\treturn item\n\t\t} else {\n\t\t\tif (handler.get) {\n\t\t\t\treturn handler.get(target, prop, receiver)\n\t\t\t} else if (prop === 'bind') {\n\t\t\t\treturn () => receiver\n\t\t\t} else if (autoPassthrough) {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t}\n\t}\n\tproxyHandler.apply = (target, thisArg, argArray) => {\n\t\tif (handler.apply) {\n\t\t\treturn handler.apply(unwrap(target), unwrap(thisArg), argArray)\n\t\t}\n\t}\n\treturn new Proxy(item, proxyHandler)\n}\n\nexport function unwrap<T extends object>(item: T): T {\n\tif (item && isWrapped(item)) {\n\t\treturn item[unwrapSymbol]\n\t} else {\n\t\treturn item\n\t}\n}\n\nexport function passthroughGet(target: any, prop: string | symbol, thisArg?: any) {\n\tconst unwrappedTarget = unwrap(target)\n\tthisArg = unwrap(thisArg) || unwrappedTarget\n\tconst value = Reflect.get(unwrappedTarget, prop)\n\tif (typeof value === 'function') {\n\t\tif (value.constructor.name === 'RpcProperty') {\n\t\t\treturn (...args: unknown[]) => unwrappedTarget[prop](...args)\n\t\t}\n\t\treturn value.bind(thisArg)\n\t} else {\n\t\treturn value\n\t}\n}\n","{\n  \"@microlabs/otel-cf-workers\": \"1.0.0-fp.58\",\n  \"npm\": \"10.9.2\",\n  \"node\": \"22.14.0\",\n  \"acorn\": \"8.14.0\",\n  \"ada\": \"2.9.2\",\n  \"amaro\": \"0.3.0\",\n  \"ares\": \"1.34.4\",\n  \"brotli\": \"1.1.0\",\n  \"cjs_module_lexer\": \"1.4.1\",\n  \"cldr\": \"46.0\",\n  \"icu\": \"76.1\",\n  \"llhttp\": \"9.2.1\",\n  \"modules\": \"127\",\n  \"napi\": \"10\",\n  \"nbytes\": \"0.1.1\",\n  \"ncrypto\": \"0.0.1\",\n  \"nghttp2\": \"1.64.0\",\n  \"nghttp3\": \"1.6.0\",\n  \"ngtcp2\": \"1.10.0\",\n  \"openssl\": \"3.0.15+quic\",\n  \"simdjson\": \"3.10.1\",\n  \"simdutf\": \"6.0.3\",\n  \"sqlite\": \"3.47.2\",\n  \"tz\": \"2024b\",\n  \"undici\": \"6.21.1\",\n  \"unicode\": \"16.0\",\n  \"uv\": \"1.49.2\",\n  \"uvwasi\": \"0.0.21\",\n  \"v8\": \"12.4.254.21-node.22\",\n  \"zlib\": \"1.3.0.1-motley-82a5fec\"\n}\n","import { Context, Span } from '@opentelemetry/api'\nimport { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport { ExportResultCode } from '@opentelemetry/core'\nimport { getActiveConfig } from './config'\nimport { TraceFlushableSpanProcessor } from './types'\nimport { TailSampleFn } from './sampling'\n\nfunction getSampler(): TailSampleFn {\n\tconst conf = getActiveConfig()\n\tif (!conf) {\n\t\tconsole.log('Could not find config for sampling, sending everything by default')\n\t}\n\treturn conf ? conf.sampling.tailSampler : () => true\n}\n\nclass TraceState {\n\tprivate unexportedSpans: ReadableSpan[] = []\n\tprivate inprogressSpans = new Set<string>()\n\tprivate exporter: SpanExporter\n\tprivate exportPromises: Promise<void>[] = []\n\tprivate localRootSpan?: ReadableSpan\n\tprivate traceDecision?: boolean\n\n\tconstructor(exporter: SpanExporter) {\n\t\tthis.exporter = exporter\n\t}\n\n\taddSpan(span: Span): void {\n\t\tconst readableSpan = span as unknown as ReadableSpan\n\t\tthis.localRootSpan = this.localRootSpan || readableSpan\n\t\tthis.unexportedSpans.push(readableSpan)\n\t\tthis.inprogressSpans.add(span.spanContext().spanId)\n\t}\n\n\tendSpan(span: ReadableSpan): void {\n\t\tthis.inprogressSpans.delete(span.spanContext().spanId)\n\t\tif (this.inprogressSpans.size === 0) {\n\t\t\tthis.flush()\n\t\t}\n\t}\n\n\tsample() {\n\t\tif (this.traceDecision === undefined && this.unexportedSpans.length > 0) {\n\t\t\tconst sampler = getSampler()\n\t\t\tthis.traceDecision = sampler({\n\t\t\t\ttraceId: this.localRootSpan!.spanContext().traceId,\n\t\t\t\tlocalRootSpan: this.localRootSpan!,\n\t\t\t\tspans: this.unexportedSpans,\n\t\t\t})\n\t\t}\n\t\tthis.unexportedSpans = this.traceDecision ? this.unexportedSpans : []\n\t}\n\n\tasync flush(): Promise<void> {\n\t\tif (this.unexportedSpans.length > 0) {\n\t\t\tconst unfinishedSpans = this.unexportedSpans.filter((span) => this.isSpanInProgress(span)) as unknown as Span[]\n\t\t\tfor (const span of unfinishedSpans) {\n\t\t\t\tconsole.log(`Span ${span.spanContext().spanId} was not ended properly`)\n\t\t\t\tspan.end()\n\t\t\t}\n\t\t\tthis.sample()\n\t\t\tthis.exportPromises.push(this.exportSpans(this.unexportedSpans))\n\t\t\tthis.unexportedSpans = []\n\t\t}\n\t\tif (this.exportPromises.length > 0) {\n\t\t\tawait Promise.allSettled(this.exportPromises)\n\t\t}\n\t}\n\n\tprivate isSpanInProgress(span: ReadableSpan) {\n\t\treturn this.inprogressSpans.has(span.spanContext().spanId)\n\t}\n\n\tprivate async exportSpans(spans: ReadableSpan[]): Promise<void> {\n\t\tawait scheduler.wait(1)\n\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\tthis.exporter.export(spans, (result) => {\n\t\t\t\tif (result.code === ExportResultCode.SUCCESS) {\n\t\t\t\t\tresolve()\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('exporting spans failed! ' + result.error)\n\t\t\t\t\treject(result.error)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t\tawait promise\n\t}\n}\n\ntype traceId = string\nexport class BatchTraceSpanProcessor implements TraceFlushableSpanProcessor {\n\tprivate traces: Record<traceId, TraceState> = {}\n\n\tconstructor(private exporter: SpanExporter) {}\n\n\tgetTraceState(traceId: string): TraceState {\n\t\tconst traceState = this.traces[traceId] || new TraceState(this.exporter)\n\t\tthis.traces[traceId] = traceState\n\t\treturn traceState\n\t}\n\n\tonStart(span: Span, _parentContext: Context): void {\n\t\tconst traceId = span.spanContext().traceId\n\t\tthis.getTraceState(traceId).addSpan(span)\n\t}\n\n\tonEnd(span: ReadableSpan): void {\n\t\tconst traceId = span.spanContext().traceId\n\t\tthis.getTraceState(traceId).endSpan(span)\n\t}\n\n\tasync forceFlush(traceId?: traceId): Promise<void> {\n\t\tif (traceId) {\n\t\t\tawait this.getTraceState(traceId).flush()\n\t\t} else {\n\t\t\tconst promises = Object.values(this.traces).map((traceState: TraceState) => traceState.flush)\n\t\t\tawait Promise.allSettled(promises)\n\t\t}\n\t}\n\n\tasync shutdown(): Promise<void> {\n\t\tawait this.forceFlush()\n\t}\n}\n","import { context, trace, Tracer, TracerOptions, TracerProvider } from '@opentelemetry/api'\n\nimport { SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { Resource } from '@opentelemetry/resources'\n\nimport { AsyncLocalStorageContextManager } from './context.js'\nimport { WorkerTracer } from './tracer.js'\n\n/**\n * Register this TracerProvider for use with the OpenTelemetry API.\n * Undefined values may be replaced with defaults, and\n * null values will be skipped.\n *\n * @param config Configuration object for SDK registration\n */\nexport class WorkerTracerProvider implements TracerProvider {\n\tprivate spanProcessors: SpanProcessor[]\n\tprivate resource: Resource\n\tprivate tracers: Record<string, Tracer> = {}\n\n\tconstructor(spanProcessors: SpanProcessor[], resource: Resource) {\n\t\tthis.spanProcessors = spanProcessors\n\t\tthis.resource = resource\n\t}\n\n\tgetTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n\t\tconst key = `${name}@${version || ''}:${options?.schemaUrl || ''}`\n\t\tif (!this.tracers[key]) {\n\t\t\tthis.tracers[key] = new WorkerTracer(this.spanProcessors, this.resource)\n\t\t}\n\t\treturn this.tracers[key]!\n\t}\n\n\tregister(): void {\n\t\ttrace.setGlobalTracerProvider(this)\n\t\tcontext.setGlobalContextManager(new AsyncLocalStorageContextManager())\n\t}\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextManager, Context, ROOT_CONTEXT } from '@opentelemetry/api'\n//@ts-ignore\nimport { AsyncLocalStorage } from 'node:async_hooks'\n//@ts-ignore\nimport { EventEmitter } from 'node:events'\n\ntype Func<T> = (...args: unknown[]) => T\n\n/**\n * Store a map for each event of all original listeners and their \"patched\"\n * version. So when a listener is removed by the user, the corresponding\n * patched function will be also removed.\n */\ninterface PatchMap {\n\t[name: string]: WeakMap<Func<void>, Func<void>>\n}\n\nconst ADD_LISTENER_METHODS = [\n\t'addListener' as const,\n\t'on' as const,\n\t'once' as const,\n\t'prependListener' as const,\n\t'prependOnceListener' as const,\n]\n\nabstract class AbstractAsyncHooksContextManager implements ContextManager {\n\tabstract active(): Context\n\n\tabstract with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\tcontext: Context,\n\t\tfn: F,\n\t\tthisArg?: ThisParameterType<F>,\n\t\t...args: A\n\t): ReturnType<F>\n\n\tabstract enable(): this\n\n\tabstract disable(): this\n\n\t/**\n\t * Binds a the certain context or the active one to the target function and then returns the target\n\t * @param context A context (span) to be bind to target\n\t * @param target a function or event emitter. When target or one of its callbacks is called,\n\t *  the provided context will be used as the active context for the duration of the call.\n\t */\n\tbind<T>(context: Context, target: T): T {\n\t\tif (target instanceof EventEmitter) {\n\t\t\treturn this._bindEventEmitter(context, target)\n\t\t}\n\n\t\tif (typeof target === 'function') {\n\t\t\treturn this._bindFunction(context, target)\n\t\t}\n\t\treturn target\n\t}\n\n\tprivate _bindFunction<T extends Function>(context: Context, target: T): T {\n\t\tconst manager = this\n\t\tconst contextWrapper = function (this: never, ...args: unknown[]) {\n\t\t\treturn manager.with(context, () => target.apply(this, args))\n\t\t}\n\t\tObject.defineProperty(contextWrapper, 'length', {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t\twritable: false,\n\t\t\tvalue: target.length,\n\t\t})\n\t\t/**\n\t\t * It isn't possible to tell Typescript that contextWrapper is the same as T\n\t\t * so we forced to cast as any here.\n\t\t */\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\treturn contextWrapper as any\n\t}\n\n\t/**\n\t * By default, EventEmitter call their callback with their context, which we do\n\t * not want, instead we will bind a specific context to all callbacks that\n\t * go through it.\n\t * @param context the context we want to bind\n\t * @param ee EventEmitter an instance of EventEmitter to patch\n\t */\n\tprivate _bindEventEmitter<T extends EventEmitter>(context: Context, ee: T): T {\n\t\tconst map = this._getPatchMap(ee)\n\t\tif (map !== undefined) return ee\n\t\tthis._createPatchMap(ee)\n\n\t\t// patch methods that add a listener to propagate context\n\t\tADD_LISTENER_METHODS.forEach((methodName) => {\n\t\t\tif (ee[methodName] === undefined) return\n\t\t\tee[methodName] = this._patchAddListener(ee, ee[methodName], context)\n\t\t})\n\t\t// patch methods that remove a listener\n\t\tif (typeof ee.removeListener === 'function') {\n\t\t\tee.removeListener = this._patchRemoveListener(ee, ee.removeListener)\n\t\t}\n\t\tif (typeof ee.off === 'function') {\n\t\t\tee.off = this._patchRemoveListener(ee, ee.off)\n\t\t}\n\t\t// patch method that remove all listeners\n\t\tif (typeof ee.removeAllListeners === 'function') {\n\t\t\tee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners)\n\t\t}\n\t\treturn ee\n\t}\n\n\t/**\n\t * Patch methods that remove a given listener so that we match the \"patched\"\n\t * version of that listener (the one that propagate context).\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t */\n\tprivate _patchRemoveListener(ee: EventEmitter, original: Function) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\tconst events = contextManager._getPatchMap(ee)?.[event]\n\t\t\tif (events === undefined) {\n\t\t\t\treturn original.call(this, event, listener)\n\t\t\t}\n\t\t\tconst patchedListener = events.get(listener)\n\t\t\treturn original.call(this, event, patchedListener || listener)\n\t\t}\n\t}\n\n\t/**\n\t * Patch methods that remove all listeners so we remove our\n\t * internal references for a given event.\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t */\n\tprivate _patchRemoveAllListeners(ee: EventEmitter, original: Function) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string) {\n\t\t\tconst map = contextManager._getPatchMap(ee)\n\t\t\tif (map !== undefined) {\n\t\t\t\tif (arguments.length === 0) {\n\t\t\t\t\tcontextManager._createPatchMap(ee)\n\t\t\t\t} else if (map[event] !== undefined) {\n\t\t\t\t\tdelete map[event]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn original.apply(this, arguments)\n\t\t}\n\t}\n\n\t/**\n\t * Patch methods on an event emitter instance that can add listeners so we\n\t * can force them to propagate a given context.\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t * @param [context] context to propagate when calling listeners\n\t */\n\tprivate _patchAddListener(ee: EventEmitter, original: Function, context: Context) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\t/**\n\t\t\t * This check is required to prevent double-wrapping the listener.\n\t\t\t * The implementation for ee.once wraps the listener and calls ee.on.\n\t\t\t * Without this check, we would wrap that wrapped listener.\n\t\t\t * This causes an issue because ee.removeListener depends on the onceWrapper\n\t\t\t * to properly remove the listener. If we wrap their wrapper, we break\n\t\t\t * that detection.\n\t\t\t */\n\t\t\tif (contextManager._wrapped) {\n\t\t\t\treturn original.call(this, event, listener)\n\t\t\t}\n\t\t\tlet map = contextManager._getPatchMap(ee)\n\t\t\tif (map === undefined) {\n\t\t\t\tmap = contextManager._createPatchMap(ee)\n\t\t\t}\n\t\t\tlet listeners = map[event]\n\t\t\tif (listeners === undefined) {\n\t\t\t\tlisteners = new WeakMap()\n\t\t\t\tmap[event] = listeners\n\t\t\t}\n\t\t\tconst patchedListener = contextManager.bind(context, listener)\n\t\t\t// store a weak reference of the user listener to ours\n\t\t\tlisteners.set(listener, patchedListener)\n\n\t\t\t/**\n\t\t\t * See comment at the start of this function for the explanation of this property.\n\t\t\t */\n\t\t\tcontextManager._wrapped = true\n\t\t\ttry {\n\t\t\t\treturn original.call(this, event, patchedListener)\n\t\t\t} finally {\n\t\t\t\tcontextManager._wrapped = false\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createPatchMap(ee: EventEmitter): PatchMap {\n\t\tconst map = Object.create(null)\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t;(ee as any)[this._kOtListeners] = map\n\t\treturn map\n\t}\n\tprivate _getPatchMap(ee: EventEmitter): PatchMap | undefined {\n\t\treturn (ee as never)[this._kOtListeners]\n\t}\n\n\tprivate readonly _kOtListeners = Symbol('OtListeners')\n\tprivate _wrapped = false\n}\n\nexport class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager {\n\tprivate _asyncLocalStorage: AsyncLocalStorage<Context>\n\n\tconstructor() {\n\t\tsuper()\n\t\tthis._asyncLocalStorage = new AsyncLocalStorage()\n\t}\n\n\tactive(): Context {\n\t\treturn this._asyncLocalStorage.getStore() ?? ROOT_CONTEXT\n\t}\n\n\twith<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\tcontext: Context,\n\t\tfn: F,\n\t\tthisArg?: ThisParameterType<F>,\n\t\t...args: A\n\t): ReturnType<F> {\n\t\tconst cb = thisArg == null ? fn : fn.bind(thisArg)\n\t\treturn this._asyncLocalStorage.run(context, cb as never, ...args)\n\t}\n\n\tenable(): this {\n\t\treturn this\n\t}\n\n\tdisable(): this {\n\t\tthis._asyncLocalStorage.disable()\n\t\treturn this\n\t}\n}\n","import {\n\tAttributes,\n\tTracer,\n\tTraceFlags,\n\tSpan,\n\tSpanKind,\n\tSpanOptions,\n\tContext,\n\tcontext as api_context,\n\ttrace,\n\tSpanContext,\n} from '@opentelemetry/api'\nimport { sanitizeAttributes } from '@opentelemetry/core'\nimport { Resource } from '@opentelemetry/resources'\nimport { SpanProcessor, RandomIdGenerator, ReadableSpan, SamplingDecision } from '@opentelemetry/sdk-trace-base'\n\nimport { SpanImpl } from './span.js'\nimport { getActiveConfig } from './config.js'\nimport { TraceFlushableSpanProcessor } from './types.js'\n\nenum NewTraceFlags {\n\tRANDOM_TRACE_ID_SET = 2,\n\tRANDOM_TRACE_ID_UNSET = 0,\n}\n\ntype NewTraceFlagValues = NewTraceFlags.RANDOM_TRACE_ID_SET | NewTraceFlags.RANDOM_TRACE_ID_UNSET\n\nconst idGenerator: RandomIdGenerator = new RandomIdGenerator()\n\nlet withNextSpanAttributes: Attributes\n\nfunction getFlagAt(flagSequence: number, position: number): number {\n\treturn ((flagSequence >> (position - 1)) & 1) * position\n}\n\nexport class WorkerTracer implements Tracer {\n\tprivate readonly spanProcessors: TraceFlushableSpanProcessor[]\n\tprivate readonly resource: Resource\n\tconstructor(spanProcessors: SpanProcessor[], resource: Resource) {\n\t\tthis.spanProcessors = spanProcessors\n\t\tthis.resource = resource\n\t}\n\n\tasync forceFlush(traceId?: string) {\n\t\tconst promises = this.spanProcessors.map(async (spanProcessor) => {\n\t\t\tawait spanProcessor.forceFlush(traceId)\n\t\t})\n\t\tawait Promise.allSettled(promises)\n\t}\n\n\taddToResource(extra: Resource) {\n\t\tthis.resource.merge(extra)\n\t}\n\n\tstartSpan(name: string, options: SpanOptions = {}, context = api_context.active()): Span {\n\t\tif (options.root) {\n\t\t\tcontext = trace.deleteSpan(context)\n\t\t}\n\n\t\tconst config = getActiveConfig()\n\t\tif (!config) throw new Error('Config is undefined. This is a bug in the instrumentation logic')\n\n\t\tconst parentSpanContext = trace.getSpan(context)?.spanContext()\n\t\tconst { traceId, randomTraceFlag } = getTraceInfo(parentSpanContext)\n\n\t\tconst spanKind = options.kind || SpanKind.INTERNAL\n\t\tconst sanitisedAttrs = sanitizeAttributes(options.attributes)\n\t\tconst sampler = config.sampling.headSampler\n\t\tconst samplingDecision = sampler.shouldSample(context, traceId, name, spanKind, sanitisedAttrs, [])\n\t\tconst { decision, traceState, attributes: attrs } = samplingDecision\n\n\t\tconst attributes = Object.assign({}, options.attributes, attrs, withNextSpanAttributes)\n\t\twithNextSpanAttributes = {}\n\n\t\tconst spanId = idGenerator.generateSpanId()\n\t\tconst parentSpanId = parentSpanContext?.spanId\n\n\t\tconst sampleFlag = decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE\n\t\tconst traceFlags = sampleFlag + randomTraceFlag\n\t\tconst spanContext = { traceId, spanId, traceFlags, traceState }\n\n\t\tconst span = new SpanImpl({\n\t\t\tattributes: sanitizeAttributes(attributes),\n\t\t\tname,\n\t\t\tonEnd: (span) => {\n\t\t\t\tthis.spanProcessors.forEach((sp) => {\n\t\t\t\t\tsp.onEnd(span as unknown as ReadableSpan)\n\t\t\t\t})\n\t\t\t},\n\t\t\tresource: this.resource,\n\t\t\tspanContext,\n\t\t\tparentSpanContext,\n\t\t\tparentSpanId,\n\t\t\tspanKind,\n\t\t\tstartTime: options.startTime,\n\t\t})\n\t\tthis.spanProcessors.forEach((sp) => {\n\t\t\t//Do not get me started on the idosyncracies of the Otel JS libraries.\n\t\t\t//@ts-ignore\n\t\t\tsp.onStart(span, context)\n\t\t})\n\t\treturn span\n\t}\n\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, fn: F): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, options: SpanOptions, fn: F): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(\n\t\tname: string,\n\t\toptions: SpanOptions,\n\t\tcontext: Context,\n\t\tfn: F,\n\t): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, ...args: unknown[]): ReturnType<F> {\n\t\tconst options = args.length > 1 ? (args[0] as SpanOptions) : undefined\n\t\tconst parentContext = args.length > 2 ? (args[1] as Context) : api_context.active()\n\t\tconst fn = args[args.length - 1] as F\n\n\t\tconst span = this.startSpan(name, options, parentContext)\n\t\tconst contextWithSpanSet = trace.setSpan(parentContext, span)\n\n\t\treturn api_context.with(contextWithSpanSet, fn, undefined, span)\n\t}\n}\n\nexport function withNextSpan(attrs: Attributes) {\n\twithNextSpanAttributes = Object.assign({}, withNextSpanAttributes, attrs)\n}\n\nfunction getTraceInfo(parentSpanContext?: SpanContext): { traceId: string; randomTraceFlag: NewTraceFlagValues } {\n\tif (parentSpanContext && trace.isSpanContextValid(parentSpanContext)) {\n\t\tconst { traceId, traceFlags } = parentSpanContext\n\t\treturn { traceId, randomTraceFlag: getFlagAt(traceFlags, 2) }\n\t} else {\n\t\treturn { traceId: idGenerator.generateTraceId(), randomTraceFlag: NewTraceFlags.RANDOM_TRACE_ID_SET }\n\t}\n}\n","import {\n\tAttributes,\n\tAttributeValue,\n\tException,\n\tHrTime,\n\tLink,\n\tSpan,\n\tSpanContext,\n\tSpanKind,\n\tSpanStatus,\n\tSpanStatusCode,\n\tTimeInput,\n} from '@opentelemetry/api'\nimport {\n\thrTimeDuration,\n\tInstrumentationScope,\n\tisAttributeValue,\n\tisTimeInput,\n\tsanitizeAttributes,\n} from '@opentelemetry/core'\nimport { Resource } from '@opentelemetry/resources'\nimport { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\n\ntype OnSpanEnd = (span: Span) => void\n\ninterface SpanInit {\n\tattributes: unknown\n\tname: string\n\tonEnd: OnSpanEnd\n\tresource: Resource\n\tspanContext: SpanContext\n\tparentSpanContext?: SpanContext\n\tlinks?: Link[]\n\tparentSpanId?: string\n\tspanKind?: SpanKind\n\tstartTime?: TimeInput\n}\n\nfunction transformExceptionAttributes(exception: Exception): Attributes {\n\tconst attributes: Attributes = {}\n\tif (typeof exception === 'string') {\n\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception\n\t} else {\n\t\tif (exception.code) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString()\n\t\t} else if (exception.name) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name\n\t\t}\n\t\tif (exception.message) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message\n\t\t}\n\t\tif (exception.stack) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack\n\t\t}\n\t}\n\treturn attributes\n}\n\nfunction millisToHr(millis: number): HrTime {\n\treturn [Math.trunc(millis / 1000), (millis % 1000) * 1e6]\n}\n\nfunction getHrTime(input?: TimeInput): HrTime {\n\tconst now = Date.now()\n\tif (!input) {\n\t\treturn millisToHr(now)\n\t} else if (input instanceof Date) {\n\t\treturn millisToHr(input.getTime())\n\t} else if (typeof input === 'number') {\n\t\t//TODO: do something with performance.now something\n\t\treturn millisToHr(input)\n\t} else if (Array.isArray(input)) {\n\t\treturn input\n\t}\n\n\tconst v: never = input\n\tthrow new Error(`unreachable value: ${JSON.stringify(v)}`)\n}\n\n// previously exported from OTel, now private\nfunction isAttributeKey(key: unknown): key is string {\n\treturn typeof key === 'string' && key.length > 0\n}\n\nexport class SpanImpl implements Span, ReadableSpan {\n\tname: string\n\tprivate readonly _spanContext: SpanContext\n\tprivate readonly onEnd: OnSpanEnd\n\treadonly parentSpanId?: string\n\treadonly parentSpanContext?: SpanContext | undefined\n\treadonly kind: SpanKind\n\treadonly attributes: Attributes\n\tstatus: SpanStatus = {\n\t\tcode: SpanStatusCode.UNSET,\n\t}\n\tendTime: HrTime = [0, 0]\n\tprivate _duration: HrTime = [0, 0]\n\treadonly startTime: HrTime\n\treadonly events: TimedEvent[] = []\n\treadonly links: Link[]\n\treadonly resource: Resource\n\tinstrumentationScope: InstrumentationScope = { name: '@microlabs/otel-cf-workers' }\n\tprivate _ended: boolean = false\n\tprivate _droppedAttributesCount: number = 0\n\tprivate _droppedEventsCount: number = 0\n\tprivate _droppedLinksCount: number = 0\n\n\tconstructor(init: SpanInit) {\n\t\tthis.name = init.name\n\t\tthis._spanContext = init.spanContext\n\t\tthis.parentSpanId = init.parentSpanId\n\t\tthis.parentSpanContext = init.parentSpanContext\n\t\tthis.kind = init.spanKind || SpanKind.INTERNAL\n\t\tthis.attributes = sanitizeAttributes(init.attributes)\n\t\tthis.startTime = getHrTime(init.startTime)\n\t\tthis.links = init.links || []\n\t\tthis.resource = init.resource\n\t\tthis.onEnd = init.onEnd\n\t}\n\n\taddLink(link: Link): this {\n\t\tthis.links.push(link)\n\t\treturn this\n\t}\n\taddLinks(links: Link[]): this {\n\t\tthis.links.push(...links)\n\t\treturn this\n\t}\n\n\tspanContext(): SpanContext {\n\t\treturn this._spanContext\n\t}\n\n\tsetAttribute(key: string, value?: AttributeValue): this {\n\t\tif (isAttributeKey(key) && isAttributeValue(value)) {\n\t\t\tthis.attributes[key] = value\n\t\t}\n\t\treturn this\n\t}\n\n\tsetAttributes(attributes: Attributes): this {\n\t\tfor (const [key, value] of Object.entries(attributes)) {\n\t\t\tthis.setAttribute(key, value)\n\t\t}\n\t\treturn this\n\t}\n\n\taddEvent(name: string, attributesOrStartTime?: Attributes | TimeInput, startTime?: TimeInput): this {\n\t\tif (isTimeInput(attributesOrStartTime)) {\n\t\t\tstartTime = attributesOrStartTime\n\t\t\tattributesOrStartTime = undefined\n\t\t}\n\n\t\tconst attributes = sanitizeAttributes(attributesOrStartTime)\n\t\tconst time = getHrTime(startTime)\n\t\tthis.events.push({ name, attributes, time })\n\t\treturn this\n\t}\n\n\tsetStatus(status: SpanStatus): this {\n\t\tthis.status = status\n\t\treturn this\n\t}\n\n\tupdateName(name: string): this {\n\t\tthis.name = name\n\t\treturn this\n\t}\n\n\tend(endTime?: TimeInput): void {\n\t\tif (this._ended) {\n\t\t\treturn\n\t\t}\n\t\tthis._ended = true\n\t\tthis.endTime = getHrTime(endTime)\n\t\tthis._duration = hrTimeDuration(this.startTime, this.endTime)\n\t\tthis.onEnd(this)\n\t}\n\n\tisRecording(): boolean {\n\t\treturn !this._ended\n\t}\n\n\trecordException(exception: Exception, time?: TimeInput): void {\n\t\tconst attributes = transformExceptionAttributes(exception)\n\t\tthis.addEvent('exception', attributes, time)\n\t}\n\n\tget duration(): HrTime {\n\t\treturn this._duration\n\t}\n\n\tget ended(): boolean {\n\t\treturn this._ended\n\t}\n\n\tget droppedAttributesCount(): number {\n\t\treturn this._droppedAttributesCount\n\t}\n\n\tget droppedEventsCount(): number {\n\t\treturn this._droppedEventsCount\n\t}\n\n\tget droppedLinksCount(): number {\n\t\treturn this._droppedLinksCount\n\t}\n}\n","import {\n\ttrace,\n\tSpanOptions,\n\tSpanKind,\n\tpropagation,\n\tcontext as api_context,\n\tAttributes,\n\tContext,\n\tSpan,\n\tException,\n\tSpanStatusCode,\n} from '@opentelemetry/api'\nimport { getActiveConfig } from '../config.js'\nimport { wrap } from '../wrap.js'\nimport { HandlerInstrumentation, OrPromise, ResolvedTraceConfig } from '../types.js'\nimport { ReadableSpan } from '@opentelemetry/sdk-trace-base'\n\ntype IncomingRequest = Parameters<ExportedHandlerFetchHandler>[0]\n\nexport type IncludeTraceContextFn = (request: Request) => boolean\nexport interface FetcherConfig {\n\tincludeTraceContext?: boolean | IncludeTraceContextFn\n}\n\nexport type AcceptTraceContextFn = (request: Request) => boolean\nexport interface FetchHandlerConfig {\n\t/**\n\t * Whether to enable context propagation for incoming requests to `fetch`.\n\t * This enables or disables distributed tracing from W3C Trace Context headers.\n\t * @default true\n\t */\n\tacceptTraceContext?: boolean | AcceptTraceContextFn\n}\n\nconst netKeysFromCF = new Set(['colo', 'country', 'request_priority', 'tls_cipher', 'tls_version', 'asn', 'tcp_rtt'])\n\nconst camelToSnakeCase = (s: string): string => {\n\treturn s.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n}\n\nconst gatherOutgoingCfAttributes = (cf: RequestInitCfProperties): Attributes => {\n\tconst attrs: Record<string, string | number> = {}\n\tObject.keys(cf).forEach((key) => {\n\t\tconst value = cf[key]\n\t\tconst destKey = camelToSnakeCase(key)\n\t\tif (!netKeysFromCF.has(destKey)) {\n\t\t\tif (typeof value === 'string' || typeof value === 'number') {\n\t\t\t\tattrs[`cf.${destKey}`] = value\n\t\t\t} else {\n\t\t\t\tattrs[`cf.${destKey}`] = JSON.stringify(value)\n\t\t\t}\n\t\t}\n\t})\n\treturn attrs\n}\n\nexport function gatherRequestAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tconst headers = request.headers\n\tattrs['http.request.method'] = request.method.toUpperCase()\n\tattrs['network.protocol.name'] = 'http'\n\tattrs['network.protocol.version'] = request.cf?.httpProtocol as string\n\tattrs['http.request.body.size'] = headers.get('content-length')!\n\tattrs['user_agent.original'] = headers.get('user-agent')!\n\tattrs['http.mime_type'] = headers.get('content-type')!\n\tattrs['http.accepts'] = request.cf?.clientAcceptEncoding as string\n\n\tconst u = new URL(request.url)\n\tattrs['url.full'] = `${u.protocol}//${u.host}${u.pathname}${u.search}`\n\tattrs['server.address'] = u.host\n\tattrs['url.scheme'] = u.protocol\n\tattrs['url.path'] = u.pathname\n\tattrs['url.query'] = u.search\n\n\treturn attrs\n}\n\nexport function gatherResponseAttributes(response: Response): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tattrs['http.response.status_code'] = response.status\n\tif (response.headers.get('content-length')! == null) {\n\t\tattrs['http.response.body.size'] = response.headers.get('content-length')!\n\t}\n\tattrs['http.mime_type'] = response.headers.get('content-type')!\n\treturn attrs\n}\n\nexport function gatherIncomingCfAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tattrs['net.colo'] = request.cf?.colo as string\n\tattrs['net.country'] = request.cf?.country as string\n\tattrs['net.request_priority'] = request.cf?.requestPriority as string\n\tattrs['net.tls_cipher'] = request.cf?.tlsCipher as string\n\tattrs['net.tls_version'] = request.cf?.tlsVersion as string\n\tattrs['net.asn'] = request.cf?.asn as number\n\tattrs['net.tcp_rtt'] = request.cf?.clientTcpRtt as number\n\treturn attrs\n}\n\nexport function getParentContextFromHeaders(headers: Headers): Context {\n\treturn propagation.extract(api_context.active(), headers, {\n\t\tget(headers, key) {\n\t\t\treturn headers.get(key) || undefined\n\t\t},\n\t\tkeys(headers) {\n\t\t\treturn [...headers.keys()]\n\t\t},\n\t})\n}\n\nexport function getParentContextFromRequest(request: Request) {\n\tconst workerConfig = getActiveConfig()\n\n\tif (workerConfig === undefined) {\n\t\treturn api_context.active()\n\t}\n\n\tconst acceptTraceContext =\n\t\ttypeof workerConfig.handlers.fetch.acceptTraceContext === 'function'\n\t\t\t? workerConfig.handlers.fetch.acceptTraceContext(request)\n\t\t\t: (workerConfig.handlers.fetch.acceptTraceContext ?? true)\n\treturn acceptTraceContext ? getParentContextFromHeaders(request.headers) : api_context.active()\n}\n\nfunction updateSpanNameOnRoute(span: Span, request: IncomingRequest) {\n\tconst readable = span as unknown as ReadableSpan\n\tif (readable.attributes['http.route']) {\n\t\tconst method = request.method.toUpperCase()\n\t\tspan.updateName(`${method} ${readable.attributes['http.route']}`)\n\t}\n}\n\nexport const fetchInstrumentation: HandlerInstrumentation<IncomingRequest, OrPromise<Response>> = {\n\tgetInitialSpanInfo: (request) => {\n\t\tconst spanContext = getParentContextFromRequest(request)\n\t\tconst attributes = {\n\t\t\t['faas.trigger']: 'http',\n\t\t\t['faas.invocation_id']: request.headers.get('cf-ray') ?? undefined,\n\t\t}\n\t\tObject.assign(attributes, gatherRequestAttributes(request))\n\t\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\t\tconst method = request.method.toUpperCase()\n\t\treturn {\n\t\t\tname: `fetchHandler ${method}`,\n\t\t\toptions: {\n\t\t\t\tattributes,\n\t\t\t\tkind: SpanKind.SERVER,\n\t\t\t},\n\t\t\tcontext: spanContext,\n\t\t}\n\t},\n\tgetAttributesFromResult: (response) => {\n\t\treturn gatherResponseAttributes(response)\n\t},\n\texecutionSucces: updateSpanNameOnRoute,\n\texecutionFailed: updateSpanNameOnRoute,\n}\n\ntype getFetchConfig = (config: ResolvedTraceConfig) => FetcherConfig\nexport function instrumentClientFetch(\n\tfetchFn: Fetcher['fetch'],\n\tconfigFn: getFetchConfig,\n\tattrs?: Attributes,\n): Fetcher['fetch'] {\n\tconst handler: ProxyHandler<Fetcher['fetch']> = {\n\t\tapply: (target, thisArg, argArray): Response | Promise<Response> => {\n\t\t\tconst request = new Request(argArray[0], argArray[1])\n\t\t\tif (!request.url.startsWith('http')) {\n\t\t\t\treturn Reflect.apply(target, thisArg, argArray)\n\t\t\t}\n\n\t\t\tconst workerConfig = getActiveConfig()\n\t\t\tif (!workerConfig) {\n\t\t\t\treturn Reflect.apply(target, thisArg, [request])\n\t\t\t}\n\t\t\tconst config = configFn(workerConfig)\n\n\t\t\tconst tracer = trace.getTracer('fetcher')\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes: attrs }\n\n\t\t\tconst host = new URL(request.url).host\n\t\t\tconst method = request.method.toUpperCase()\n\t\t\tconst spanName = typeof attrs?.['name'] === 'string' ? attrs?.['name'] : `fetch ${method} ${host}`\n\t\t\tconst promise = tracer.startActiveSpan(spanName, options, async (span) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst includeTraceContext =\n\t\t\t\t\t\ttypeof config.includeTraceContext === 'function'\n\t\t\t\t\t\t\t? config.includeTraceContext(request)\n\t\t\t\t\t\t\t: config.includeTraceContext\n\t\t\t\t\tif (includeTraceContext ?? true) {\n\t\t\t\t\t\tpropagation.inject(api_context.active(), request.headers, {\n\t\t\t\t\t\t\tset: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tspan.setAttributes(gatherRequestAttributes(request))\n\t\t\t\t\tif (request.cf) span.setAttributes(gatherOutgoingCfAttributes(request.cf))\n\t\t\t\t\tconst response = await Reflect.apply(target, thisArg, [request])\n\t\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\t\treturn response\n\t\t\t\t} catch (error: unknown) {\n\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\tthrow error\n\t\t\t\t} finally {\n\t\t\t\t\tspan.end()\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn promise\n\t\t},\n\t}\n\treturn wrap(fetchFn, handler, true)\n}\n\nexport function instrumentGlobalFetch(): void {\n\t//@ts-ignore For some reason the node types are imported and complain.\n\tglobalThis.fetch = instrumentClientFetch(globalThis.fetch, (config) => config.fetch)\n}\n","import { SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { wrap } from '../wrap.js'\n\ntype CacheFns = Cache[keyof Cache]\n\nconst tracer = trace.getTracer('cache instrumentation')\n\nfunction sanitiseURL(url: string): string {\n\tconst u = new URL(url)\n\treturn `${u.protocol}//${u.host}${u.pathname}${u.search}`\n}\n\nfunction instrumentFunction<T extends CacheFns>(fn: T, cacheName: string, op: string): T {\n\tconst handler: ProxyHandler<typeof fn> = {\n\t\tasync apply(target, thisArg, argArray) {\n\t\t\tconst attributes = {\n\t\t\t\t'cache.name': cacheName,\n\t\t\t\t'http.url': argArray[0].url ? sanitiseURL(argArray[0].url) : undefined,\n\t\t\t\t'cache.operation': op,\n\t\t\t}\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes }\n\t\t\treturn tracer.startActiveSpan(`Cache ${cacheName} ${op}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tif (op === 'match') {\n\t\t\t\t\tspan.setAttribute('cache.hit', !!result)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nfunction instrumentCache(cache: Cache, cacheName: string): Cache {\n\tconst handler: ProxyHandler<typeof cache> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'delete' || prop === 'match' || prop === 'put') {\n\t\t\t\tconst fn = Reflect.get(target, prop).bind(target)\n\t\t\t\treturn instrumentFunction(fn, cacheName, prop)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(cache, handler)\n}\n\nfunction instrumentOpen(openFn: CacheStorage['open']): CacheStorage['open'] {\n\tconst handler: ProxyHandler<typeof openFn> = {\n\t\tasync apply(target, thisArg, argArray) {\n\t\t\tconst cacheName = argArray[0]\n\t\t\tconst cache = await Reflect.apply(target, thisArg, argArray)\n\t\t\treturn instrumentCache(cache, cacheName)\n\t\t},\n\t}\n\treturn wrap(openFn, handler)\n}\n\nfunction _instrumentGlobalCache() {\n\tconst handler: ProxyHandler<typeof caches> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'default') {\n\t\t\t\tconst cache = target.default\n\t\t\t\treturn instrumentCache(cache, 'default')\n\t\t\t} else if (prop === 'open') {\n\t\t\t\tconst openFn = Reflect.get(target, prop).bind(target)\n\t\t\t\treturn instrumentOpen(openFn)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\t//@ts-ignore\n\tglobalThis.caches = wrap(caches, handler)\n}\n\nexport function instrumentGlobalCache() {\n\treturn _instrumentGlobalCache()\n}\n","import { trace, SpanKind, Attributes, Span, propagation, context as api_context } from '@opentelemetry/api'\nimport { unwrap, wrap } from '../wrap.js'\nimport { HandlerInstrumentation, InitialSpanInfo, OrPromise } from '../types.js'\nimport { ATTR_FAAS_TRIGGER, FAAS_TRIGGER_VALUE_PUBSUB } from '@opentelemetry/semantic-conventions/incubating'\n\ntype QueueHandler = ExportedHandlerQueueHandler<unknown, unknown>\nexport type QueueHandlerArgs = Parameters<QueueHandler>\n\nclass MessageStatusCount {\n\tsucceeded = 0\n\tfailed = 0\n\timplicitly_acked = 0\n\timplicitly_retried = 0\n\treadonly total: number\n\n\tconstructor(total: number) {\n\t\tthis.total = total\n\t}\n\n\tack() {\n\t\tthis.succeeded = this.succeeded + 1\n\t}\n\n\tackRemaining() {\n\t\tthis.implicitly_acked = this.total - this.succeeded - this.failed\n\t\tthis.succeeded = this.total - this.failed\n\t}\n\n\tretry() {\n\t\tthis.failed = this.failed + 1\n\t}\n\n\tretryRemaining() {\n\t\tthis.implicitly_retried = this.total - this.succeeded - this.failed\n\t\tthis.failed = this.total - this.succeeded\n\t}\n\n\ttoAttributes(): Attributes {\n\t\treturn {\n\t\t\t'queue.messages_count': this.total,\n\t\t\t'queue.messages_success': this.succeeded,\n\t\t\t'queue.messages_failed': this.failed,\n\t\t\t'queue.batch_success': this.succeeded === this.total,\n\t\t\t'queue.implicitly_acked': this.implicitly_acked,\n\t\t\t'queue.implicitly_retried': this.implicitly_retried,\n\t\t}\n\t}\n}\n\nconst addEvent = (name: string, msg?: Message) => {\n\tconst attrs: Attributes = {}\n\tif (msg) {\n\t\tattrs['queue.message_id'] = msg.id\n\t\tattrs['queue.message_timestamp'] = msg.timestamp.toISOString()\n\t}\n\ttrace.getActiveSpan()?.addEvent(name, attrs)\n}\n\nconst proxyQueueMessage = <Q>(msg: Message<Q>, count: MessageStatusCount): Message<Q> => {\n\tconst msgHandler: ProxyHandler<Message<Q>> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'ack') {\n\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('messageAck', msg)\n\t\t\t\t\t\tcount.ack()\n\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, msg, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else if (prop === 'retry') {\n\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('messageRetry', msg)\n\t\t\t\t\t\tcount.retry()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tconst result = Reflect.apply(fnTarget, msg, [])\n\t\t\t\t\t\treturn result\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop, msg)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(msg, msgHandler)\n}\n\nconst proxyMessageBatch = (batch: MessageBatch, count: MessageStatusCount) => {\n\tconst batchHandler: ProxyHandler<MessageBatch> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'messages') {\n\t\t\t\tconst messages = Reflect.get(target, prop)\n\t\t\t\tconst messagesHandler: ProxyHandler<MessageBatch['messages']> = {\n\t\t\t\t\tget: (target, prop) => {\n\t\t\t\t\t\tif (typeof prop === 'string' && !isNaN(parseInt(prop))) {\n\t\t\t\t\t\t\tconst message = Reflect.get(target, prop)\n\t\t\t\t\t\t\treturn proxyQueueMessage(message, count)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn wrap(messages, messagesHandler)\n\t\t\t} else if (prop === 'ackAll') {\n\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('ackAll')\n\t\t\t\t\t\tcount.ackRemaining()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else if (prop === 'retryAll') {\n\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('retryAll')\n\t\t\t\t\t\tcount.retryRemaining()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop)\n\t\t},\n\t}\n\treturn wrap(batch, batchHandler)\n}\n\nexport class QueueInstrumentation implements HandlerInstrumentation<MessageBatch, OrPromise<void>> {\n\tprivate count?: MessageStatusCount\n\n\tgetInitialSpanInfo(batch: MessageBatch): InitialSpanInfo {\n\t\treturn {\n\t\t\tname: `queueHandler ${batch.queue}`,\n\t\t\toptions: {\n\t\t\t\tattributes: {\n\t\t\t\t\t[ATTR_FAAS_TRIGGER]: FAAS_TRIGGER_VALUE_PUBSUB,\n\t\t\t\t\t'queue.name': batch.queue,\n\t\t\t\t},\n\t\t\t\tkind: SpanKind.CONSUMER,\n\t\t\t},\n\t\t}\n\t}\n\n\tinstrumentTrigger(batch: MessageBatch): MessageBatch {\n\t\tthis.count = new MessageStatusCount(batch.messages.length)\n\t\treturn proxyMessageBatch(batch, this.count)\n\t}\n\n\texecutionSucces(span: Span) {\n\t\tif (this.count) {\n\t\t\tthis.count.ackRemaining()\n\t\t\tspan.setAttributes(this.count.toAttributes())\n\t\t}\n\t}\n\n\texecutionFailed(span: Span) {\n\t\tif (this.count) {\n\t\t\tthis.count.retryRemaining()\n\t\t\tspan.setAttributes(this.count.toAttributes())\n\t\t}\n\t}\n}\n\ntype SimpleQueueRequest = {\n\tmetadata: Record<string, string>\n}\n\nfunction propagateContext(argArray: unknown[]) {\n\tconst shouldPropagate = argArray?.length > 0 && typeof argArray[0] === 'object'\n\n\tconst request = shouldPropagate ? (argArray[0] as SimpleQueueRequest) : undefined\n\tif (request) {\n\t\trequest.metadata = request.metadata ? request.metadata : {}\n\t}\n\tif (request) {\n\t\tpropagation.inject(api_context.active(), request.metadata, {\n\t\t\tset: (h, k, v) => (h[k] = typeof v === 'string' ? v : String(v)),\n\t\t})\n\t}\n}\n\nfunction instrumentQueueSend(fn: Queue<unknown>['send'], name: string): Queue<unknown>['send'] {\n\tconst tracer = trace.getTracer('queueSender')\n\tconst handler: ProxyHandler<Queue<unknown>['send']> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\treturn tracer.startActiveSpan(`PRODUCER ${name}.send`, async (span) => {\n\t\t\t\tpropagateContext(argArray)\n\t\t\t\tspan.setAttribute('queue.operation', 'send')\n\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\tspan.end()\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nfunction instrumentQueueSendBatch(fn: Queue<unknown>['sendBatch'], name: string): Queue<unknown>['sendBatch'] {\n\tconst tracer = trace.getTracer('queueSender')\n\tconst handler: ProxyHandler<Queue<unknown>['sendBatch']> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\treturn tracer.startActiveSpan(`PRODUCER ${name}.sendBatch`, async (span) => {\n\t\t\t\tspan.setAttribute('queue.operation', 'sendBatch')\n\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\tspan.end()\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nexport function instrumentQueueSender(queue: Queue<unknown>, name: string) {\n\tconst queueHandler: ProxyHandler<Queue<unknown>> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'send') {\n\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentQueueSend(sendFn, name)\n\t\t\t} else if (prop === 'sendBatch') {\n\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentQueueSendBatch(sendFn, name)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(queue, queueHandler)\n}\n","import { context as api_context, trace, SpanOptions, SpanKind, Exception, SpanStatusCode } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { passthroughGet, unwrap, wrap } from '../wrap.js'\nimport {\n\tgetParentContextFromHeaders,\n\tgatherIncomingCfAttributes,\n\tgatherRequestAttributes,\n\tgatherResponseAttributes,\n\tinstrumentClientFetch,\n} from './fetch.js'\nimport { instrumentEnv } from './env.js'\nimport { Initialiser, setConfig } from '../config.js'\nimport { instrumentStorage } from './do-storage.js'\nimport { DOConstructorTrigger } from '../types.js'\n\nimport { DurableObject as DurableObjectClass } from 'cloudflare:workers'\n\ntype DO = DurableObject | DurableObjectClass\ntype FetchFn = DurableObject['fetch']\ntype AlarmFn = DurableObject['alarm']\ntype Env = Record<string, unknown>\n\nfunction instrumentBindingStub(stub: DurableObjectStub, nsName: string): DurableObjectStub {\n\tconst stubHandler: ProxyHandler<typeof stub> = {\n\t\tget(target, prop, receiver) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetcher = Reflect.get(target, prop)\n\t\t\t\tconst attrs = {\n\t\t\t\t\tname: `Durable Object ${nsName}`,\n\t\t\t\t\t'do.namespace': nsName,\n\t\t\t\t\t'do.id': target.id.toString(),\n\t\t\t\t\t'do.id.name': target.id.name,\n\t\t\t\t}\n\t\t\t\treturn instrumentClientFetch(fetcher, () => ({ includeTraceContext: true }), attrs)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop, receiver)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(stub, stubHandler)\n}\n\nfunction instrumentBindingGet(getFn: DurableObjectNamespace['get'], nsName: string): DurableObjectNamespace['get'] {\n\tconst getHandler: ProxyHandler<DurableObjectNamespace['get']> = {\n\t\tapply(target, thisArg, argArray) {\n\t\t\tconst stub: DurableObjectStub = Reflect.apply(target, thisArg, argArray)\n\t\t\treturn instrumentBindingStub(stub, nsName)\n\t\t},\n\t}\n\treturn wrap(getFn, getHandler)\n}\n\nexport function instrumentDOBinding(ns: DurableObjectNamespace, nsName: string) {\n\tconst nsHandler: ProxyHandler<typeof ns> = {\n\t\tget(target, prop, receiver) {\n\t\t\tif (prop === 'get') {\n\t\t\t\tconst fn = Reflect.get(ns, prop, receiver)\n\t\t\t\treturn instrumentBindingGet(fn, nsName)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop, receiver)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(ns, nsHandler)\n}\n\nexport function instrumentState(state: DurableObjectState) {\n\tconst stateHandler: ProxyHandler<DurableObjectState> = {\n\t\tget(target, prop, receiver) {\n\t\t\tconst result = Reflect.get(target, prop, unwrap(receiver))\n\t\t\tif (prop === 'storage') {\n\t\t\t\treturn instrumentStorage(result.bind(target))\n\t\t\t} else if (typeof result === 'function') {\n\t\t\t\treturn result.bind(target)\n\t\t\t} else {\n\t\t\t\treturn result\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(state, stateHandler)\n}\n\nlet cold_start = true\nexport function executeDOFetch(fetchFn: FetchFn, request: Request, id: DurableObjectId): Promise<Response> {\n\tconst spanContext = getParentContextFromHeaders(request.headers)\n\n\tconst tracer = trace.getTracer('DO fetchHandler')\n\tconst attributes = {\n\t\t[SemanticAttributes.FAAS_TRIGGER]: 'http',\n\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst name = id.name || ''\n\tconst promise = tracer.startActiveSpan(`Durable Object Fetch ${name}`, options, spanContext, async (span) => {\n\t\ttry {\n\t\t\tconst response: Response = await fetchFn(request)\n\t\t\tif (response.ok) {\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t}\n\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\tspan.end()\n\n\t\t\treturn response\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function executeDOAlarm(alarmFn: NonNullable<AlarmFn>, id: DurableObjectId): Promise<void> {\n\tconst tracer = trace.getTracer('DO alarmHandler')\n\n\tconst name = id.name || ''\n\tconst promise = tracer.startActiveSpan(`Durable Object Alarm ${name}`, async (span) => {\n\t\tspan.setAttribute(SemanticAttributes.FAAS_COLDSTART, cold_start)\n\t\tcold_start = false\n\t\tspan.setAttribute('do.id', id.toString())\n\t\tif (id.name) span.setAttribute('do.name', id.name)\n\n\t\ttry {\n\t\t\tawait alarmFn()\n\t\t\tspan.end()\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n\nfunction instrumentFetchFn(fetchFn: FetchFn, initialiser: Initialiser, env: Env, id: DurableObjectId): FetchFn {\n\tconst fetchHandler: ProxyHandler<FetchFn> = {\n\t\tasync apply(target, thisArg, argArray: Parameters<FetchFn>) {\n\t\t\tconst request = argArray[0]\n\t\t\tconst config = initialiser(env, request)\n\t\t\tconst context = setConfig(config)\n\t\t\ttry {\n\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\treturn await api_context.with(context, executeDOFetch, undefined, bound, request, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetchFn, fetchHandler)\n}\n\nfunction instrumentAlarmFn(alarmFn: AlarmFn, initialiser: Initialiser, env: Env, id: DurableObjectId) {\n\tif (!alarmFn) return undefined\n\n\tconst alarmHandler: ProxyHandler<NonNullable<AlarmFn>> = {\n\t\tasync apply(target, thisArg) {\n\t\t\tconst config = initialiser(env, 'do-alarm')\n\t\t\tconst context = setConfig(config)\n\t\t\ttry {\n\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\treturn await api_context.with(context, executeDOAlarm, undefined, bound, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(alarmFn, alarmHandler)\n}\n\nfunction instrumentAnyFn(fn: () => any, initialiser: Initialiser, env: Env, _id: DurableObjectId) {\n\tif (!fn) return undefined\n\n\tconst fnHandler: ProxyHandler<() => any> = {\n\t\tasync apply(target, thisArg, argArray: []) {\n\t\t\tthisArg = unwrap(thisArg)\n\t\t\tconst config = initialiser(env, 'do-alarm')\n\t\t\tconst context = setConfig(config)\n\t\t\ttry {\n\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\treturn await api_context.with(context, () => bound.apply(thisArg, argArray), undefined)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nfunction instrumentDurableObject(\n\tdoObj: DO,\n\tinitialiser: Initialiser,\n\tenv: Env,\n\tstate: DurableObjectState,\n\tclassStyle: boolean,\n) {\n\tconst objHandler: ProxyHandler<DurableObject> = {\n\t\tget(target, prop) {\n\t\t\tif (classStyle && prop === 'ctx') {\n\t\t\t\treturn state\n\t\t\t} else if (classStyle && prop === 'env') {\n\t\t\t\treturn env\n\t\t\t} else if (prop === 'fetch') {\n\t\t\t\tconst fetchFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentFetchFn(fetchFn, initialiser, env, state.id)\n\t\t\t} else if (prop === 'alarm') {\n\t\t\t\tconst alarmFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentAlarmFn(alarmFn, initialiser, env, state.id)\n\t\t\t} else {\n\t\t\t\tconst result = Reflect.get(target, prop)\n\t\t\t\tif (typeof result === 'function') {\n\t\t\t\t\tresult.bind(doObj)\n\t\t\t\t\treturn instrumentAnyFn(result, initialiser, env, state.id)\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(doObj, objHandler)\n}\n\nexport type DOClass = { new (state: DurableObjectState, env: any): DO }\n\nexport function instrumentDOClass<C extends DOClass>(doClass: C, initialiser: Initialiser): C {\n\tconst classHandler: ProxyHandler<C> = {\n\t\tconstruct(target, [orig_state, orig_env]: ConstructorParameters<DOClass>) {\n\t\t\tconst trigger: DOConstructorTrigger = {\n\t\t\t\tid: orig_state.id.toString(),\n\t\t\t\tname: orig_state.id.name,\n\t\t\t}\n\t\t\tconst constructorConfig = initialiser(orig_env, trigger)\n\t\t\tconst context = setConfig(constructorConfig)\n\t\t\tconst state = instrumentState(orig_state)\n\t\t\tconst env = instrumentEnv(orig_env)\n\t\t\tconst classStyle = doClass.prototype instanceof DurableObjectClass\n\t\t\tconst createDO = () => {\n\t\t\t\tif (classStyle) {\n\t\t\t\t\treturn new target(orig_state, orig_env)\n\t\t\t\t} else {\n\t\t\t\t\treturn new target(state, env)\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst doObj = api_context.with(context, createDO)\n\n\t\t\treturn instrumentDurableObject(doObj, initialiser, env, state, classStyle)\n\t\t},\n\t}\n\treturn wrap(doClass, classHandler)\n}\n","import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst dbSystem = 'Cloudflare KV'\n\nconst KVAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\tdelete(_argArray) {\n\t\treturn {}\n\t},\n\tget(argArray) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts = argArray[1]\n\t\tif (typeof opts === 'string') {\n\t\t\tattrs['db.cf.kv.type'] = opts\n\t\t} else if (typeof opts === 'object') {\n\t\t\tattrs['db.cf.kv.type'] = opts.type\n\t\t\tattrs['db.cf.kv.cache_ttl'] = opts.cacheTtl\n\t\t}\n\t\treturn attrs\n\t},\n\tgetWithMetadata(argArray, result) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts = argArray[1]\n\t\tif (typeof opts === 'string') {\n\t\t\tattrs['db.cf.kv.type'] = opts\n\t\t} else if (typeof opts === 'object') {\n\t\t\tattrs['db.cf.kv.type'] = opts.type\n\t\t\tattrs['db.cf.kv.cache_ttl'] = opts.cacheTtl\n\t\t}\n\n\t\tattrs['db.cf.kv.metadata'] = true\n\t\tconst { cacheStatus } = result as KVNamespaceGetWithMetadataResult<any, any>\n\t\tif (typeof cacheStatus === 'string') {\n\t\t\tattrs['db.cf.kv.cache_status'] = cacheStatus\n\t\t}\n\t\treturn attrs\n\t},\n\tlist(argArray, result) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts: KVNamespaceListOptions = argArray[0] || {}\n\t\tconst { cursor, limit } = opts\n\t\tattrs['db.cf.kv.list_request_cursor'] = cursor || undefined\n\t\tattrs['db.cf.kv.list_limit'] = limit || undefined\n\t\tconst { list_complete, cacheStatus } = result as KVNamespaceListResult<any, any>\n\t\tattrs['db.cf.kv.list_complete'] = list_complete || undefined\n\t\tif (!list_complete) {\n\t\t\tattrs['db.cf.kv.list_response_cursor'] = cursor || undefined\n\t\t}\n\t\tif (typeof cacheStatus === 'string') {\n\t\t\tattrs['db.cf.kv.cache_status'] = cacheStatus\n\t\t}\n\t\treturn attrs\n\t},\n\tput(argArray) {\n\t\tconst attrs: Attributes = {}\n\t\tif (argArray.length > 2 && argArray[2]) {\n\t\t\tconst { expiration, expirationTtl, metadata } = argArray[2] as KVNamespacePutOptions\n\t\t\tattrs['db.cf.kv.expiration'] = expiration\n\t\t\tattrs['db.cf.kv.expiration_ttl'] = expirationTtl\n\t\t\tattrs['db.cf.kv.metadata'] = !!metadata\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentKVFn(fn: Function, name: string, operation: string) {\n\tconst tracer = trace.getTracer('KV')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst attributes = {\n\t\t\t\tbinding_type: 'KV',\n\t\t\t\t[SemanticAttributes.DB_NAME]: name,\n\t\t\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t\t\t}\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes,\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`KV ${name} ${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrsFn = KVAttributes[operation]\n\t\t\t\tconst extraAttrs = extraAttrsFn ? extraAttrsFn(argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tif (operation === 'list') {\n\t\t\t\t\tconst opts: KVNamespaceListOptions = argArray[0] || {}\n\t\t\t\t\tconst { prefix } = opts\n\t\t\t\t\tspan.setAttribute(SemanticAttributes.DB_STATEMENT, `${operation} ${prefix || undefined}`)\n\t\t\t\t} else {\n\t\t\t\t\tspan.setAttribute(SemanticAttributes.DB_STATEMENT, `${operation} ${argArray[0]}`)\n\t\t\t\t\tspan.setAttribute('db.cf.kv.key', argArray[0])\n\t\t\t\t}\n\t\t\t\tif (operation === 'getWithMetadata') {\n\t\t\t\t\tconst hasResults = !!result && !!(result as KVNamespaceGetWithMetadataResult<string, unknown>).value\n\t\t\t\t\tspan.setAttribute('db.cf.kv.has_result', hasResults)\n\t\t\t\t} else {\n\t\t\t\t\tspan.setAttribute('db.cf.kv.has_result', !!result)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentKV(kv: KVNamespace, name: string): KVNamespace {\n\tconst kvHandler: ProxyHandler<KVNamespace> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentKVFn(fn, name, operation)\n\t\t},\n\t}\n\treturn wrap(kv, kvHandler)\n}\n","import {\n\tcontext as api_context,\n\tAttributes,\n\tpropagation,\n\tSpanKind,\n\tSpanOptions,\n\tSpanStatusCode,\n\ttrace,\n} from '@opentelemetry/api'\nimport { ResolvedTraceConfig } from '../../dist/index.mjs'\nimport { unwrap, wrap } from '../wrap.js'\nimport { FetcherConfig, instrumentClientFetch } from './fetch.js'\nimport { getActiveConfig } from '../config.js'\nimport { should } from 'vitest'\n\nexport function instrumentServiceBinding(fetcher: Fetcher, envName: string): Fetcher {\n\tconst fetcherHandler: ProxyHandler<Fetcher> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetcher = Reflect.get(target, prop)\n\t\t\t\tconst attrs = {\n\t\t\t\t\tname: `Service Binding ${envName}`,\n\t\t\t\t}\n\t\t\t\treturn instrumentClientFetch(fetcher, () => ({ includeTraceContext: true }), attrs)\n\t\t\t} else {\n\t\t\t\treturn instrumentClientRpcIfNeeded(target, envName, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetcher, fetcherHandler)\n}\n\nexport function instrumentClientRpcIfNeeded(target: any, envName: string, prop: string | symbol, thisArg?: any) {\n\tconst unwrappedTarget = unwrap(target)\n\tconst value = Reflect.get(unwrappedTarget, prop)\n\tif (typeof value === 'function') {\n\t\tif (value.constructor.name === 'RpcProperty') {\n\t\t\tconst attrs = {\n\t\t\t\tname: `RPC call ${envName}.${String(prop)}`,\n\t\t\t}\n\t\t\treturn instrumentClientRpc(value, () => ({ includeTraceContext: true }), attrs)\n\t\t}\n\t\tthisArg = thisArg || unwrappedTarget\n\t\treturn value.bind(thisArg)\n\t} else {\n\t\treturn value\n\t}\n}\n\ntype SimpleRpcRequest = {\n\tmetadata: Record<string, string>\n}\n\ntype getFetchConfig = (config: ResolvedTraceConfig) => FetcherConfig\nexport function instrumentClientRpc(\n\tfetchFn: Fetcher['fetch'],\n\tconfigFn: getFetchConfig,\n\tattrs?: Attributes,\n): Fetcher['fetch'] {\n\tconst handler: ProxyHandler<Fetcher['fetch']> = {\n\t\tapply: (target, thisArg, argArray): Response | Promise<Response> => {\n\t\t\tconst shouldPropagate = argArray?.length > 0 && typeof argArray[0] === 'object'\n\n\t\t\tconst request = shouldPropagate ? (argArray[0] as SimpleRpcRequest) : undefined\n\t\t\tif (request) {\n\t\t\t\trequest.metadata = request.metadata ? request.metadata : {}\n\t\t\t}\n\n\t\t\tconst workerConfig = getActiveConfig()\n\t\t\tif (!workerConfig) {\n\t\t\t\treturn Reflect.apply(target, thisArg, [request])\n\t\t\t}\n\t\t\tconst config = configFn(workerConfig)\n\n\t\t\tconst tracer = trace.getTracer('rpc')\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes: attrs }\n\n\t\t\tconst spanName = typeof attrs?.['name'] === 'string' ? attrs?.['name'] : `RPC call`\n\t\t\tconst promise = tracer.startActiveSpan(spanName, options, async (span) => {\n\t\t\t\tconst includeTraceContext = config.includeTraceContext ?? true\n\t\t\t\tif (request && includeTraceContext) {\n\t\t\t\t\tpropagation.inject(api_context.active(), request.metadata, {\n\t\t\t\t\t\tset: (h, k, v) => (h[k] = typeof v === 'string' ? v : String(v)),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn await Reflect.apply(target, thisArg, [request])\n\t\t\t\t} catch (err) {\n\t\t\t\t\tspan?.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\tthrow err\n\t\t\t\t} finally {\n\t\t\t\t\tspan.end()\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn promise\n\t\t},\n\t}\n\treturn wrap(fetchFn, handler, true)\n}\n","import { Attributes, SpanKind, SpanOptions, SpanStatusCode, Exception, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\n\nconst dbSystem = 'Cloudflare D1'\n\n// We need to peak into D1 \"internals\" to instrument batch queries\n// See: https://github.com/cloudflare/workerd/blob/5d27f8f7f1f9b584f673d2f11c9032f5a776ec55/src/cloudflare/internal/d1-api.ts#L173\ninterface D1StatementInternals {\n\tstatement: string\n\tparams: unknown[]\n}\n\nfunction metaAttributes(meta: D1Meta): Attributes {\n\treturn {\n\t\t'db.cf.d1.rows_read': meta.rows_read,\n\t\t'db.cf.d1.rows_written': meta.rows_written,\n\t\t'db.cf.d1.duration': meta.duration,\n\t\t'db.cf.d1.size_after': meta.size_after,\n\t\t'db.cf.d1.last_row_id': meta.last_row_id,\n\t\t'db.cf.d1.changed_db': meta.changed_db,\n\t\t'db.cf.d1.changes': meta.changes,\n\t}\n}\nfunction spanOptions(dbName: string, operation: string, sql?: string): SpanOptions {\n\tconst attributes: Attributes = {\n\t\tbinding_type: 'D1',\n\t\t[SemanticAttributes.DB_NAME]: dbName,\n\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t}\n\tif (sql) {\n\t\tattributes[SemanticAttributes.DB_STATEMENT] = sql\n\t}\n\treturn {\n\t\tkind: SpanKind.CLIENT,\n\t\tattributes,\n\t}\n}\n\nfunction instrumentD1StatementFn(fn: Function, dbName: string, operation: string, sql: string) {\n\tconst tracer = trace.getTracer('D1')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tif (operation === 'bind') {\n\t\t\t\tconst newStmt = Reflect.apply(target, thisArg, argArray) as D1PreparedStatement\n\t\t\t\treturn instrumentD1PreparedStatement(newStmt, dbName, sql)\n\t\t\t}\n\n\t\t\tconst options = spanOptions(dbName, operation, sql)\n\t\t\treturn tracer.startActiveSpan(`${dbName} ${operation}`, options, async (span) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\t\tif (operation === 'all' || operation === 'run') {\n\t\t\t\t\t\tspan.setAttributes(metaAttributes((result as D1Result).meta))\n\t\t\t\t\t}\n\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t\treturn result\n\t\t\t\t} catch (error) {\n\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\tthrow error\n\t\t\t\t} finally {\n\t\t\t\t\tspan.end()\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nfunction instrumentD1PreparedStatement(\n\tstmt: D1PreparedStatement,\n\tdbName: string,\n\tstatement: string,\n): D1PreparedStatement {\n\tconst statementHandler: ProxyHandler<D1PreparedStatement> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\tif (typeof fn === 'function') {\n\t\t\t\treturn instrumentD1StatementFn(fn, dbName, operation, statement)\n\t\t\t}\n\t\t\treturn fn\n\t\t},\n\t}\n\treturn wrap(stmt, statementHandler)\n}\n\nexport function instrumentD1Fn(fn: Function, dbName: string, operation: string) {\n\tconst tracer = trace.getTracer('D1')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tif (operation === 'prepare') {\n\t\t\t\tconst sql = argArray[0] as string\n\t\t\t\tconst stmt = Reflect.apply(target, thisArg, argArray) as D1PreparedStatement\n\t\t\t\treturn instrumentD1PreparedStatement(stmt, dbName, sql)\n\t\t\t} else if (operation === 'exec') {\n\t\t\t\tconst sql = argArray[0] as string\n\t\t\t\tconst options = spanOptions(dbName, operation, sql)\n\t\t\t\treturn tracer.startActiveSpan(`${dbName} ${operation}`, options, async (span) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t\t\treturn result\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tspan.end()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else if (operation === 'batch') {\n\t\t\t\t// Create span for each statement, requires peeaking into D1 internals ...\n\t\t\t\tconst statements = argArray[0] as D1StatementInternals[]\n\t\t\t\treturn tracer.startActiveSpan(`${dbName} ${operation}`, async (span) => {\n\t\t\t\t\t// Create a span per query in the batch\n\t\t\t\t\tconst subSpans = statements.map((s) =>\n\t\t\t\t\t\ttracer.startSpan(`${dbName} ${operation} > query`, spanOptions(dbName, operation, s.statement)),\n\t\t\t\t\t)\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = (await Reflect.apply(target, thisArg, argArray)) as D1Result[]\n\t\t\t\t\t\tresult.forEach((r, i) => subSpans[i]?.setAttributes(metaAttributes(r.meta)))\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t\t\treturn result\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubSpans.forEach((s) => s.end())\n\t\t\t\t\t\tspan.end()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn Reflect.apply(target, thisArg, argArray)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentD1(database: D1Database, dbName: string): D1Database {\n\tconst dbHandler: ProxyHandler<D1Database> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\tif (typeof fn === 'function') {\n\t\t\t\treturn instrumentD1Fn(fn, dbName, operation)\n\t\t\t}\n\t\t\treturn fn\n\t\t},\n\t}\n\treturn wrap(database, dbHandler)\n}\n","import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst dbSystem = 'Cloudflare Analytics Engine'\n\nconst AEAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\twriteDataPoint(argArray) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts = argArray[0]\n\t\tif (typeof opts === 'object') {\n\t\t\tattrs['db.cf.ae.indexes'] = opts.indexes.length\n\t\t\tattrs['db.cf.ae.index'] = (opts.indexes[0] as ArrayBuffer | string).toString()\n\t\t\tattrs['db.cf.ae.doubles'] = opts.doubles.length\n\t\t\tattrs['db.cf.ae.blobs'] = opts.blobs.length\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentAEFn(fn: Function, name: string, operation: string) {\n\tconst tracer = trace.getTracer('AnalyticsEngine')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst attributes = {\n\t\t\t\tbinding_type: 'AnalyticsEngine',\n\t\t\t\t[SemanticAttributes.DB_NAME]: name,\n\t\t\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t\t\t}\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes,\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`Analytics Engine ${name} ${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrsFn = AEAttributes[operation]\n\t\t\t\tconst extraAttrs = extraAttrsFn ? extraAttrsFn(argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tspan.setAttribute(SemanticAttributes.DB_STATEMENT, `${operation} ${argArray[0]}`)\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentAnalyticsEngineDataset(\n\tdataset: AnalyticsEngineDataset,\n\tname: string,\n): AnalyticsEngineDataset {\n\tconst datasetHandler: ProxyHandler<AnalyticsEngineDataset> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentAEFn(fn, name, operation)\n\t\t},\n\t}\n\treturn wrap(dataset, datasetHandler)\n}\n","import { isProxyable, wrap } from '../wrap.js'\nimport { instrumentDOBinding } from './do.js'\nimport { instrumentKV } from './kv.js'\nimport { instrumentQueueSender } from './queue.js'\nimport { instrumentServiceBinding } from './service.js'\nimport { instrumentD1 } from './d1'\nimport { instrumentAnalyticsEngineDataset } from './analytics-engine.js'\n\nconst isJSRPC = (item?: unknown): item is Service => {\n\t// @ts-expect-error The point of RPC types is to block non-existent properties, but that's the goal here\n\treturn !!(item as Service)?.['__some_property_that_will_never_exist' + Math.random()]\n}\n\nconst isKVNamespace = (item?: unknown): item is KVNamespace => {\n\treturn !isJSRPC(item) && !!(item as KVNamespace)?.getWithMetadata\n}\n\nconst isQueue = (item?: unknown): item is Queue<unknown> => {\n\treturn !isJSRPC(item) && !!(item as Queue<unknown>)?.sendBatch\n}\n\nconst isDurableObject = (item?: unknown): item is DurableObjectNamespace => {\n\treturn !isJSRPC(item) && !!(item as DurableObjectNamespace)?.idFromName\n}\n\nexport const isVersionMetadata = (item?: unknown): item is WorkerVersionMetadata => {\n\treturn (\n\t\t!isJSRPC(item) &&\n\t\ttypeof (item as WorkerVersionMetadata)?.id === 'string' &&\n\t\ttypeof (item as WorkerVersionMetadata)?.tag === 'string'\n\t)\n}\n\nconst isAnalyticsEngineDataset = (item?: unknown): item is AnalyticsEngineDataset => {\n\treturn !isJSRPC(item) && !!(item as AnalyticsEngineDataset)?.writeDataPoint\n}\n\nconst isD1Database = (item?: unknown): item is D1Database => {\n\treturn !!(item as D1Database)?.exec && !!(item as D1Database)?.prepare\n}\n\nconst instrumentEnv = <E extends Record<string, unknown>>(env: E): E => {\n\tconst envHandler: ProxyHandler<Record<string, unknown>> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst item = Reflect.get(target, prop, receiver)\n\t\t\tif (!isProxyable(item)) {\n\t\t\t\treturn item\n\t\t\t}\n\t\t\tif (isJSRPC(item)) {\n\t\t\t\treturn instrumentServiceBinding(item, String(prop))\n\t\t\t} else if (isKVNamespace(item)) {\n\t\t\t\treturn instrumentKV(item, String(prop))\n\t\t\t} else if (isQueue(item)) {\n\t\t\t\treturn instrumentQueueSender(item, String(prop))\n\t\t\t} else if (isDurableObject(item)) {\n\t\t\t\treturn instrumentDOBinding(item, String(prop))\n\t\t\t} else if (isVersionMetadata(item)) {\n\t\t\t\t// we do not need to log accesses to the metadata\n\t\t\t\treturn item\n\t\t\t} else if (isAnalyticsEngineDataset(item)) {\n\t\t\t\treturn instrumentAnalyticsEngineDataset(item, String(prop))\n\t\t\t} else if (isD1Database(item)) {\n\t\t\t\treturn instrumentD1(item, String(prop))\n\t\t\t} else {\n\t\t\t\treturn item\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(env, envHandler) as E\n}\n\nexport { instrumentEnv }\n","import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\nimport { Overloads } from './common.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst dbSystem = 'Cloudflare DO'\n\ntype DurableObjectCommonOptions = Pick<DurableObjectPutOptions, 'allowConcurrency' | 'allowUnconfirmed' | 'noCache'>\nfunction isDurableObjectCommonOptions(options: any): options is DurableObjectCommonOptions {\n\treturn (\n\t\ttypeof options === 'object' &&\n\t\t('allowConcurrency' in options || 'allowUnconfirmed' in options || 'noCache' in options)\n\t)\n}\n\n/** Applies attributes for common Durable Objects options:\n * `allowConcurrency`, `allowUnconfirmed`, and `noCache`\n */\nfunction applyOptionsAttributes(attrs: Attributes, options: DurableObjectCommonOptions) {\n\tif ('allowConcurrency' in options) {\n\t\tattrs['db.cf.do.allow_concurrency'] = options.allowConcurrency\n\t}\n\tif ('allowUnconfirmed' in options) {\n\t\tattrs['db.cf.do.allow_unconfirmed'] = options.allowUnconfirmed\n\t}\n\tif ('noCache' in options) {\n\t\tattrs['db.cf.do.no_cache'] = options.noCache\n\t}\n}\n\nconst StorageAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\tdelete(argArray, result: Awaited<ReturnType<Overloads<DurableObjectStorage['delete']>>>) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['delete']>>\n\t\tlet attrs: Attributes = {}\n\t\tif (Array.isArray(args[0])) {\n\t\t\tconst keys = args[0]\n\t\t\tattrs = {\n\t\t\t\t// todo: Maybe set db.cf.do.keys to the whole array here?\n\t\t\t\t'db.cf.do.key': keys[0],\n\t\t\t\t'db.cf.do.number_of_keys': keys.length,\n\t\t\t\t'db.cf.do.keys_deleted': result,\n\t\t\t}\n\t\t} else {\n\t\t\tattrs = {\n\t\t\t\t'db.cf.do.key': args[0],\n\t\t\t\t'db.cf.do.success': result,\n\t\t\t}\n\t\t}\n\t\tif (args[1]) {\n\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tdeleteAll(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['deleteAll']>>\n\t\tlet attrs: Attributes = {}\n\t\tif (args[0]) {\n\t\t\tapplyOptionsAttributes(attrs, args[0])\n\t\t}\n\t\treturn attrs\n\t},\n\tget(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['get']>>\n\t\tlet attrs: Attributes = {}\n\t\tif (Array.isArray(args[0])) {\n\t\t\tconst keys = args[0]\n\t\t\tattrs = {\n\t\t\t\t// todo: Maybe set db.cf.do.keys to the whole array here?\n\t\t\t\t'db.cf.do.key': keys[0],\n\t\t\t\t'db.cf.do.number_of_keys': keys.length,\n\t\t\t}\n\t\t} else {\n\t\t\tattrs = {\n\t\t\t\t'db.cf.do.key': args[0],\n\t\t\t}\n\t\t}\n\t\tif (args[1]) {\n\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tlist(argArray, result: Awaited<ReturnType<Overloads<DurableObjectStorage['list']>>>) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['list']>>\n\t\tconst attrs: Attributes = {\n\t\t\t'db.cf.do.number_of_results': result.size,\n\t\t}\n\t\tif (args[0]) {\n\t\t\tconst options = args[0]\n\t\t\tapplyOptionsAttributes(attrs, options)\n\t\t\tif ('start' in options) {\n\t\t\t\tattrs['db.cf.do.start'] = options.start\n\t\t\t}\n\t\t\tif ('startAfter' in options) {\n\t\t\t\tattrs['db.cf.do.start_after'] = options.startAfter\n\t\t\t}\n\t\t\tif ('end' in options) {\n\t\t\t\tattrs['db.cf.do.end'] = options.end\n\t\t\t}\n\t\t\tif ('prefix' in options) {\n\t\t\t\tattrs['db.cf.do.prefix'] = options.prefix\n\t\t\t}\n\t\t\tif ('reverse' in options) {\n\t\t\t\tattrs['db.cf.do.reverse'] = options.reverse\n\t\t\t}\n\t\t\tif ('limit' in options) {\n\t\t\t\tattrs['db.cf.do.limit'] = options.limit\n\t\t\t}\n\t\t}\n\t\treturn attrs\n\t},\n\tput(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['put']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (typeof args[0] === 'string') {\n\t\t\tattrs['db.cf.do.key'] = args[0]\n\t\t\tif (args[2]) {\n\t\t\t\tapplyOptionsAttributes(attrs, args[2])\n\t\t\t}\n\t\t} else {\n\t\t\tconst keys = Object.keys(args[0])\n\t\t\t// todo: Maybe set db.cf.do.keys to the whole array here?\n\t\t\tattrs['db.cf.do.key'] = keys[0]\n\t\t\tattrs['db.cf.do.number_of_keys'] = keys.length\n\t\t\tif (isDurableObjectCommonOptions(args[1])) {\n\t\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t\t}\n\t\t}\n\t\treturn attrs\n\t},\n\tgetAlarm(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['getAlarm']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (args[0]) {\n\t\t\tapplyOptionsAttributes(attrs, args[0])\n\t\t}\n\t\treturn attrs\n\t},\n\tsetAlarm(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['setAlarm']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (args[0] instanceof Date) {\n\t\t\tattrs['db.cf.do.alarm_time'] = args[0].getTime()\n\t\t} else {\n\t\t\tattrs['db.cf.do.alarm_time'] = args[0]\n\t\t}\n\t\tif (args[1]) {\n\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tdeleteAlarm(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['deleteAlarm']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (args[0]) {\n\t\t\tapplyOptionsAttributes(attrs, args[0])\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentStorageFn(fn: Function, operation: string) {\n\tconst tracer = trace.getTracer('do_storage')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst attributes = {\n\t\t\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t\t\t\t[SemanticAttributes.DB_STATEMENT]: `${operation} ${argArray[0]}`,\n\t\t\t}\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes: {\n\t\t\t\t\t...attributes,\n\t\t\t\t\toperation,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`Durable Object Storage ${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrsFn = StorageAttributes[operation]\n\t\t\t\tconst extraAttrs = extraAttrsFn ? extraAttrsFn(argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tspan.setAttribute('db.cf.do.has_result', !!result)\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentStorage(storage: DurableObjectStorage): DurableObjectStorage {\n\tconst storageHandler: ProxyHandler<DurableObjectStorage> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentStorageFn(fn, operation)\n\t\t},\n\t}\n\treturn wrap(storage, storageHandler)\n}\n","import { SpanKind } from '@opentelemetry/api'\nimport { HandlerInstrumentation, InitialSpanInfo, OrPromise } from '../types.js'\nimport {\n\tATTR_FAAS_CRON,\n\tATTR_FAAS_TIME,\n\tATTR_FAAS_TRIGGER,\n\tFAAS_TRIGGER_VALUE_TIMER,\n} from '@opentelemetry/semantic-conventions/incubating'\n\nexport const scheduledInstrumentation: HandlerInstrumentation<ScheduledController, OrPromise<void>> = {\n\tgetInitialSpanInfo: function (controller: ScheduledController): InitialSpanInfo {\n\t\treturn {\n\t\t\tname: `scheduledHandler ${controller.cron}`,\n\t\t\toptions: {\n\t\t\t\tattributes: {\n\t\t\t\t\t[ATTR_FAAS_TRIGGER]: FAAS_TRIGGER_VALUE_TIMER,\n\t\t\t\t\t[ATTR_FAAS_CRON]: controller.cron,\n\t\t\t\t\t[ATTR_FAAS_TIME]: new Date(controller.scheduledTime).toISOString(),\n\t\t\t\t},\n\t\t\t\tkind: SpanKind.INTERNAL,\n\t\t\t},\n\t\t}\n\t},\n}\n","import { isVersionMetadata } from './env.js'\n\nexport function versionAttributes(env: unknown): Record<string, string | undefined> {\n\tconst attributes = {} as Record<string, string | undefined>\n\n\tif (typeof env === 'object' && env !== null) {\n\t\tfor (const [binding, data] of Object.entries(env)) {\n\t\t\tif (isVersionMetadata(data)) {\n\t\t\t\tattributes['cf.workers_version_metadata.binding'] = binding\n\t\t\t\tattributes['cf.workers_version_metadata.id'] = data.id\n\t\t\t\tattributes['cf.workers_version_metadata.tag'] = data.tag\n\t\t\t\t// Version metadata bindings are identical, so we can stop after the first one found\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn attributes\n}\n","import { trace } from '@opentelemetry/api'\nimport { WorkerTracer } from '../tracer.js'\nimport { passthroughGet, wrap } from '../wrap.js'\n\ntype ContextAndTracker = { ctx: ExecutionContext; tracker: PromiseTracker }\ntype WaitUntilFn = ExecutionContext['waitUntil']\n\nexport class PromiseTracker {\n\t_outstandingPromises: Promise<unknown>[] = []\n\n\tget outstandingPromiseCount() {\n\t\treturn this._outstandingPromises.length\n\t}\n\n\ttrack(promise: Promise<unknown>): void {\n\t\tthis._outstandingPromises.push(promise)\n\t}\n\n\tasync wait() {\n\t\tawait allSettledMutable(this._outstandingPromises)\n\t}\n}\n\nfunction createWaitUntil(fn: WaitUntilFn, context: ExecutionContext, tracker: PromiseTracker): WaitUntilFn {\n\tconst handler: ProxyHandler<WaitUntilFn> = {\n\t\tapply(target, _thisArg, argArray) {\n\t\t\ttracker.track(argArray[0])\n\t\t\treturn Reflect.apply(target, context, argArray)\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nexport function proxyExecutionContext(context: ExecutionContext): ContextAndTracker {\n\tconst tracker = new PromiseTracker()\n\tconst ctx = new Proxy(context, {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'waitUntil') {\n\t\t\t\tconst fn = Reflect.get(target, prop)\n\t\t\t\treturn createWaitUntil(fn, context, tracker)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t})\n\treturn { ctx, tracker }\n}\n\nexport async function exportSpans(tracker?: PromiseTracker) {\n\tconst tracer = trace.getTracer('export')\n\tif (tracer instanceof WorkerTracer) {\n\t\tawait scheduler.wait(1)\n\t\tawait tracker?.wait()\n\t\tawait tracer.forceFlush()\n\t} else {\n\t\tconsole.error('The global tracer is not of type WorkerTracer and can not export spans')\n\t}\n}\n\n/** Like `Promise.allSettled`, but handles modifications to the promises array */\nasync function allSettledMutable(promises: Promise<unknown>[]): Promise<PromiseSettledResult<unknown>[]> {\n\tlet values: PromiseSettledResult<unknown>[]\n\t// when the length of the array changes, there has been a nested call to waitUntil\n\t// and we should await the promises again\n\tdo {\n\t\tvalues = await Promise.allSettled(promises)\n\t} while (values.length !== promises.length)\n\treturn values\n}\n\n/** Overloads extracts up to 4 overloads for the given function. */\nexport type Overloads<T> = T extends {\n\t(...args: infer P1): infer R1\n\t(...args: infer P2): infer R2\n\t(...args: infer P3): infer R3\n\t(...args: infer P4): infer R4\n}\n\t? ((...args: P1) => R1) | ((...args: P2) => R2) | ((...args: P3) => R3) | ((...args: P4) => R4)\n\t: never\n","import { SpanKind, type SpanOptions } from '@opentelemetry/api'\nimport {\n\tATTR_FAAS_TRIGGER,\n\tATTR_MESSAGING_DESTINATION_NAME,\n\tATTR_RPC_MESSAGE_ID,\n} from '@opentelemetry/semantic-conventions/incubating'\nimport { HandlerInstrumentation, OrPromise } from '../types'\n\n/**\n * Converts the message headers into a record ready to be injected\n * as OpenTelemetry attributes\n *\n * @example\n * ```ts\n * const headers = new Headers({ \"Subject\": \"Hello!\", From: \"hello@example.com\" })\n * headerAttributes({ headers })\n * // => {\"email.header.Subject\": \"Hello!\", \"email.header.From\": \"hello@example.com\"}\n * ```\n */\nfunction headerAttributes(message: { headers: Headers }): Record<string, unknown> {\n\treturn Object.fromEntries([...message.headers].map(([key, value]) => [`email.header.${key}`, value] as const))\n}\n\nexport const emailInstrumentation: HandlerInstrumentation<ForwardableEmailMessage, OrPromise<void>> = {\n\tgetInitialSpanInfo: (message) => {\n\t\tconst attributes = {\n\t\t\t[ATTR_FAAS_TRIGGER]: 'other',\n\t\t\t[ATTR_RPC_MESSAGE_ID]: message.headers.get('Message-Id') ?? undefined,\n\t\t\t[ATTR_MESSAGING_DESTINATION_NAME]: message.to,\n\t\t}\n\t\tObject.assign(attributes, headerAttributes(message))\n\t\tconst options = {\n\t\t\tattributes,\n\t\t\tkind: SpanKind.CONSUMER,\n\t\t} satisfies SpanOptions\n\n\t\treturn {\n\t\t\tname: `emailHandler ${message.to}`,\n\t\t\toptions,\n\t\t}\n\t},\n}\n","import { ReadableSpan } from '@opentelemetry/sdk-trace-base'\nimport { Initialiser, setConfig } from '../config'\nimport { exportSpans, proxyExecutionContext } from './common'\nimport { Exception, SpanKind, SpanOptions, SpanStatusCode, context as api_context, trace } from '@opentelemetry/api'\nimport { wrap } from '../wrap'\nimport {\n\tgatherIncomingCfAttributes,\n\tgatherRequestAttributes,\n\tgatherResponseAttributes,\n\tgetParentContextFromRequest,\n\tinstrumentClientFetch,\n} from './fetch'\nimport { instrumentEnv } from './env'\n\nexport type Cookies = {\n\t/**\n\t * Gets a cookie that was previously set with `cookies.set`, or from the request headers.\n\t * @param name the name of the cookie\n\t * @param opts the options, passed directly to `cookie.parse`. See documentation [here](https://github.com/jshttp/cookie#cookieparsestr-options)\n\t */\n\tget(name: string, opts?: import('cookie').ParseOptions): string | undefined\n\n\t/**\n\t * Gets all cookies that were previously set with `cookies.set`, or from the request headers.\n\t * @param opts the options, passed directly to `cookie.parse`. See documentation [here](https://github.com/jshttp/cookie#cookieparsestr-options)\n\t */\n\tgetAll(opts?: import('cookie').ParseOptions): Array<{ name: string; value: string }>\n\n\t/**\n\t * Sets a cookie. This will add a `set-cookie` header to the response, but also make the cookie available via `cookies.get` or `cookies.getAll` during the current request.\n\t *\n\t * The `httpOnly` and `secure` options are `true` by default (except on http://localhost, where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`.\n\t *\n\t * You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children\n\t * @param name the name of the cookie\n\t * @param value the cookie value\n\t * @param opts the options, passed directly to `cookie.serialize`. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)\n\t */\n\tset(name: string, value: string, opts: import('cookie').ParseOptions & { path: string }): void\n\n\t/**\n\t * Deletes a cookie by setting its value to an empty string and setting the expiry date in the past.\n\t *\n\t * You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children\n\t * @param name the name of the cookie\n\t * @param opts the options, passed directly to `cookie.serialize`. The `path` must match the path of the cookie you want to delete. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)\n\t */\n\tdelete(name: string, opts: import('cookie').ParseOptions & { path: string }): void\n\n\t/**\n\t * Serialize a cookie name-value pair into a `Set-Cookie` header string, but don't apply it to the response.\n\t *\n\t * The `httpOnly` and `secure` options are `true` by default (except on http://localhost, where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`.\n\t *\n\t * You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children\n\t *\n\t * @param name the name of the cookie\n\t * @param value the cookie value\n\t * @param opts the options, passed directly to `cookie.serialize`. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)\n\t */\n\tserialize(name: string, value: string, opts: import('cookie').ParseOptions & { path: string }): string\n}\n\nexport interface ResolveOptions {\n\t/**\n\t * Applies custom transforms to HTML. If `done` is true, it's the final chunk. Chunks are not guaranteed to be well-formed HTML\n\t * (they could include an element's opening tag but not its closing tag, for example)\n\t * but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components.\n\t * @param input the html chunk and the info if this is the last chunk\n\t */\n\ttransformPageChunk?(input: { html: string; done: boolean }): MaybePromise<string | undefined>\n\t/**\n\t * Determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`.\n\t * By default, none will be included.\n\t * @param name header name\n\t * @param value header value\n\t */\n\tfilterSerializedResponseHeaders?(name: string, value: string): boolean\n\t/**\n\t * Determines what should be added to the `<head>` tag to preload it.\n\t * By default, `js` and `css` files will be preloaded.\n\t * @param input the type of the file and its path\n\t */\n\tpreload?(input: { type: 'font' | 'css' | 'js' | 'asset'; path: string }): boolean\n}\nexport type SvelteLocals = Partial<Record<string, any>>\ntype Env = unknown\nexport type SveltePlatform = {\n\tenv: Env\n\tcf: CfProperties\n\tctx: ExecutionContext\n}\n\nexport type RequestEvent<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tRouteId extends string | null = string | null,\n> = {\n\t/**\n\t * Get or set cookies related to the current request\n\t */\n\tcookies: Cookies\n\t/**\n\t * `fetch` is equivalent to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch), with a few additional features:\n\t *\n\t * - It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request.\n\t * - It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context).\n\t * - Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.\n\t * - During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text` and `json` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](https://svelte.dev/docs/kit/hooks#Server-hooks-handle)\n\t * - During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.\n\t *\n\t * You can learn more about making credentialed requests with cookies [here](https://svelte.dev/docs/kit/load#Cookies)\n\t */\n\tfetch: typeof fetch\n\t/**\n\t * The client's IP address, set by the adapter.\n\t */\n\tgetClientAddress(): string\n\t/**\n\t * Contains custom data that was added to the request within the [`server handle hook`](https://svelte.dev/docs/kit/hooks#Server-hooks-handle).\n\t */\n\tlocals: SvelteLocals\n\t/**\n\t * The parameters of the current route - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object\n\t */\n\tparams: Params\n\t/**\n\t * Additional data made available through the adapter.\n\t */\n\tplatform: Readonly<SveltePlatform> | undefined\n\t/**\n\t * The original request object\n\t */\n\trequest: Request\n\t/**\n\t * Info about the current route\n\t */\n\troute: {\n\t\t/**\n\t\t * The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`\n\t\t */\n\t\tid: RouteId\n\t}\n\t/**\n\t * If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:\n\t *\n\t *\t```js\n\t *\t/// file: src/routes/blog/+page.js\n\t *\texport async function load({ fetch, setHeaders }) {\n\t *\t\tconst url = `https://cms.example.com/articles.json`;\n\t *\t\tconst response = await fetch(url);\n\t *\n\t *\t\tsetHeaders({\n\t *\t\t\tage: response.headers.get('age'),\n\t *\t\t\t'cache-control': response.headers.get('cache-control')\n\t *\t\t});\n\t *\n\t *\t\treturn response.json();\n\t *\t}\n\t *\t```\n\t *\n\t * Setting the same header multiple times (even in separate `load` functions) is an error  you can only set a given header once.\n\t *\n\t * You cannot add a `set-cookie` header with `setHeaders`  use the [`cookies`](https://svelte.dev/docs/kit/@sveltejs-kit#Cookies) API instead.\n\t */\n\tsetHeaders(headers: Record<string, string>): void\n\t/**\n\t * The requested URL.\n\t */\n\turl: URL\n\t/**\n\t * `true` if the request comes from the client asking for `+page/layout.server.js` data. The `url` property will be stripped of the internal information\n\t * related to the data request in this case. Use this property instead if the distinction is important to you.\n\t */\n\tisDataRequest: boolean\n\t/**\n\t * `true` for `+server.js` calls coming from SvelteKit without the overhead of actually making an HTTP request. This happens when you make same-origin `fetch` requests on the server.\n\t */\n\tisSubRequest: boolean\n}\n\nexport type MaybePromise<T> = T | Promise<T>\n\nexport type ExportedSvelteEventHandler = (input: {\n\tevent: RequestEvent\n\tresolve(event: RequestEvent, opts?: ResolveOptions): MaybePromise<Response>\n}) => MaybePromise<Response>\n\nexport type _Response = typeof globalThis extends { onmessage: any } ? {} : import('undici-types').Response\nexport interface ResponseEvent extends _Response {}\n\ntype PageHandlerArgs = Parameters<ExportedSvelteEventHandler>\n\nlet cold_start = true\nexport function executePageHandler(pagesFn: ExportedSvelteEventHandler, [input]: PageHandlerArgs): Promise<Response> {\n\tconst { event } = input\n\tconst spanContext = getParentContextFromRequest(event.request)\n\n\tconst tracer = trace.getTracer('pagesHandler')\n\tconst attributes = {\n\t\t['faas.trigger']: 'http',\n\t\t['faas.coldstart']: cold_start,\n\t\t['faas.invocation_id']: event.request.headers.get('cf-ray') ?? undefined,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(event.request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(event.request))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst promise = tracer.startActiveSpan(\n\t\t`${event.request.method} ${event.url.pathname}`,\n\t\toptions,\n\t\tspanContext,\n\t\tasync (span) => {\n\t\t\tconst readable = span as unknown as ReadableSpan\n\t\t\tconst method = event.request.method.toUpperCase()\n\t\t\ttry {\n\t\t\t\tconst response: Response = await pagesFn(input)\n\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\tif (readable.attributes['http.route']) {\n\t\t\t\t\tspan.updateName(`${event.request.method} ${readable.attributes['http.route']}`)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\n\t\t\t\treturn response\n\t\t\t} catch (error) {\n\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\tif (readable.attributes['http.route']) {\n\t\t\t\t\tspan.updateName(`fetchHandler ${method} ${readable.attributes['http.route']}`)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\t\t\t}\n\t\t},\n\t)\n\treturn promise\n}\n\nexport function createPageHandler(pageFn: ExportedSvelteEventHandler, initialiser: Initialiser) {\n\tconst pagesHandler: ProxyHandler<ExportedSvelteEventHandler> = {\n\t\tapply: async (target, _thisArg, argArray: Parameters<ExportedSvelteEventHandler>): Promise<Response> => {\n\t\t\tconst [input] = argArray\n\t\t\tconst { event } = input\n\t\t\t// @ts-expect-error\n\t\t\tlet { env, context } = event.platform!\n\t\t\tconst config = initialiser(env as Record<string, unknown>, event.request)\n\t\t\tconst configContext = setConfig(config)\n\t\t\t// @ts-expect-error\n\t\t\tevent.locals.env = instrumentEnv(env as Record<string, unknown>)\n\t\t\tevent.fetch = instrumentClientFetch(event.fetch, (config) => config.fetch)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(context)\n\t\t\t// @ts-expect-error\n\t\t\tevent.locals.ctx = ctx\n\n\t\t\ttry {\n\t\t\t\tconst args: PageHandlerArgs = [input] as PageHandlerArgs\n\t\t\t\treturn await api_context.with(configContext, executePageHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\tcontext.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(pageFn, pagesHandler)\n}\n","import {\n\tSpanKind,\n\tSpanOptions,\n\ttrace,\n\tcontext as api_context,\n\tException,\n\tpropagation,\n\tContext,\n} from '@opentelemetry/api'\nimport { Initialiser, setConfig } from '../config'\nimport { exportSpans, proxyExecutionContext } from './common'\nimport { instrumentEnv } from './env'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { WorkerEntrypoint } from 'cloudflare:workers'\nimport { instrumentClientFetch } from './fetch'\nimport { ResolvedTraceConfig } from '../types'\n\nconst traceIdSymbol = Symbol('traceId')\n\nexport abstract class InstrumentedEntrypoint<E extends Record<string, unknown>> extends WorkerEntrypoint<E> {\n\tprivate enhancedEnv: E\n\n\tconstructor(ctx: ExecutionContext, env: E) {\n\t\tsuper(ctx, env)\n\t\tthis.enhancedEnv = {} as E\n\t}\n\n\tpublic set instrumentedEnv(env: E) {\n\t\tthis.enhancedEnv = env\n\t}\n\n\tprotected entrypointContext<EntrypointContext>(): EntrypointContext {\n\t\treturn {\n\t\t\tenv: this.enhancedEnv,\n\t\t\tfetch: this.fetch,\n\t\t} as EntrypointContext\n\t}\n}\n\nexport function getParentContextFromMetadata(metadata: Record<string, string | string[] | undefined>): Context {\n\treturn propagation.extract<Record<string, unknown>>(api_context.active(), metadata, {\n\t\tget(headers, key) {\n\t\t\tconst value = headers[key] || undefined\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn value as string[]\n\t\t\t}\n\t\t\treturn value as string\n\t\t},\n\t\tkeys(data) {\n\t\t\treturn [...Object.keys(data)]\n\t\t},\n\t})\n}\n\nfunction getParentContextFromEntrypoint(\n\tworkerConfig: ResolvedTraceConfig | undefined,\n\trequest: Record<string, unknown>,\n) {\n\tif (workerConfig === undefined) {\n\t\treturn api_context.active()\n\t}\n\n\tconst acceptTraceContext = workerConfig.handlers.fetch.acceptTraceContext ?? true\n\treturn acceptTraceContext && !!request\n\t\t? getParentContextFromMetadata((request['metadata'] as Record<string, string | string[] | undefined>) ?? {})\n\t\t: api_context.active()\n}\n\nexport function createEntrypointHandler<E extends Record<string, unknown>>(initialiser: Initialiser): MethodDecorator {\n\t// @ts-expect-error type checking\n\tconst decorator: MethodDecorator = <Target extends InstrumentedEntrypoint<E>>(\n\t\ttarget: Target,\n\t\tpropertyKey: string,\n\t\tdescriptor: PropertyDescriptor,\n\t) => {\n\t\tconst original = descriptor.value\n\t\tdescriptor.value = async function (...args: unknown[]) {\n\t\t\tconst request = args?.length > 0 ? (args[0] as Record<string, unknown>) : {}\n\t\t\tconst originalRef = this as InstrumentedEntrypoint<E>\n\t\t\t// @ts-expect-error type check\n\t\t\tconst orig_env = originalRef.env\n\t\t\t// @ts-expect-error type check\n\t\t\tconst orig_ctx = originalRef.ctx\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, this)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\t// @ts-expect-error type checking\n\t\t\toriginalRef.fetch = instrumentClientFetch(originalRef.fetch, (config) => config.fetch)\n\t\t\tconst { tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error type checking\n\t\t\t\toriginalRef.instrumentedEnv = env\n\t\t\t\tconst executeEntrypointHandler = (): Promise<unknown> => {\n\t\t\t\t\tconst spanContext = getParentContextFromEntrypoint(config, request)\n\t\t\t\t\tconst tracer = trace.getTracer('rpcHandler')\n\t\t\t\t\tconst options: SpanOptions = {\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t[SemanticAttributes.FAAS_TRIGGER]: 'rpc',\n\t\t\t\t\t\t\t'rpc.function.name': propertyKey,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkind: SpanKind.SERVER,\n\t\t\t\t\t}\n\t\t\t\t\tconst promise = tracer.startActiveSpan(\n\t\t\t\t\t\t`RPC ${target.constructor.name}.${propertyKey}`,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\tspanContext,\n\t\t\t\t\t\tasync (span) => {\n\t\t\t\t\t\t\tconst traceId = span.spanContext().traceId\n\t\t\t\t\t\t\tapi_context.active().setValue(traceIdSymbol, traceId)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst result = await original.apply(originalRef, args)\n\t\t\t\t\t\t\t\tspan.end()\n\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\t\t\t\tspan.end()\n\t\t\t\t\t\t\t\tthrow error\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t\treturn promise\n\t\t\t\t}\n\t\t\t\treturn await api_context.with(context, executeEntrypointHandler)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t}\n\t\treturn descriptor\n\t}\n\treturn decorator\n}\n","import { SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core'\n\n// First implementation, completely synchronous, more tested.\n\nexport class MultiSpanExporter implements SpanExporter {\n\tprivate exporters: Array<SpanExporter>\n\tconstructor(exporters: Array<SpanExporter>) {\n\t\tthis.exporters = exporters\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tfor (const exporter of this.exporters) {\n\t\t\texporter.export(items, resultCallback)\n\t\t}\n\t}\n\n\tasync shutdown(): Promise<void> {\n\t\tfor (const exporter of this.exporters) {\n\t\t\tawait exporter.shutdown()\n\t\t}\n\t}\n}\n\n// async\n\nexport class MultiSpanExporterAsync implements SpanExporter {\n\tprivate exporters: Array<SpanExporter>\n\tconstructor(exporters: Array<SpanExporter>) {\n\t\tthis.exporters = exporters\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tconst promises = this.exporters.map(\n\t\t\t(exporter) =>\n\t\t\t\tnew Promise<ExportResult>((resolve) => {\n\t\t\t\t\texporter.export(items, resolve)\n\t\t\t\t}),\n\t\t)\n\n\t\tPromise.all(promises).then((results) => {\n\t\t\tconst failed = results.filter((result) => result.code === ExportResultCode.FAILED)\n\t\t\tif (failed.length > 0) {\n\t\t\t\t// not ideal, but just return the first error\n\t\t\t\tresultCallback({ code: ExportResultCode.FAILED, error: failed[0]!.error })\n\t\t\t} else {\n\t\t\t\tresultCallback({ code: ExportResultCode.SUCCESS })\n\t\t\t}\n\t\t})\n\t}\n\n\tasync shutdown(): Promise<void> {\n\t\tawait Promise.all(this.exporters.map((exporter) => exporter.shutdown()))\n\t}\n}\n"],"mappings":";AACA,SAAS,cAAc;AAEvB,WAAW,SAAS;;;ACHpB,SAAS,YAAY,sBAAsB;AAC3C,SAAS,oBAA2C,gCAAgC;AAW7E,SAAS,iBAAiB,UAAwC;AACxE,SAAO,CAAC,cAAc;AACrB,WAAO,SAAS,OAAO,CAAC,QAAQ,YAAY,UAAU,QAAQ,SAAS,GAAG,KAAK;AAAA,EAChF;AACD;AAEO,IAAM,gBAA8B,CAAC,cAAc;AACzD,QAAM,gBAAgB,UAAU;AAChC,UAAQ,cAAc,YAAY,EAAE,aAAa,WAAW,aAAa,WAAW;AACrF;AAEO,IAAM,kBAAgC,CAAC,cAAc;AAC3D,QAAM,gBAAgB,UAAU;AAChC,SAAO,cAAc,OAAO,SAAS,eAAe;AACrD;AAEO,SAAS,cAAc,MAA0C;AACvE,QAAM,eAAe,IAAI,yBAAyB,KAAK,KAAK;AAC5D,MAAI,OAAO,KAAK,iBAAiB,aAAa,CAAC,KAAK,cAAc;AACjE,WAAO,IAAI,mBAAmB;AAAA,MAC7B,MAAM;AAAA,MACN,qBAAqB;AAAA,MACrB,wBAAwB;AAAA,IACzB,CAAC;AAAA,EACF,OAAO;AACN,WAAO,IAAI,mBAAmB,EAAE,MAAM,aAAa,CAAC;AAAA,EACrD;AACD;;;ACvCA,SAAS,WAAWA,cAAwB,eAAAC,cAAa,kBAAAC,iBAAgB,SAAAC,eAAa;AACtF,SAAmB,8BAA8B;;;ACDjD,SAAS,eAAe;;;AC6EjB,SAAS,sBAAsB,QAA0D;AAC/F,SAAO,CAAC,CAAE,OAAqC;AAChD;;;ADtEA,SAAS,iCAAiC;;;AET1C,SAAuB,wBAAwB;AAC/C,SAAS,yBAAyB;AAClC,SAAS,2BAA2B;;;ACFpC,IAAM,eAAe,OAAO,QAAQ;AAI7B,SAAS,UAAa,MAA6B;AACzD,SAAO,QAAQ,CAAC,CAAE,KAAoB,YAAY;AACnD;AAEO,SAAS,YAAY,MAAW;AACtC,SAAQ,SAAS,QAAQ,OAAO,SAAS,YAAa,OAAO,SAAS;AACvE;AAEO,SAAS,KAAuB,MAAS,SAA0B,kBAA2B,MAAS;AAC7G,MAAI,UAAU,IAAI,KAAK,CAAC,YAAY,IAAI,GAAG;AAC1C,WAAO;AAAA,EACR;AACA,QAAM,eAAe,OAAO,OAAO,CAAC,GAAG,OAAO;AAC9C,eAAa,MAAM,CAAC,QAAQ,MAAM,aAAa;AAC9C,QAAI,SAAS,cAAc;AAC1B,aAAO;AAAA,IACR,OAAO;AACN,UAAI,QAAQ,KAAK;AAChB,eAAO,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAAA,MAC1C,WAAW,SAAS,QAAQ;AAC3B,eAAO,MAAM;AAAA,MACd,WAAW,iBAAiB;AAC3B,eAAO,eAAe,QAAQ,IAAI;AAAA,MACnC;AAAA,IACD;AAAA,EACD;AACA,eAAa,QAAQ,CAAC,QAAQ,SAAS,aAAa;AACnD,QAAI,QAAQ,OAAO;AAClB,aAAO,QAAQ,MAAM,OAAO,MAAM,GAAG,OAAO,OAAO,GAAG,QAAQ;AAAA,IAC/D;AAAA,EACD;AACA,SAAO,IAAI,MAAM,MAAM,YAAY;AACpC;AAEO,SAAS,OAAyB,MAAY;AACpD,MAAI,QAAQ,UAAU,IAAI,GAAG;AAC5B,WAAO,KAAK,YAAY;AAAA,EACzB,OAAO;AACN,WAAO;AAAA,EACR;AACD;AAEO,SAAS,eAAe,QAAa,MAAuB,SAAe;AACjF,QAAM,kBAAkB,OAAO,MAAM;AACrC,YAAU,OAAO,OAAO,KAAK;AAC7B,QAAM,QAAQ,QAAQ,IAAI,iBAAiB,IAAI;AAC/C,MAAI,OAAO,UAAU,YAAY;AAChC,QAAI,MAAM,YAAY,SAAS,eAAe;AAC7C,aAAO,IAAI,SAAoB,gBAAgB,IAAI,EAAE,GAAG,IAAI;AAAA,IAC7D;AACA,WAAO,MAAM,KAAK,OAAO;AAAA,EAC1B,OAAO;AACN,WAAO;AAAA,EACR;AACD;;;ACzDE,IAAAC,6BAA8B;AAE9B,WAAQ;;;AFWV,IAAM,iBAAyC;AAAA,EAC9C,QAAQ;AAAA,EACR,gBAAgB;AAAA,EAChB,cAAc,iDAA0DC,0BAA6B;AACtG;AAEO,IAAM,eAAN,MAA2C;AAAA,EACzC;AAAA,EACA;AAAA,EACR,YAAY,QAA4B;AACvC,SAAK,MAAM,OAAO;AAClB,SAAK,UAAU,OAAO,OAAO,CAAC,GAAG,gBAAgB,OAAO,OAAO;AAAA,EAChE;AAAA,EAEA,OAAO,OAAc,gBAAsD;AAC1E,SAAK,QAAQ,KAAK,EAChB,KAAK,MAAM;AACX,qBAAe,EAAE,MAAM,iBAAiB,QAAQ,CAAC;AAAA,IAClD,CAAC,EACA,MAAM,CAAC,UAAU;AACjB,qBAAe,EAAE,MAAM,iBAAiB,QAAQ,MAAM,CAAC;AAAA,IACxD,CAAC;AAAA,EACH;AAAA,EAEQ,QAAQ,OAAgC;AAC/C,WAAO,IAAI,QAAc,CAAC,SAAS,WAAW;AAC7C,UAAI;AACH,aAAK,KAAK,OAAO,SAAS,MAAM;AAAA,MACjC,SAAS,GAAG;AACX,eAAO,CAAC;AAAA,MACT;AAAA,IACD,CAAC;AAAA,EACF;AAAA,EAEA,KAAK,OAAc,WAAuB,SAAmD;AAC5F,UAAM,UAAU,IAAI,YAAY;AAChC,UAAM,gBAAgB,oBAAoB,iBAAiB,KAAK;AAEhE,UAAM,OAAO,QAAQ,OAAO,aAAa;AACzC,UAAM,SAAsB;AAAA,MAC3B,QAAQ;AAAA,MACR,SAAS,KAAK;AAAA,MACd;AAAA,IACD;AAEA,WAAO,KAAK,EAAE,KAAK,KAAK,MAAM,EAC5B,KAAK,CAAC,aAAa;AACnB,UAAI,SAAS,IAAI;AAChB,kBAAU;AAAA,MACX,OAAO;AACN,gBAAQ,IAAI,kBAAkB,mCAAmC,SAAS,MAAM,EAAE,CAAC;AAAA,MACpF;AAAA,IACD,CAAC,EACA,MAAM,CAAC,UAAU;AACjB,cAAQ,IAAI,kBAAkB,4BAA4B,MAAM,SAAS,CAAC,IAAI,MAAM,MAAM,MAAM,KAAK,CAAC;AAAA,IACvG,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,WAA0B;AAAA,EAAC;AAClC;;;AGvEA,SAAS,oBAAAC,yBAAwB;AAKjC,SAAS,aAA2B;AACnC,QAAM,OAAO,gBAAgB;AAC7B,MAAI,CAAC,MAAM;AACV,YAAQ,IAAI,mEAAmE;AAAA,EAChF;AACA,SAAO,OAAO,KAAK,SAAS,cAAc,MAAM;AACjD;AAEA,IAAM,aAAN,MAAiB;AAAA,EACR,kBAAkC,CAAC;AAAA,EACnC,kBAAkB,oBAAI,IAAY;AAAA,EAClC;AAAA,EACA,iBAAkC,CAAC;AAAA,EACnC;AAAA,EACA;AAAA,EAER,YAAY,UAAwB;AACnC,SAAK,WAAW;AAAA,EACjB;AAAA,EAEA,QAAQ,MAAkB;AACzB,UAAM,eAAe;AACrB,SAAK,gBAAgB,KAAK,iBAAiB;AAC3C,SAAK,gBAAgB,KAAK,YAAY;AACtC,SAAK,gBAAgB,IAAI,KAAK,YAAY,EAAE,MAAM;AAAA,EACnD;AAAA,EAEA,QAAQ,MAA0B;AACjC,SAAK,gBAAgB,OAAO,KAAK,YAAY,EAAE,MAAM;AACrD,QAAI,KAAK,gBAAgB,SAAS,GAAG;AACpC,WAAK,MAAM;AAAA,IACZ;AAAA,EACD;AAAA,EAEA,SAAS;AACR,QAAI,KAAK,kBAAkB,UAAa,KAAK,gBAAgB,SAAS,GAAG;AACxE,YAAM,UAAU,WAAW;AAC3B,WAAK,gBAAgB,QAAQ;AAAA,QAC5B,SAAS,KAAK,cAAe,YAAY,EAAE;AAAA,QAC3C,eAAe,KAAK;AAAA,QACpB,OAAO,KAAK;AAAA,MACb,CAAC;AAAA,IACF;AACA,SAAK,kBAAkB,KAAK,gBAAgB,KAAK,kBAAkB,CAAC;AAAA,EACrE;AAAA,EAEA,MAAM,QAAuB;AAC5B,QAAI,KAAK,gBAAgB,SAAS,GAAG;AACpC,YAAM,kBAAkB,KAAK,gBAAgB,OAAO,CAAC,SAAS,KAAK,iBAAiB,IAAI,CAAC;AACzF,iBAAW,QAAQ,iBAAiB;AACnC,gBAAQ,IAAI,QAAQ,KAAK,YAAY,EAAE,MAAM,yBAAyB;AACtE,aAAK,IAAI;AAAA,MACV;AACA,WAAK,OAAO;AACZ,WAAK,eAAe,KAAK,KAAK,YAAY,KAAK,eAAe,CAAC;AAC/D,WAAK,kBAAkB,CAAC;AAAA,IACzB;AACA,QAAI,KAAK,eAAe,SAAS,GAAG;AACnC,YAAM,QAAQ,WAAW,KAAK,cAAc;AAAA,IAC7C;AAAA,EACD;AAAA,EAEQ,iBAAiB,MAAoB;AAC5C,WAAO,KAAK,gBAAgB,IAAI,KAAK,YAAY,EAAE,MAAM;AAAA,EAC1D;AAAA,EAEA,MAAc,YAAY,OAAsC;AAC/D,UAAM,UAAU,KAAK,CAAC;AACtB,UAAM,UAAU,IAAI,QAAc,CAAC,SAAS,WAAW;AACtD,WAAK,SAAS,OAAO,OAAO,CAAC,WAAW;AACvC,YAAI,OAAO,SAASC,kBAAiB,SAAS;AAC7C,kBAAQ;AAAA,QACT,OAAO;AACN,kBAAQ,IAAI,6BAA6B,OAAO,KAAK;AACrD,iBAAO,OAAO,KAAK;AAAA,QACpB;AAAA,MACD,CAAC;AAAA,IACF,CAAC;AACD,UAAM;AAAA,EACP;AACD;AAGO,IAAM,0BAAN,MAAqE;AAAA,EAG3E,YAAoB,UAAwB;AAAxB;AAAA,EAAyB;AAAA,EAFrC,SAAsC,CAAC;AAAA,EAI/C,cAAc,SAA6B;AAC1C,UAAM,aAAa,KAAK,OAAO,OAAO,KAAK,IAAI,WAAW,KAAK,QAAQ;AACvE,SAAK,OAAO,OAAO,IAAI;AACvB,WAAO;AAAA,EACR;AAAA,EAEA,QAAQ,MAAY,gBAA+B;AAClD,UAAM,UAAU,KAAK,YAAY,EAAE;AACnC,SAAK,cAAc,OAAO,EAAE,QAAQ,IAAI;AAAA,EACzC;AAAA,EAEA,MAAM,MAA0B;AAC/B,UAAM,UAAU,KAAK,YAAY,EAAE;AACnC,SAAK,cAAc,OAAO,EAAE,QAAQ,IAAI;AAAA,EACzC;AAAA,EAEA,MAAM,WAAW,SAAkC;AAClD,QAAI,SAAS;AACZ,YAAM,KAAK,cAAc,OAAO,EAAE,MAAM;AAAA,IACzC,OAAO;AACN,YAAM,WAAW,OAAO,OAAO,KAAK,MAAM,EAAE,IAAI,CAAC,eAA2B,WAAW,KAAK;AAC5F,YAAM,QAAQ,WAAW,QAAQ;AAAA,IAClC;AAAA,EACD;AAAA,EAEA,MAAM,WAA0B;AAC/B,UAAM,KAAK,WAAW;AAAA,EACvB;AACD;;;AL3GA,IAAM,eAAe,OAAO,oCAAoC;AAIzD,SAAS,UAAU,QAA6B,MAAM,QAAQ,OAAO,GAAG;AAC9E,SAAO,IAAI,SAAS,cAAc,MAAM;AACzC;AAEO,SAAS,kBAAmD;AAClE,QAAM,SAAS,QAAQ,OAAO,EAAE,SAAS,YAAY;AACrD,SAAO,UAAU;AAClB;AAEA,SAAS,eAAe,gBAAgE;AACvF,SAAO,CAAC,CAAE,eAAgC;AAC3C;AAEA,SAAS,UAAU,SAAkE;AACpF,SAAO,CAAC,CAAE,QAAoB;AAC/B;AAEO,SAAS,YAAY,UAA4C;AACvE,MAAI,sBAAsB,QAAQ,GAAG;AACpC,UAAM,iBAAiB,SAAS,UAAU,eAAe,EAAE,OAAO,EAAE;AACpE,UAAM,cAAc,UAAU,cAAc,IAAI,iBAAiB,cAAc,cAAc;AAC7F,UAAM,iBAAiB,MAAM,QAAQ,SAAS,cAAc,IAAI,SAAS,iBAAiB,CAAC,SAAS,cAAc;AAClH,QAAI,eAAe,WAAW,GAAG;AAChC,cAAQ;AAAA,QACP;AAAA,MACD;AAAA,IACD;AACA,WAAO;AAAA,MACN,OAAO;AAAA,QACN,qBAAqB,SAAS,OAAO,uBAAuB;AAAA,MAC7D;AAAA,MACA,UAAU;AAAA,QACT,OAAO;AAAA,UACN,oBAAoB,SAAS,UAAU,OAAO,sBAAsB;AAAA,QACrE;AAAA,MACD;AAAA,MACA,eAAe,SAAS,kBAAkB,CAAC,UAA0B;AAAA,MACrE,UAAU;AAAA,QACT;AAAA,QACA,aAAa,SAAS,UAAU,eAAe,iBAAiB,CAAC,eAAe,eAAe,CAAC;AAAA,MACjG;AAAA,MACA,SAAS,SAAS;AAAA,MAClB;AAAA,MACA,YAAY,SAAS,cAAc,IAAI,0BAA0B;AAAA,MACjE,iBAAiB;AAAA,QAChB,uBAAuB,SAAS,iBAAiB,yBAAyB;AAAA,QAC1E,uBAAuB,SAAS,iBAAiB,yBAAyB;AAAA,MAC3E;AAAA,IACD;AAAA,EACD,OAAO;AACN,UAAM,WAAW,eAAe,SAAS,QAAQ,IAAI,SAAS,WAAW,IAAI,aAAa,SAAS,QAAQ;AAC3G,UAAM,iBAAiB,CAAC,IAAI,wBAAwB,QAAQ,CAAC;AAC7D,UAAM,YAAY,OAAO,OAAO,UAAU,EAAE,UAAU,QAAW,eAAe,CAAC;AACjF,WAAO,YAAY,SAAS;AAAA,EAC7B;AACD;;;AM3EA,SAAS,WAAAC,UAAS,SAAAC,cAAoD;;;ACgBtE,SAAkC,oBAAoB;AAEtD,SAAS,yBAAyB;AAElC,SAAS,oBAAoB;AAa7B,IAAM,uBAAuB;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AAEA,IAAe,mCAAf,MAA0E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBzE,KAAQC,UAAkB,QAAc;AACvC,QAAI,kBAAkB,cAAc;AACnC,aAAO,KAAK,kBAAkBA,UAAS,MAAM;AAAA,IAC9C;AAEA,QAAI,OAAO,WAAW,YAAY;AACjC,aAAO,KAAK,cAAcA,UAAS,MAAM;AAAA,IAC1C;AACA,WAAO;AAAA,EACR;AAAA,EAEQ,cAAkCA,UAAkB,QAAc;AACzE,UAAM,UAAU;AAChB,UAAM,iBAAiB,YAA0B,MAAiB;AACjE,aAAO,QAAQ,KAAKA,UAAS,MAAM,OAAO,MAAM,MAAM,IAAI,CAAC;AAAA,IAC5D;AACA,WAAO,eAAe,gBAAgB,UAAU;AAAA,MAC/C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO,OAAO;AAAA,IACf,CAAC;AAMD,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,kBAA0CA,UAAkB,IAAU;AAC7E,UAAM,MAAM,KAAK,aAAa,EAAE;AAChC,QAAI,QAAQ,OAAW,QAAO;AAC9B,SAAK,gBAAgB,EAAE;AAGvB,yBAAqB,QAAQ,CAAC,eAAe;AAC5C,UAAI,GAAG,UAAU,MAAM,OAAW;AAClC,SAAG,UAAU,IAAI,KAAK,kBAAkB,IAAI,GAAG,UAAU,GAAGA,QAAO;AAAA,IACpE,CAAC;AAED,QAAI,OAAO,GAAG,mBAAmB,YAAY;AAC5C,SAAG,iBAAiB,KAAK,qBAAqB,IAAI,GAAG,cAAc;AAAA,IACpE;AACA,QAAI,OAAO,GAAG,QAAQ,YAAY;AACjC,SAAG,MAAM,KAAK,qBAAqB,IAAI,GAAG,GAAG;AAAA,IAC9C;AAEA,QAAI,OAAO,GAAG,uBAAuB,YAAY;AAChD,SAAG,qBAAqB,KAAK,yBAAyB,IAAI,GAAG,kBAAkB;AAAA,IAChF;AACA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,qBAAqB,IAAkB,UAAoB;AAClE,UAAM,iBAAiB;AACvB,WAAO,SAAuB,OAAe,UAAsB;AAClE,YAAM,SAAS,eAAe,aAAa,EAAE,IAAI,KAAK;AACtD,UAAI,WAAW,QAAW;AACzB,eAAO,SAAS,KAAK,MAAM,OAAO,QAAQ;AAAA,MAC3C;AACA,YAAM,kBAAkB,OAAO,IAAI,QAAQ;AAC3C,aAAO,SAAS,KAAK,MAAM,OAAO,mBAAmB,QAAQ;AAAA,IAC9D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,yBAAyB,IAAkB,UAAoB;AACtE,UAAM,iBAAiB;AACvB,WAAO,SAAuB,OAAe;AAC5C,YAAM,MAAM,eAAe,aAAa,EAAE;AAC1C,UAAI,QAAQ,QAAW;AACtB,YAAI,UAAU,WAAW,GAAG;AAC3B,yBAAe,gBAAgB,EAAE;AAAA,QAClC,WAAW,IAAI,KAAK,MAAM,QAAW;AACpC,iBAAO,IAAI,KAAK;AAAA,QACjB;AAAA,MACD;AACA,aAAO,SAAS,MAAM,MAAM,SAAS;AAAA,IACtC;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,kBAAkB,IAAkB,UAAoBA,UAAkB;AACjF,UAAM,iBAAiB;AACvB,WAAO,SAAuB,OAAe,UAAsB;AASlE,UAAI,eAAe,UAAU;AAC5B,eAAO,SAAS,KAAK,MAAM,OAAO,QAAQ;AAAA,MAC3C;AACA,UAAI,MAAM,eAAe,aAAa,EAAE;AACxC,UAAI,QAAQ,QAAW;AACtB,cAAM,eAAe,gBAAgB,EAAE;AAAA,MACxC;AACA,UAAI,YAAY,IAAI,KAAK;AACzB,UAAI,cAAc,QAAW;AAC5B,oBAAY,oBAAI,QAAQ;AACxB,YAAI,KAAK,IAAI;AAAA,MACd;AACA,YAAM,kBAAkB,eAAe,KAAKA,UAAS,QAAQ;AAE7D,gBAAU,IAAI,UAAU,eAAe;AAKvC,qBAAe,WAAW;AAC1B,UAAI;AACH,eAAO,SAAS,KAAK,MAAM,OAAO,eAAe;AAAA,MAClD,UAAE;AACD,uBAAe,WAAW;AAAA,MAC3B;AAAA,IACD;AAAA,EACD;AAAA,EAEQ,gBAAgB,IAA4B;AACnD,UAAM,MAAM,uBAAO,OAAO,IAAI;AAE7B,IAAC,GAAW,KAAK,aAAa,IAAI;AACnC,WAAO;AAAA,EACR;AAAA,EACQ,aAAa,IAAwC;AAC5D,WAAQ,GAAa,KAAK,aAAa;AAAA,EACxC;AAAA,EAEiB,gBAAgB,OAAO,aAAa;AAAA,EAC7C,WAAW;AACpB;AAEO,IAAM,kCAAN,cAA8C,iCAAiC;AAAA,EAC7E;AAAA,EAER,cAAc;AACb,UAAM;AACN,SAAK,qBAAqB,IAAI,kBAAkB;AAAA,EACjD;AAAA,EAEA,SAAkB;AACjB,WAAO,KAAK,mBAAmB,SAAS,KAAK;AAAA,EAC9C;AAAA,EAEA,KACCA,UACA,IACA,YACG,MACa;AAChB,UAAM,KAAK,WAAW,OAAO,KAAK,GAAG,KAAK,OAAO;AACjD,WAAO,KAAK,mBAAmB,IAAIA,UAAS,IAAa,GAAG,IAAI;AAAA,EACjE;AAAA,EAEA,SAAe;AACd,WAAO;AAAA,EACR;AAAA,EAEA,UAAgB;AACf,SAAK,mBAAmB,QAAQ;AAChC,WAAO;AAAA,EACR;AACD;;;AC3PA;AAAA,EAGC,cAAAC;AAAA,EAEA,YAAAC;AAAA,EAGA,WAAW;AAAA,EACX;AAAA,OAEM;AACP,SAAS,sBAAAC,2BAA0B;AAEnC,SAAwB,mBAAiC,wBAAwB;;;ACdjF;AAAA,EAQC;AAAA,EAEA,kBAAAC;AAAA,OAEM;AACP;AAAA,EACC;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,OACM;AAGP,SAAS,0BAA0B;AAiBnC,SAAS,6BAA6B,WAAkC;AACvE,QAAM,aAAyB,CAAC;AAChC,MAAI,OAAO,cAAc,UAAU;AAClC,eAAW,mBAAmB,iBAAiB,IAAI;AAAA,EACpD,OAAO;AACN,QAAI,UAAU,MAAM;AACnB,iBAAW,mBAAmB,cAAc,IAAI,UAAU,KAAK,SAAS;AAAA,IACzE,WAAW,UAAU,MAAM;AAC1B,iBAAW,mBAAmB,cAAc,IAAI,UAAU;AAAA,IAC3D;AACA,QAAI,UAAU,SAAS;AACtB,iBAAW,mBAAmB,iBAAiB,IAAI,UAAU;AAAA,IAC9D;AACA,QAAI,UAAU,OAAO;AACpB,iBAAW,mBAAmB,oBAAoB,IAAI,UAAU;AAAA,IACjE;AAAA,EACD;AACA,SAAO;AACR;AAEA,SAAS,WAAW,QAAwB;AAC3C,SAAO,CAAC,KAAK,MAAM,SAAS,GAAI,GAAI,SAAS,MAAQ,GAAG;AACzD;AAEA,SAAS,UAAU,OAA2B;AAC7C,QAAM,MAAM,KAAK,IAAI;AACrB,MAAI,CAAC,OAAO;AACX,WAAO,WAAW,GAAG;AAAA,EACtB,WAAW,iBAAiB,MAAM;AACjC,WAAO,WAAW,MAAM,QAAQ,CAAC;AAAA,EAClC,WAAW,OAAO,UAAU,UAAU;AAErC,WAAO,WAAW,KAAK;AAAA,EACxB,WAAW,MAAM,QAAQ,KAAK,GAAG;AAChC,WAAO;AAAA,EACR;AAEA,QAAM,IAAW;AACjB,QAAM,IAAI,MAAM,sBAAsB,KAAK,UAAU,CAAC,CAAC,EAAE;AAC1D;AAGA,SAAS,eAAe,KAA6B;AACpD,SAAO,OAAO,QAAQ,YAAY,IAAI,SAAS;AAChD;AAEO,IAAM,WAAN,MAA6C;AAAA,EACnD;AAAA,EACiB;AAAA,EACA;AAAA,EACR;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACT,SAAqB;AAAA,IACpB,MAAMA,gBAAe;AAAA,EACtB;AAAA,EACA,UAAkB,CAAC,GAAG,CAAC;AAAA,EACf,YAAoB,CAAC,GAAG,CAAC;AAAA,EACxB;AAAA,EACA,SAAuB,CAAC;AAAA,EACxB;AAAA,EACA;AAAA,EACT,uBAA6C,EAAE,MAAM,6BAA6B;AAAA,EAC1E,SAAkB;AAAA,EAClB,0BAAkC;AAAA,EAClC,sBAA8B;AAAA,EAC9B,qBAA6B;AAAA,EAErC,YAAYC,OAAgB;AAC3B,SAAK,OAAOA,MAAK;AACjB,SAAK,eAAeA,MAAK;AACzB,SAAK,eAAeA,MAAK;AACzB,SAAK,oBAAoBA,MAAK;AAC9B,SAAK,OAAOA,MAAK,YAAY,SAAS;AACtC,SAAK,aAAa,mBAAmBA,MAAK,UAAU;AACpD,SAAK,YAAY,UAAUA,MAAK,SAAS;AACzC,SAAK,QAAQA,MAAK,SAAS,CAAC;AAC5B,SAAK,WAAWA,MAAK;AACrB,SAAK,QAAQA,MAAK;AAAA,EACnB;AAAA,EAEA,QAAQ,MAAkB;AACzB,SAAK,MAAM,KAAK,IAAI;AACpB,WAAO;AAAA,EACR;AAAA,EACA,SAAS,OAAqB;AAC7B,SAAK,MAAM,KAAK,GAAG,KAAK;AACxB,WAAO;AAAA,EACR;AAAA,EAEA,cAA2B;AAC1B,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,aAAa,KAAa,OAA8B;AACvD,QAAI,eAAe,GAAG,KAAK,iBAAiB,KAAK,GAAG;AACnD,WAAK,WAAW,GAAG,IAAI;AAAA,IACxB;AACA,WAAO;AAAA,EACR;AAAA,EAEA,cAAc,YAA8B;AAC3C,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,UAAU,GAAG;AACtD,WAAK,aAAa,KAAK,KAAK;AAAA,IAC7B;AACA,WAAO;AAAA,EACR;AAAA,EAEA,SAAS,MAAc,uBAAgD,WAA6B;AACnG,QAAI,YAAY,qBAAqB,GAAG;AACvC,kBAAY;AACZ,8BAAwB;AAAA,IACzB;AAEA,UAAM,aAAa,mBAAmB,qBAAqB;AAC3D,UAAM,OAAO,UAAU,SAAS;AAChC,SAAK,OAAO,KAAK,EAAE,MAAM,YAAY,KAAK,CAAC;AAC3C,WAAO;AAAA,EACR;AAAA,EAEA,UAAU,QAA0B;AACnC,SAAK,SAAS;AACd,WAAO;AAAA,EACR;AAAA,EAEA,WAAW,MAAoB;AAC9B,SAAK,OAAO;AACZ,WAAO;AAAA,EACR;AAAA,EAEA,IAAI,SAA2B;AAC9B,QAAI,KAAK,QAAQ;AAChB;AAAA,IACD;AACA,SAAK,SAAS;AACd,SAAK,UAAU,UAAU,OAAO;AAChC,SAAK,YAAY,eAAe,KAAK,WAAW,KAAK,OAAO;AAC5D,SAAK,MAAM,IAAI;AAAA,EAChB;AAAA,EAEA,cAAuB;AACtB,WAAO,CAAC,KAAK;AAAA,EACd;AAAA,EAEA,gBAAgB,WAAsB,MAAwB;AAC7D,UAAM,aAAa,6BAA6B,SAAS;AACzD,SAAK,SAAS,aAAa,YAAY,IAAI;AAAA,EAC5C;AAAA,EAEA,IAAI,WAAmB;AACtB,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAI,QAAiB;AACpB,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAI,yBAAiC;AACpC,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAI,qBAA6B;AAChC,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAI,oBAA4B;AAC/B,WAAO,KAAK;AAAA,EACb;AACD;;;ADrLA,IAAM,cAAiC,IAAI,kBAAkB;AAE7D,IAAI;AAEJ,SAAS,UAAU,cAAsB,UAA0B;AAClE,UAAS,gBAAiB,WAAW,IAAM,KAAK;AACjD;AAEO,IAAM,eAAN,MAAqC;AAAA,EAC1B;AAAA,EACA;AAAA,EACjB,YAAY,gBAAiC,UAAoB;AAChE,SAAK,iBAAiB;AACtB,SAAK,WAAW;AAAA,EACjB;AAAA,EAEA,MAAM,WAAW,SAAkB;AAClC,UAAM,WAAW,KAAK,eAAe,IAAI,OAAO,kBAAkB;AACjE,YAAM,cAAc,WAAW,OAAO;AAAA,IACvC,CAAC;AACD,UAAM,QAAQ,WAAW,QAAQ;AAAA,EAClC;AAAA,EAEA,cAAc,OAAiB;AAC9B,SAAK,SAAS,MAAM,KAAK;AAAA,EAC1B;AAAA,EAEA,UAAU,MAAc,UAAuB,CAAC,GAAGC,WAAU,YAAY,OAAO,GAAS;AACxF,QAAI,QAAQ,MAAM;AACjB,MAAAA,WAAU,MAAM,WAAWA,QAAO;AAAA,IACnC;AAEA,UAAM,SAAS,gBAAgB;AAC/B,QAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,iEAAiE;AAE9F,UAAM,oBAAoB,MAAM,QAAQA,QAAO,GAAG,YAAY;AAC9D,UAAM,EAAE,SAAS,gBAAgB,IAAI,aAAa,iBAAiB;AAEnE,UAAM,WAAW,QAAQ,QAAQC,UAAS;AAC1C,UAAM,iBAAiBC,oBAAmB,QAAQ,UAAU;AAC5D,UAAM,UAAU,OAAO,SAAS;AAChC,UAAM,mBAAmB,QAAQ,aAAaF,UAAS,SAAS,MAAM,UAAU,gBAAgB,CAAC,CAAC;AAClG,UAAM,EAAE,UAAU,YAAY,YAAY,MAAM,IAAI;AAEpD,UAAM,aAAa,OAAO,OAAO,CAAC,GAAG,QAAQ,YAAY,OAAO,sBAAsB;AACtF,6BAAyB,CAAC;AAE1B,UAAM,SAAS,YAAY,eAAe;AAC1C,UAAM,eAAe,mBAAmB;AAExC,UAAM,aAAa,aAAa,iBAAiB,qBAAqBG,YAAW,UAAUA,YAAW;AACtG,UAAM,aAAa,aAAa;AAChC,UAAM,cAAc,EAAE,SAAS,QAAQ,YAAY,WAAW;AAE9D,UAAM,OAAO,IAAI,SAAS;AAAA,MACzB,YAAYD,oBAAmB,UAAU;AAAA,MACzC;AAAA,MACA,OAAO,CAACE,UAAS;AAChB,aAAK,eAAe,QAAQ,CAAC,OAAO;AACnC,aAAG,MAAMA,KAA+B;AAAA,QACzC,CAAC;AAAA,MACF;AAAA,MACA,UAAU,KAAK;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,WAAW,QAAQ;AAAA,IACpB,CAAC;AACD,SAAK,eAAe,QAAQ,CAAC,OAAO;AAGnC,SAAG,QAAQ,MAAMJ,QAAO;AAAA,IACzB,CAAC;AACD,WAAO;AAAA,EACR;AAAA,EAUA,gBAAyD,SAAiB,MAAgC;AACzG,UAAM,UAAU,KAAK,SAAS,IAAK,KAAK,CAAC,IAAoB;AAC7D,UAAM,gBAAgB,KAAK,SAAS,IAAK,KAAK,CAAC,IAAgB,YAAY,OAAO;AAClF,UAAM,KAAK,KAAK,KAAK,SAAS,CAAC;AAE/B,UAAM,OAAO,KAAK,UAAU,MAAM,SAAS,aAAa;AACxD,UAAM,qBAAqB,MAAM,QAAQ,eAAe,IAAI;AAE5D,WAAO,YAAY,KAAK,oBAAoB,IAAI,QAAW,IAAI;AAAA,EAChE;AACD;AAEO,SAAS,aAAa,OAAmB;AAC/C,2BAAyB,OAAO,OAAO,CAAC,GAAG,wBAAwB,KAAK;AACzE;AAEA,SAAS,aAAa,mBAA2F;AAChH,MAAI,qBAAqB,MAAM,mBAAmB,iBAAiB,GAAG;AACrE,UAAM,EAAE,SAAS,WAAW,IAAI;AAChC,WAAO,EAAE,SAAS,iBAAiB,UAAU,YAAY,CAAC,EAAE;AAAA,EAC7D,OAAO;AACN,WAAO,EAAE,SAAS,YAAY,gBAAgB,GAAG,iBAAiB,4BAAkC;AAAA,EACrG;AACD;;;AFxHO,IAAM,uBAAN,MAAqD;AAAA,EACnD;AAAA,EACA;AAAA,EACA,UAAkC,CAAC;AAAA,EAE3C,YAAY,gBAAiC,UAAoB;AAChE,SAAK,iBAAiB;AACtB,SAAK,WAAW;AAAA,EACjB;AAAA,EAEA,UAAU,MAAc,SAAkB,SAAiC;AAC1E,UAAM,MAAM,GAAG,IAAI,IAAI,WAAW,EAAE,IAAI,SAAS,aAAa,EAAE;AAChE,QAAI,CAAC,KAAK,QAAQ,GAAG,GAAG;AACvB,WAAK,QAAQ,GAAG,IAAI,IAAI,aAAa,KAAK,gBAAgB,KAAK,QAAQ;AAAA,IACxE;AACA,WAAO,KAAK,QAAQ,GAAG;AAAA,EACxB;AAAA,EAEA,WAAiB;AAChB,IAAAK,OAAM,wBAAwB,IAAI;AAClC,IAAAC,SAAQ,wBAAwB,IAAI,gCAAgC,CAAC;AAAA,EACtE;AACD;;;AIrCA;AAAA,EACC,SAAAC;AAAA,EAEA,YAAAC;AAAA,EACA;AAAA,EACA,WAAWC;AAAA,EAKX,kBAAAC;AAAA,OACM;AAuBP,IAAM,gBAAgB,oBAAI,IAAI,CAAC,QAAQ,WAAW,oBAAoB,cAAc,eAAe,OAAO,SAAS,CAAC;AAEpH,IAAM,mBAAmB,CAAC,MAAsB;AAC/C,SAAO,EAAE,QAAQ,UAAU,CAAC,WAAW,IAAI,OAAO,YAAY,CAAC,EAAE;AAClE;AAEA,IAAM,6BAA6B,CAAC,OAA4C;AAC/E,QAAM,QAAyC,CAAC;AAChD,SAAO,KAAK,EAAE,EAAE,QAAQ,CAAC,QAAQ;AAChC,UAAM,QAAQ,GAAG,GAAG;AACpB,UAAM,UAAU,iBAAiB,GAAG;AACpC,QAAI,CAAC,cAAc,IAAI,OAAO,GAAG;AAChC,UAAI,OAAO,UAAU,YAAY,OAAO,UAAU,UAAU;AAC3D,cAAM,MAAM,OAAO,EAAE,IAAI;AAAA,MAC1B,OAAO;AACN,cAAM,MAAM,OAAO,EAAE,IAAI,KAAK,UAAU,KAAK;AAAA,MAC9C;AAAA,IACD;AAAA,EACD,CAAC;AACD,SAAO;AACR;AAEO,SAAS,wBAAwB,SAA8B;AACrE,QAAM,QAAyC,CAAC;AAChD,QAAM,UAAU,QAAQ;AACxB,QAAM,qBAAqB,IAAI,QAAQ,OAAO,YAAY;AAC1D,QAAM,uBAAuB,IAAI;AACjC,QAAM,0BAA0B,IAAI,QAAQ,IAAI;AAChD,QAAM,wBAAwB,IAAI,QAAQ,IAAI,gBAAgB;AAC9D,QAAM,qBAAqB,IAAI,QAAQ,IAAI,YAAY;AACvD,QAAM,gBAAgB,IAAI,QAAQ,IAAI,cAAc;AACpD,QAAM,cAAc,IAAI,QAAQ,IAAI;AAEpC,QAAM,IAAI,IAAI,IAAI,QAAQ,GAAG;AAC7B,QAAM,UAAU,IAAI,GAAG,EAAE,QAAQ,KAAK,EAAE,IAAI,GAAG,EAAE,QAAQ,GAAG,EAAE,MAAM;AACpE,QAAM,gBAAgB,IAAI,EAAE;AAC5B,QAAM,YAAY,IAAI,EAAE;AACxB,QAAM,UAAU,IAAI,EAAE;AACtB,QAAM,WAAW,IAAI,EAAE;AAEvB,SAAO;AACR;AAEO,SAAS,yBAAyB,UAAgC;AACxE,QAAM,QAAyC,CAAC;AAChD,QAAM,2BAA2B,IAAI,SAAS;AAC9C,MAAI,SAAS,QAAQ,IAAI,gBAAgB,KAAM,MAAM;AACpD,UAAM,yBAAyB,IAAI,SAAS,QAAQ,IAAI,gBAAgB;AAAA,EACzE;AACA,QAAM,gBAAgB,IAAI,SAAS,QAAQ,IAAI,cAAc;AAC7D,SAAO;AACR;AAEO,SAAS,2BAA2B,SAA8B;AACxE,QAAM,QAAyC,CAAC;AAChD,QAAM,UAAU,IAAI,QAAQ,IAAI;AAChC,QAAM,aAAa,IAAI,QAAQ,IAAI;AACnC,QAAM,sBAAsB,IAAI,QAAQ,IAAI;AAC5C,QAAM,gBAAgB,IAAI,QAAQ,IAAI;AACtC,QAAM,iBAAiB,IAAI,QAAQ,IAAI;AACvC,QAAM,SAAS,IAAI,QAAQ,IAAI;AAC/B,QAAM,aAAa,IAAI,QAAQ,IAAI;AACnC,SAAO;AACR;AAEO,SAAS,4BAA4B,SAA2B;AACtE,SAAO,YAAY,QAAQC,aAAY,OAAO,GAAG,SAAS;AAAA,IACzD,IAAIC,UAAS,KAAK;AACjB,aAAOA,SAAQ,IAAI,GAAG,KAAK;AAAA,IAC5B;AAAA,IACA,KAAKA,UAAS;AACb,aAAO,CAAC,GAAGA,SAAQ,KAAK,CAAC;AAAA,IAC1B;AAAA,EACD,CAAC;AACF;AAEO,SAAS,4BAA4B,SAAkB;AAC7D,QAAM,eAAe,gBAAgB;AAErC,MAAI,iBAAiB,QAAW;AAC/B,WAAOD,aAAY,OAAO;AAAA,EAC3B;AAEA,QAAM,qBACL,OAAO,aAAa,SAAS,MAAM,uBAAuB,aACvD,aAAa,SAAS,MAAM,mBAAmB,OAAO,IACrD,aAAa,SAAS,MAAM,sBAAsB;AACvD,SAAO,qBAAqB,4BAA4B,QAAQ,OAAO,IAAIA,aAAY,OAAO;AAC/F;AAEA,SAAS,sBAAsB,MAAY,SAA0B;AACpE,QAAM,WAAW;AACjB,MAAI,SAAS,WAAW,YAAY,GAAG;AACtC,UAAM,SAAS,QAAQ,OAAO,YAAY;AAC1C,SAAK,WAAW,GAAG,MAAM,IAAI,SAAS,WAAW,YAAY,CAAC,EAAE;AAAA,EACjE;AACD;AAEO,IAAM,uBAAqF;AAAA,EACjG,oBAAoB,CAAC,YAAY;AAChC,UAAM,cAAc,4BAA4B,OAAO;AACvD,UAAM,aAAa;AAAA,MAClB,CAAC,cAAc,GAAG;AAAA,MAClB,CAAC,oBAAoB,GAAG,QAAQ,QAAQ,IAAI,QAAQ,KAAK;AAAA,IAC1D;AACA,WAAO,OAAO,YAAY,wBAAwB,OAAO,CAAC;AAC1D,WAAO,OAAO,YAAY,2BAA2B,OAAO,CAAC;AAC7D,UAAM,SAAS,QAAQ,OAAO,YAAY;AAC1C,WAAO;AAAA,MACN,MAAM,gBAAgB,MAAM;AAAA,MAC5B,SAAS;AAAA,QACR;AAAA,QACA,MAAME,UAAS;AAAA,MAChB;AAAA,MACA,SAAS;AAAA,IACV;AAAA,EACD;AAAA,EACA,yBAAyB,CAAC,aAAa;AACtC,WAAO,yBAAyB,QAAQ;AAAA,EACzC;AAAA,EACA,iBAAiB;AAAA,EACjB,iBAAiB;AAClB;AAGO,SAAS,sBACf,SACA,UACA,OACmB;AACnB,QAAM,UAA0C;AAAA,IAC/C,OAAO,CAAC,QAAQ,SAAS,aAA2C;AACnE,YAAM,UAAU,IAAI,QAAQ,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AACpD,UAAI,CAAC,QAAQ,IAAI,WAAW,MAAM,GAAG;AACpC,eAAO,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAAA,MAC/C;AAEA,YAAM,eAAe,gBAAgB;AACrC,UAAI,CAAC,cAAc;AAClB,eAAO,QAAQ,MAAM,QAAQ,SAAS,CAAC,OAAO,CAAC;AAAA,MAChD;AACA,YAAM,SAAS,SAAS,YAAY;AAEpC,YAAMC,UAASC,OAAM,UAAU,SAAS;AACxC,YAAM,UAAuB,EAAE,MAAMF,UAAS,QAAQ,YAAY,MAAM;AAExE,YAAM,OAAO,IAAI,IAAI,QAAQ,GAAG,EAAE;AAClC,YAAM,SAAS,QAAQ,OAAO,YAAY;AAC1C,YAAM,WAAW,OAAO,QAAQ,MAAM,MAAM,WAAW,QAAQ,MAAM,IAAI,SAAS,MAAM,IAAI,IAAI;AAChG,YAAM,UAAUC,QAAO,gBAAgB,UAAU,SAAS,OAAO,SAAS;AACzE,YAAI;AACH,gBAAM,sBACL,OAAO,OAAO,wBAAwB,aACnC,OAAO,oBAAoB,OAAO,IAClC,OAAO;AACX,cAAI,uBAAuB,MAAM;AAChC,wBAAY,OAAOH,aAAY,OAAO,GAAG,QAAQ,SAAS;AAAA,cACzD,KAAK,CAAC,GAAG,GAAG,MAAM,EAAE,IAAI,GAAG,OAAO,MAAM,WAAW,IAAI,OAAO,CAAC,CAAC;AAAA,YACjE,CAAC;AAAA,UACF;AACA,eAAK,cAAc,wBAAwB,OAAO,CAAC;AACnD,cAAI,QAAQ,GAAI,MAAK,cAAc,2BAA2B,QAAQ,EAAE,CAAC;AACzE,gBAAM,WAAW,MAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC,OAAO,CAAC;AAC/D,eAAK,cAAc,yBAAyB,QAAQ,CAAC;AACrD,iBAAO;AAAA,QACR,SAAS,OAAgB;AACxB,eAAK,gBAAgB,KAAkB;AACvC,eAAK,UAAU,EAAE,MAAMK,gBAAe,MAAM,CAAC;AAC7C,gBAAM;AAAA,QACP,UAAE;AACD,eAAK,IAAI;AAAA,QACV;AAAA,MACD,CAAC;AACD,aAAO;AAAA,IACR;AAAA,EACD;AACA,SAAO,KAAK,SAAS,SAAS,IAAI;AACnC;AAEO,SAAS,wBAA8B;AAE7C,aAAW,QAAQ,sBAAsB,WAAW,OAAO,CAAC,WAAW,OAAO,KAAK;AACpF;;;ACxNA,SAAS,YAAAC,WAAuB,SAAAC,cAAa;AAK7C,IAAM,SAASC,OAAM,UAAU,uBAAuB;AAEtD,SAAS,YAAY,KAAqB;AACzC,QAAM,IAAI,IAAI,IAAI,GAAG;AACrB,SAAO,GAAG,EAAE,QAAQ,KAAK,EAAE,IAAI,GAAG,EAAE,QAAQ,GAAG,EAAE,MAAM;AACxD;AAEA,SAAS,mBAAuC,IAAO,WAAmB,IAAe;AACxF,QAAM,UAAmC;AAAA,IACxC,MAAM,MAAM,QAAQ,SAAS,UAAU;AACtC,YAAM,aAAa;AAAA,QAClB,cAAc;AAAA,QACd,YAAY,SAAS,CAAC,EAAE,MAAM,YAAY,SAAS,CAAC,EAAE,GAAG,IAAI;AAAA,QAC7D,mBAAmB;AAAA,MACpB;AACA,YAAM,UAAuB,EAAE,MAAMC,UAAS,QAAQ,WAAW;AACjE,aAAO,OAAO,gBAAgB,SAAS,SAAS,IAAI,EAAE,IAAI,SAAS,OAAO,SAAS;AAClF,cAAM,SAAS,MAAM,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAC5D,YAAI,OAAO,SAAS;AACnB,eAAK,aAAa,aAAa,CAAC,CAAC,MAAM;AAAA,QACxC;AACA,aAAK,IAAI;AACT,eAAO;AAAA,MACR,CAAC;AAAA,IACF;AAAA,EACD;AACA,SAAO,KAAK,IAAI,OAAO;AACxB;AAEA,SAAS,gBAAgB,OAAc,WAA0B;AAChE,QAAM,UAAsC;AAAA,IAC3C,IAAI,QAAQ,MAAM;AACjB,UAAI,SAAS,YAAY,SAAS,WAAW,SAAS,OAAO;AAC5D,cAAM,KAAK,QAAQ,IAAI,QAAQ,IAAI,EAAE,KAAK,MAAM;AAChD,eAAO,mBAAmB,IAAI,WAAW,IAAI;AAAA,MAC9C,OAAO;AACN,eAAO,QAAQ,IAAI,QAAQ,IAAI;AAAA,MAChC;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,OAAO,OAAO;AAC3B;AAEA,SAAS,eAAe,QAAoD;AAC3E,QAAM,UAAuC;AAAA,IAC5C,MAAM,MAAM,QAAQ,SAAS,UAAU;AACtC,YAAM,YAAY,SAAS,CAAC;AAC5B,YAAM,QAAQ,MAAM,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAC3D,aAAO,gBAAgB,OAAO,SAAS;AAAA,IACxC;AAAA,EACD;AACA,SAAO,KAAK,QAAQ,OAAO;AAC5B;AAEA,SAAS,yBAAyB;AACjC,QAAM,UAAuC;AAAA,IAC5C,IAAI,QAAQ,MAAM;AACjB,UAAI,SAAS,WAAW;AACvB,cAAM,QAAQ,OAAO;AACrB,eAAO,gBAAgB,OAAO,SAAS;AAAA,MACxC,WAAW,SAAS,QAAQ;AAC3B,cAAM,SAAS,QAAQ,IAAI,QAAQ,IAAI,EAAE,KAAK,MAAM;AACpD,eAAO,eAAe,MAAM;AAAA,MAC7B,OAAO;AACN,eAAO,QAAQ,IAAI,QAAQ,IAAI;AAAA,MAChC;AAAA,IACD;AAAA,EACD;AAEA,aAAW,SAAS,KAAK,QAAQ,OAAO;AACzC;AAEO,SAAS,wBAAwB;AACvC,SAAO,uBAAuB;AAC/B;;;AC/EA,SAAS,SAAAC,QAAO,YAAAC,WAA4B,eAAAC,cAAa,WAAWC,oBAAmB;AAGvF,SAAS,mBAAmB,iCAAiC;AAK7D,IAAM,qBAAN,MAAyB;AAAA,EACxB,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,mBAAmB;AAAA,EACnB,qBAAqB;AAAA,EACZ;AAAA,EAET,YAAY,OAAe;AAC1B,SAAK,QAAQ;AAAA,EACd;AAAA,EAEA,MAAM;AACL,SAAK,YAAY,KAAK,YAAY;AAAA,EACnC;AAAA,EAEA,eAAe;AACd,SAAK,mBAAmB,KAAK,QAAQ,KAAK,YAAY,KAAK;AAC3D,SAAK,YAAY,KAAK,QAAQ,KAAK;AAAA,EACpC;AAAA,EAEA,QAAQ;AACP,SAAK,SAAS,KAAK,SAAS;AAAA,EAC7B;AAAA,EAEA,iBAAiB;AAChB,SAAK,qBAAqB,KAAK,QAAQ,KAAK,YAAY,KAAK;AAC7D,SAAK,SAAS,KAAK,QAAQ,KAAK;AAAA,EACjC;AAAA,EAEA,eAA2B;AAC1B,WAAO;AAAA,MACN,wBAAwB,KAAK;AAAA,MAC7B,0BAA0B,KAAK;AAAA,MAC/B,yBAAyB,KAAK;AAAA,MAC9B,uBAAuB,KAAK,cAAc,KAAK;AAAA,MAC/C,0BAA0B,KAAK;AAAA,MAC/B,4BAA4B,KAAK;AAAA,IAClC;AAAA,EACD;AACD;AAEA,IAAM,WAAW,CAAC,MAAc,QAAkB;AACjD,QAAM,QAAoB,CAAC;AAC3B,MAAI,KAAK;AACR,UAAM,kBAAkB,IAAI,IAAI;AAChC,UAAM,yBAAyB,IAAI,IAAI,UAAU,YAAY;AAAA,EAC9D;AACA,EAAAC,OAAM,cAAc,GAAG,SAAS,MAAM,KAAK;AAC5C;AAEA,IAAM,oBAAoB,CAAI,KAAiB,UAA0C;AACxF,QAAM,aAAuC;AAAA,IAC5C,KAAK,CAAC,QAAQ,SAAS;AACtB,UAAI,SAAS,OAAO;AACnB,cAAM,QAAQ,QAAQ,IAAI,QAAQ,IAAI;AACtC,eAAO,IAAI,MAAM,OAAO;AAAA,UACvB,OAAO,CAAC,aAAa;AACpB,qBAAS,cAAc,GAAG;AAC1B,kBAAM,IAAI;AAGV,oBAAQ,MAAM,UAAU,KAAK,CAAC,CAAC;AAAA,UAChC;AAAA,QACD,CAAC;AAAA,MACF,WAAW,SAAS,SAAS;AAC5B,cAAM,UAAU,QAAQ,IAAI,QAAQ,IAAI;AACxC,eAAO,IAAI,MAAM,SAAS;AAAA,UACzB,OAAO,CAAC,aAAa;AACpB,qBAAS,gBAAgB,GAAG;AAC5B,kBAAM,MAAM;AAEZ,kBAAM,SAAS,QAAQ,MAAM,UAAU,KAAK,CAAC,CAAC;AAC9C,mBAAO;AAAA,UACR;AAAA,QACD,CAAC;AAAA,MACF,OAAO;AACN,eAAO,QAAQ,IAAI,QAAQ,MAAM,GAAG;AAAA,MACrC;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,KAAK,UAAU;AAC5B;AAEA,IAAM,oBAAoB,CAAC,OAAqB,UAA8B;AAC7E,QAAM,eAA2C;AAAA,IAChD,KAAK,CAAC,QAAQ,SAAS;AACtB,UAAI,SAAS,YAAY;AACxB,cAAM,WAAW,QAAQ,IAAI,QAAQ,IAAI;AACzC,cAAM,kBAA0D;AAAA,UAC/D,KAAK,CAACC,SAAQC,UAAS;AACtB,gBAAI,OAAOA,UAAS,YAAY,CAAC,MAAM,SAASA,KAAI,CAAC,GAAG;AACvD,oBAAM,UAAU,QAAQ,IAAID,SAAQC,KAAI;AACxC,qBAAO,kBAAkB,SAAS,KAAK;AAAA,YACxC,OAAO;AACN,qBAAO,QAAQ,IAAID,SAAQC,KAAI;AAAA,YAChC;AAAA,UACD;AAAA,QACD;AACA,eAAO,KAAK,UAAU,eAAe;AAAA,MACtC,WAAW,SAAS,UAAU;AAC7B,cAAM,QAAQ,QAAQ,IAAI,QAAQ,IAAI;AACtC,eAAO,IAAI,MAAM,OAAO;AAAA,UACvB,OAAO,CAAC,aAAa;AACpB,qBAAS,QAAQ;AACjB,kBAAM,aAAa;AAEnB,oBAAQ,MAAM,UAAU,OAAO,CAAC,CAAC;AAAA,UAClC;AAAA,QACD,CAAC;AAAA,MACF,WAAW,SAAS,YAAY;AAC/B,cAAM,UAAU,QAAQ,IAAI,QAAQ,IAAI;AACxC,eAAO,IAAI,MAAM,SAAS;AAAA,UACzB,OAAO,CAAC,aAAa;AACpB,qBAAS,UAAU;AACnB,kBAAM,eAAe;AAErB,oBAAQ,MAAM,UAAU,OAAO,CAAC,CAAC;AAAA,UAClC;AAAA,QACD,CAAC;AAAA,MACF;AAEA,aAAO,QAAQ,IAAI,QAAQ,IAAI;AAAA,IAChC;AAAA,EACD;AACA,SAAO,KAAK,OAAO,YAAY;AAChC;AAEO,IAAM,uBAAN,MAA4F;AAAA,EAC1F;AAAA,EAER,mBAAmB,OAAsC;AACxD,WAAO;AAAA,MACN,MAAM,gBAAgB,MAAM,KAAK;AAAA,MACjC,SAAS;AAAA,QACR,YAAY;AAAA,UACX,CAAC,iBAAiB,GAAG;AAAA,UACrB,cAAc,MAAM;AAAA,QACrB;AAAA,QACA,MAAMC,UAAS;AAAA,MAChB;AAAA,IACD;AAAA,EACD;AAAA,EAEA,kBAAkB,OAAmC;AACpD,SAAK,QAAQ,IAAI,mBAAmB,MAAM,SAAS,MAAM;AACzD,WAAO,kBAAkB,OAAO,KAAK,KAAK;AAAA,EAC3C;AAAA,EAEA,gBAAgB,MAAY;AAC3B,QAAI,KAAK,OAAO;AACf,WAAK,MAAM,aAAa;AACxB,WAAK,cAAc,KAAK,MAAM,aAAa,CAAC;AAAA,IAC7C;AAAA,EACD;AAAA,EAEA,gBAAgB,MAAY;AAC3B,QAAI,KAAK,OAAO;AACf,WAAK,MAAM,eAAe;AAC1B,WAAK,cAAc,KAAK,MAAM,aAAa,CAAC;AAAA,IAC7C;AAAA,EACD;AACD;AAMA,SAAS,iBAAiB,UAAqB;AAC9C,QAAM,kBAAkB,UAAU,SAAS,KAAK,OAAO,SAAS,CAAC,MAAM;AAEvE,QAAM,UAAU,kBAAmB,SAAS,CAAC,IAA2B;AACxE,MAAI,SAAS;AACZ,YAAQ,WAAW,QAAQ,WAAW,QAAQ,WAAW,CAAC;AAAA,EAC3D;AACA,MAAI,SAAS;AACZ,IAAAC,aAAY,OAAOC,aAAY,OAAO,GAAG,QAAQ,UAAU;AAAA,MAC1D,KAAK,CAAC,GAAG,GAAG,MAAO,EAAE,CAAC,IAAI,OAAO,MAAM,WAAW,IAAI,OAAO,CAAC;AAAA,IAC/D,CAAC;AAAA,EACF;AACD;AAEA,SAAS,oBAAoB,IAA4B,MAAsC;AAC9F,QAAMC,UAASN,OAAM,UAAU,aAAa;AAC5C,QAAM,UAAgD;AAAA,IACrD,OAAO,CAAC,QAAQ,SAAS,aAAa;AACrC,aAAOM,QAAO,gBAAgB,YAAY,IAAI,SAAS,OAAO,SAAS;AACtE,yBAAiB,QAAQ;AACzB,aAAK,aAAa,mBAAmB,MAAM;AAC3C,cAAM,QAAQ,MAAM,QAAQ,OAAO,OAAO,GAAG,QAAQ;AACrD,aAAK,IAAI;AAAA,MACV,CAAC;AAAA,IACF;AAAA,EACD;AACA,SAAO,KAAK,IAAI,OAAO;AACxB;AAEA,SAAS,yBAAyB,IAAiC,MAA2C;AAC7G,QAAMA,UAASN,OAAM,UAAU,aAAa;AAC5C,QAAM,UAAqD;AAAA,IAC1D,OAAO,CAAC,QAAQ,SAAS,aAAa;AACrC,aAAOM,QAAO,gBAAgB,YAAY,IAAI,cAAc,OAAO,SAAS;AAC3E,aAAK,aAAa,mBAAmB,WAAW;AAChD,cAAM,QAAQ,MAAM,QAAQ,OAAO,OAAO,GAAG,QAAQ;AACrD,aAAK,IAAI;AAAA,MACV,CAAC;AAAA,IACF;AAAA,EACD;AACA,SAAO,KAAK,IAAI,OAAO;AACxB;AAEO,SAAS,sBAAsB,OAAuB,MAAc;AAC1E,QAAM,eAA6C;AAAA,IAClD,KAAK,CAAC,QAAQ,SAAS;AACtB,UAAI,SAAS,QAAQ;AACpB,cAAM,SAAS,QAAQ,IAAI,QAAQ,IAAI;AACvC,eAAO,oBAAoB,QAAQ,IAAI;AAAA,MACxC,WAAW,SAAS,aAAa;AAChC,cAAM,SAAS,QAAQ,IAAI,QAAQ,IAAI;AACvC,eAAO,yBAAyB,QAAQ,IAAI;AAAA,MAC7C,OAAO;AACN,eAAO,QAAQ,IAAI,QAAQ,IAAI;AAAA,MAChC;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,OAAO,YAAY;AAChC;;;ACzOA,SAAS,WAAWC,cAAa,SAAAC,SAAoB,YAAAC,YAAqB,kBAAAC,uBAAsB;AAChG,SAAS,sBAAAC,2BAA0B;;;ACDnC,SAAqB,YAAAC,WAAuB,SAAAC,cAAa;AACzD,SAAS,sBAAAC,2BAA0B;AAKnC,IAAM,WAAW;AAEjB,IAAM,eAA0D;AAAA,EAC/D,OAAO,WAAW;AACjB,WAAO,CAAC;AAAA,EACT;AAAA,EACA,IAAI,UAAU;AACb,UAAM,QAAoB,CAAC;AAC3B,UAAM,OAAO,SAAS,CAAC;AACvB,QAAI,OAAO,SAAS,UAAU;AAC7B,YAAM,eAAe,IAAI;AAAA,IAC1B,WAAW,OAAO,SAAS,UAAU;AACpC,YAAM,eAAe,IAAI,KAAK;AAC9B,YAAM,oBAAoB,IAAI,KAAK;AAAA,IACpC;AACA,WAAO;AAAA,EACR;AAAA,EACA,gBAAgB,UAAU,QAAQ;AACjC,UAAM,QAAoB,CAAC;AAC3B,UAAM,OAAO,SAAS,CAAC;AACvB,QAAI,OAAO,SAAS,UAAU;AAC7B,YAAM,eAAe,IAAI;AAAA,IAC1B,WAAW,OAAO,SAAS,UAAU;AACpC,YAAM,eAAe,IAAI,KAAK;AAC9B,YAAM,oBAAoB,IAAI,KAAK;AAAA,IACpC;AAEA,UAAM,mBAAmB,IAAI;AAC7B,UAAM,EAAE,YAAY,IAAI;AACxB,QAAI,OAAO,gBAAgB,UAAU;AACpC,YAAM,uBAAuB,IAAI;AAAA,IAClC;AACA,WAAO;AAAA,EACR;AAAA,EACA,KAAK,UAAU,QAAQ;AACtB,UAAM,QAAoB,CAAC;AAC3B,UAAM,OAA+B,SAAS,CAAC,KAAK,CAAC;AACrD,UAAM,EAAE,QAAQ,MAAM,IAAI;AAC1B,UAAM,8BAA8B,IAAI,UAAU;AAClD,UAAM,qBAAqB,IAAI,SAAS;AACxC,UAAM,EAAE,eAAe,YAAY,IAAI;AACvC,UAAM,wBAAwB,IAAI,iBAAiB;AACnD,QAAI,CAAC,eAAe;AACnB,YAAM,+BAA+B,IAAI,UAAU;AAAA,IACpD;AACA,QAAI,OAAO,gBAAgB,UAAU;AACpC,YAAM,uBAAuB,IAAI;AAAA,IAClC;AACA,WAAO;AAAA,EACR;AAAA,EACA,IAAI,UAAU;AACb,UAAM,QAAoB,CAAC;AAC3B,QAAI,SAAS,SAAS,KAAK,SAAS,CAAC,GAAG;AACvC,YAAM,EAAE,YAAY,eAAe,SAAS,IAAI,SAAS,CAAC;AAC1D,YAAM,qBAAqB,IAAI;AAC/B,YAAM,yBAAyB,IAAI;AACnC,YAAM,mBAAmB,IAAI,CAAC,CAAC;AAAA,IAChC;AACA,WAAO;AAAA,EACR;AACD;AAEA,SAAS,eAAe,IAAc,MAAc,WAAmB;AACtE,QAAMC,UAASC,OAAM,UAAU,IAAI;AACnC,QAAM,YAA+B;AAAA,IACpC,OAAO,CAAC,QAAQ,SAAS,aAAa;AACrC,YAAM,aAAa;AAAA,QAClB,cAAc;AAAA,QACd,CAACC,oBAAmB,OAAO,GAAG;AAAA,QAC9B,CAACA,oBAAmB,SAAS,GAAG;AAAA,QAChC,CAACA,oBAAmB,YAAY,GAAG;AAAA,MACpC;AACA,YAAM,UAAuB;AAAA,QAC5B,MAAMC,UAAS;AAAA,QACf;AAAA,MACD;AACA,aAAOH,QAAO,gBAAgB,MAAM,IAAI,IAAI,SAAS,IAAI,SAAS,OAAO,SAAS;AACjF,cAAM,SAAS,MAAM,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAC5D,cAAM,eAAe,aAAa,SAAS;AAC3C,cAAM,aAAa,eAAe,aAAa,UAAU,MAAM,IAAI,CAAC;AACpE,aAAK,cAAc,UAAU;AAC7B,YAAI,cAAc,QAAQ;AACzB,gBAAM,OAA+B,SAAS,CAAC,KAAK,CAAC;AACrD,gBAAM,EAAE,OAAO,IAAI;AACnB,eAAK,aAAaE,oBAAmB,cAAc,GAAG,SAAS,IAAI,UAAU,MAAS,EAAE;AAAA,QACzF,OAAO;AACN,eAAK,aAAaA,oBAAmB,cAAc,GAAG,SAAS,IAAI,SAAS,CAAC,CAAC,EAAE;AAChF,eAAK,aAAa,gBAAgB,SAAS,CAAC,CAAC;AAAA,QAC9C;AACA,YAAI,cAAc,mBAAmB;AACpC,gBAAM,aAAa,CAAC,CAAC,UAAU,CAAC,CAAE,OAA6D;AAC/F,eAAK,aAAa,uBAAuB,UAAU;AAAA,QACpD,OAAO;AACN,eAAK,aAAa,uBAAuB,CAAC,CAAC,MAAM;AAAA,QAClD;AACA,aAAK,IAAI;AACT,eAAO;AAAA,MACR,CAAC;AAAA,IACF;AAAA,EACD;AACA,SAAO,KAAK,IAAI,SAAS;AAC1B;AAEO,SAAS,aAAa,IAAiB,MAA2B;AACxE,QAAM,YAAuC;AAAA,IAC5C,KAAK,CAAC,QAAQ,MAAM,aAAa;AAChC,YAAM,YAAY,OAAO,IAAI;AAC7B,YAAM,KAAK,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAC7C,aAAO,eAAe,IAAI,MAAM,SAAS;AAAA,IAC1C;AAAA,EACD;AACA,SAAO,KAAK,IAAI,SAAS;AAC1B;;;ACtHA;AAAA,EACC,WAAWE;AAAA,EAEX,eAAAC;AAAA,EACA,YAAAC;AAAA,EAEA,kBAAAC;AAAA,EACA,SAAAC;AAAA,OACM;AAOA,SAAS,yBAAyB,SAAkB,SAA0B;AACpF,QAAM,iBAAwC;AAAA,IAC7C,IAAI,QAAQ,MAAM;AACjB,UAAI,SAAS,SAAS;AACrB,cAAMC,WAAU,QAAQ,IAAI,QAAQ,IAAI;AACxC,cAAM,QAAQ;AAAA,UACb,MAAM,mBAAmB,OAAO;AAAA,QACjC;AACA,eAAO,sBAAsBA,UAAS,OAAO,EAAE,qBAAqB,KAAK,IAAI,KAAK;AAAA,MACnF,OAAO;AACN,eAAO,4BAA4B,QAAQ,SAAS,IAAI;AAAA,MACzD;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,SAAS,cAAc;AACpC;AAEO,SAAS,4BAA4B,QAAa,SAAiB,MAAuB,SAAe;AAC/G,QAAM,kBAAkB,OAAO,MAAM;AACrC,QAAM,QAAQ,QAAQ,IAAI,iBAAiB,IAAI;AAC/C,MAAI,OAAO,UAAU,YAAY;AAChC,QAAI,MAAM,YAAY,SAAS,eAAe;AAC7C,YAAM,QAAQ;AAAA,QACb,MAAM,YAAY,OAAO,IAAI,OAAO,IAAI,CAAC;AAAA,MAC1C;AACA,aAAO,oBAAoB,OAAO,OAAO,EAAE,qBAAqB,KAAK,IAAI,KAAK;AAAA,IAC/E;AACA,cAAU,WAAW;AACrB,WAAO,MAAM,KAAK,OAAO;AAAA,EAC1B,OAAO;AACN,WAAO;AAAA,EACR;AACD;AAOO,SAAS,oBACf,SACA,UACA,OACmB;AACnB,QAAM,UAA0C;AAAA,IAC/C,OAAO,CAAC,QAAQ,SAAS,aAA2C;AACnE,YAAM,kBAAkB,UAAU,SAAS,KAAK,OAAO,SAAS,CAAC,MAAM;AAEvE,YAAM,UAAU,kBAAmB,SAAS,CAAC,IAAyB;AACtE,UAAI,SAAS;AACZ,gBAAQ,WAAW,QAAQ,WAAW,QAAQ,WAAW,CAAC;AAAA,MAC3D;AAEA,YAAM,eAAe,gBAAgB;AACrC,UAAI,CAAC,cAAc;AAClB,eAAO,QAAQ,MAAM,QAAQ,SAAS,CAAC,OAAO,CAAC;AAAA,MAChD;AACA,YAAM,SAAS,SAAS,YAAY;AAEpC,YAAMC,UAASC,OAAM,UAAU,KAAK;AACpC,YAAM,UAAuB,EAAE,MAAMC,UAAS,QAAQ,YAAY,MAAM;AAExE,YAAM,WAAW,OAAO,QAAQ,MAAM,MAAM,WAAW,QAAQ,MAAM,IAAI;AACzE,YAAM,UAAUF,QAAO,gBAAgB,UAAU,SAAS,OAAO,SAAS;AACzE,cAAM,sBAAsB,OAAO,uBAAuB;AAC1D,YAAI,WAAW,qBAAqB;AACnC,UAAAG,aAAY,OAAOC,aAAY,OAAO,GAAG,QAAQ,UAAU;AAAA,YAC1D,KAAK,CAAC,GAAG,GAAG,MAAO,EAAE,CAAC,IAAI,OAAO,MAAM,WAAW,IAAI,OAAO,CAAC;AAAA,UAC/D,CAAC;AAAA,QACF;AACA,YAAI;AACH,iBAAO,MAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC,OAAO,CAAC;AAAA,QACtD,SAAS,KAAK;AACb,gBAAM,UAAU,EAAE,MAAMC,gBAAe,MAAM,CAAC;AAC9C,gBAAM;AAAA,QACP,UAAE;AACD,eAAK,IAAI;AAAA,QACV;AAAA,MACD,CAAC;AACD,aAAO;AAAA,IACR;AAAA,EACD;AACA,SAAO,KAAK,SAAS,SAAS,IAAI;AACnC;;;AClGA,SAAqB,YAAAC,WAAuB,kBAAAC,iBAA2B,SAAAC,cAAa;AACpF,SAAS,sBAAAC,2BAA0B;AAGnC,IAAMC,YAAW;AASjB,SAAS,eAAe,MAA0B;AACjD,SAAO;AAAA,IACN,sBAAsB,KAAK;AAAA,IAC3B,yBAAyB,KAAK;AAAA,IAC9B,qBAAqB,KAAK;AAAA,IAC1B,uBAAuB,KAAK;AAAA,IAC5B,wBAAwB,KAAK;AAAA,IAC7B,uBAAuB,KAAK;AAAA,IAC5B,oBAAoB,KAAK;AAAA,EAC1B;AACD;AACA,SAAS,YAAY,QAAgB,WAAmB,KAA2B;AAClF,QAAM,aAAyB;AAAA,IAC9B,cAAc;AAAA,IACd,CAACC,oBAAmB,OAAO,GAAG;AAAA,IAC9B,CAACA,oBAAmB,SAAS,GAAGD;AAAA,IAChC,CAACC,oBAAmB,YAAY,GAAG;AAAA,EACpC;AACA,MAAI,KAAK;AACR,eAAWA,oBAAmB,YAAY,IAAI;AAAA,EAC/C;AACA,SAAO;AAAA,IACN,MAAMC,UAAS;AAAA,IACf;AAAA,EACD;AACD;AAEA,SAAS,wBAAwB,IAAc,QAAgB,WAAmB,KAAa;AAC9F,QAAMC,UAASC,OAAM,UAAU,IAAI;AACnC,QAAM,YAA+B;AAAA,IACpC,OAAO,CAAC,QAAQ,SAAS,aAAa;AACrC,UAAI,cAAc,QAAQ;AACzB,cAAM,UAAU,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AACvD,eAAO,8BAA8B,SAAS,QAAQ,GAAG;AAAA,MAC1D;AAEA,YAAM,UAAU,YAAY,QAAQ,WAAW,GAAG;AAClD,aAAOD,QAAO,gBAAgB,GAAG,MAAM,IAAI,SAAS,IAAI,SAAS,OAAO,SAAS;AAChF,YAAI;AACH,gBAAM,SAAS,MAAM,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAC5D,cAAI,cAAc,SAAS,cAAc,OAAO;AAC/C,iBAAK,cAAc,eAAgB,OAAoB,IAAI,CAAC;AAAA,UAC7D;AACA,eAAK,UAAU,EAAE,MAAME,gBAAe,GAAG,CAAC;AAC1C,iBAAO;AAAA,QACR,SAAS,OAAO;AACf,eAAK,gBAAgB,KAAkB;AACvC,eAAK,UAAU,EAAE,MAAMA,gBAAe,MAAM,CAAC;AAC7C,gBAAM;AAAA,QACP,UAAE;AACD,eAAK,IAAI;AAAA,QACV;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AACA,SAAO,KAAK,IAAI,SAAS;AAC1B;AAEA,SAAS,8BACR,MACA,QACA,WACsB;AACtB,QAAM,mBAAsD;AAAA,IAC3D,KAAK,CAAC,QAAQ,MAAM,aAAa;AAChC,YAAM,YAAY,OAAO,IAAI;AAC7B,YAAM,KAAK,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAC7C,UAAI,OAAO,OAAO,YAAY;AAC7B,eAAO,wBAAwB,IAAI,QAAQ,WAAW,SAAS;AAAA,MAChE;AACA,aAAO;AAAA,IACR;AAAA,EACD;AACA,SAAO,KAAK,MAAM,gBAAgB;AACnC;AAEO,SAAS,eAAe,IAAc,QAAgB,WAAmB;AAC/E,QAAMF,UAASC,OAAM,UAAU,IAAI;AACnC,QAAM,YAA+B;AAAA,IACpC,OAAO,CAAC,QAAQ,SAAS,aAAa;AACrC,UAAI,cAAc,WAAW;AAC5B,cAAM,MAAM,SAAS,CAAC;AACtB,cAAM,OAAO,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AACpD,eAAO,8BAA8B,MAAM,QAAQ,GAAG;AAAA,MACvD,WAAW,cAAc,QAAQ;AAChC,cAAM,MAAM,SAAS,CAAC;AACtB,cAAM,UAAU,YAAY,QAAQ,WAAW,GAAG;AAClD,eAAOD,QAAO,gBAAgB,GAAG,MAAM,IAAI,SAAS,IAAI,SAAS,OAAO,SAAS;AAChF,cAAI;AACH,kBAAM,SAAS,MAAM,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAC5D,iBAAK,UAAU,EAAE,MAAME,gBAAe,GAAG,CAAC;AAC1C,mBAAO;AAAA,UACR,SAAS,OAAO;AACf,iBAAK,gBAAgB,KAAkB;AACvC,iBAAK,UAAU,EAAE,MAAMA,gBAAe,MAAM,CAAC;AAC7C,kBAAM;AAAA,UACP,UAAE;AACD,iBAAK,IAAI;AAAA,UACV;AAAA,QACD,CAAC;AAAA,MACF,WAAW,cAAc,SAAS;AAEjC,cAAM,aAAa,SAAS,CAAC;AAC7B,eAAOF,QAAO,gBAAgB,GAAG,MAAM,IAAI,SAAS,IAAI,OAAO,SAAS;AAEvE,gBAAM,WAAW,WAAW;AAAA,YAAI,CAAC,MAChCA,QAAO,UAAU,GAAG,MAAM,IAAI,SAAS,YAAY,YAAY,QAAQ,WAAW,EAAE,SAAS,CAAC;AAAA,UAC/F;AAEA,cAAI;AACH,kBAAM,SAAU,MAAM,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAC7D,mBAAO,QAAQ,CAAC,GAAG,MAAM,SAAS,CAAC,GAAG,cAAc,eAAe,EAAE,IAAI,CAAC,CAAC;AAC3E,iBAAK,UAAU,EAAE,MAAME,gBAAe,GAAG,CAAC;AAC1C,mBAAO;AAAA,UACR,SAAS,OAAO;AACf,iBAAK,gBAAgB,KAAkB;AACvC,iBAAK,UAAU,EAAE,MAAMA,gBAAe,MAAM,CAAC;AAC7C,kBAAM;AAAA,UACP,UAAE;AACD,qBAAS,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC;AAC/B,iBAAK,IAAI;AAAA,UACV;AAAA,QACD,CAAC;AAAA,MACF,OAAO;AACN,eAAO,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAAA,MAC/C;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,IAAI,SAAS;AAC1B;AAEO,SAAS,aAAa,UAAsB,QAA4B;AAC9E,QAAM,YAAsC;AAAA,IAC3C,KAAK,CAAC,QAAQ,MAAM,aAAa;AAChC,YAAM,YAAY,OAAO,IAAI;AAC7B,YAAM,KAAK,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAC7C,UAAI,OAAO,OAAO,YAAY;AAC7B,eAAO,eAAe,IAAI,QAAQ,SAAS;AAAA,MAC5C;AACA,aAAO;AAAA,IACR;AAAA,EACD;AACA,SAAO,KAAK,UAAU,SAAS;AAChC;;;AC5JA,SAAqB,YAAAC,WAAuB,SAAAC,cAAa;AACzD,SAAS,sBAAAC,2BAA0B;AAKnC,IAAMC,YAAW;AAEjB,IAAM,eAA0D;AAAA,EAC/D,eAAe,UAAU;AACxB,UAAM,QAAoB,CAAC;AAC3B,UAAM,OAAO,SAAS,CAAC;AACvB,QAAI,OAAO,SAAS,UAAU;AAC7B,YAAM,kBAAkB,IAAI,KAAK,QAAQ;AACzC,YAAM,gBAAgB,IAAK,KAAK,QAAQ,CAAC,EAA2B,SAAS;AAC7E,YAAM,kBAAkB,IAAI,KAAK,QAAQ;AACzC,YAAM,gBAAgB,IAAI,KAAK,MAAM;AAAA,IACtC;AACA,WAAO;AAAA,EACR;AACD;AAEA,SAAS,eAAe,IAAc,MAAc,WAAmB;AACtE,QAAMC,UAASC,OAAM,UAAU,iBAAiB;AAChD,QAAM,YAA+B;AAAA,IACpC,OAAO,CAAC,QAAQ,SAAS,aAAa;AACrC,YAAM,aAAa;AAAA,QAClB,cAAc;AAAA,QACd,CAACC,oBAAmB,OAAO,GAAG;AAAA,QAC9B,CAACA,oBAAmB,SAAS,GAAGH;AAAA,QAChC,CAACG,oBAAmB,YAAY,GAAG;AAAA,MACpC;AACA,YAAM,UAAuB;AAAA,QAC5B,MAAMC,UAAS;AAAA,QACf;AAAA,MACD;AACA,aAAOH,QAAO,gBAAgB,oBAAoB,IAAI,IAAI,SAAS,IAAI,SAAS,OAAO,SAAS;AAC/F,cAAM,SAAS,MAAM,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAC5D,cAAM,eAAe,aAAa,SAAS;AAC3C,cAAM,aAAa,eAAe,aAAa,UAAU,MAAM,IAAI,CAAC;AACpE,aAAK,cAAc,UAAU;AAC7B,aAAK,aAAaE,oBAAmB,cAAc,GAAG,SAAS,IAAI,SAAS,CAAC,CAAC,EAAE;AAChF,aAAK,IAAI;AACT,eAAO;AAAA,MACR,CAAC;AAAA,IACF;AAAA,EACD;AACA,SAAO,KAAK,IAAI,SAAS;AAC1B;AAEO,SAAS,iCACf,SACA,MACyB;AACzB,QAAM,iBAAuD;AAAA,IAC5D,KAAK,CAAC,QAAQ,MAAM,aAAa;AAChC,YAAM,YAAY,OAAO,IAAI;AAC7B,YAAM,KAAK,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAC7C,aAAO,eAAe,IAAI,MAAM,SAAS;AAAA,IAC1C;AAAA,EACD;AACA,SAAO,KAAK,SAAS,cAAc;AACpC;;;ACtDA,IAAM,UAAU,CAAC,SAAoC;AAEpD,SAAO,CAAC,CAAE,OAAmB,0CAA0C,KAAK,OAAO,CAAC;AACrF;AAEA,IAAM,gBAAgB,CAAC,SAAwC;AAC9D,SAAO,CAAC,QAAQ,IAAI,KAAK,CAAC,CAAE,MAAsB;AACnD;AAEA,IAAM,UAAU,CAAC,SAA2C;AAC3D,SAAO,CAAC,QAAQ,IAAI,KAAK,CAAC,CAAE,MAAyB;AACtD;AAEA,IAAM,kBAAkB,CAAC,SAAmD;AAC3E,SAAO,CAAC,QAAQ,IAAI,KAAK,CAAC,CAAE,MAAiC;AAC9D;AAEO,IAAM,oBAAoB,CAAC,SAAkD;AACnF,SACC,CAAC,QAAQ,IAAI,KACb,OAAQ,MAAgC,OAAO,YAC/C,OAAQ,MAAgC,QAAQ;AAElD;AAEA,IAAM,2BAA2B,CAAC,SAAmD;AACpF,SAAO,CAAC,QAAQ,IAAI,KAAK,CAAC,CAAE,MAAiC;AAC9D;AAEA,IAAM,eAAe,CAAC,SAAuC;AAC5D,SAAO,CAAC,CAAE,MAAqB,QAAQ,CAAC,CAAE,MAAqB;AAChE;AAEA,IAAM,gBAAgB,CAAoCE,SAAc;AACvE,QAAM,aAAoD;AAAA,IACzD,KAAK,CAAC,QAAQ,MAAM,aAAa;AAChC,YAAM,OAAO,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAC/C,UAAI,CAAC,YAAY,IAAI,GAAG;AACvB,eAAO;AAAA,MACR;AACA,UAAI,QAAQ,IAAI,GAAG;AAClB,eAAO,yBAAyB,MAAM,OAAO,IAAI,CAAC;AAAA,MACnD,WAAW,cAAc,IAAI,GAAG;AAC/B,eAAO,aAAa,MAAM,OAAO,IAAI,CAAC;AAAA,MACvC,WAAW,QAAQ,IAAI,GAAG;AACzB,eAAO,sBAAsB,MAAM,OAAO,IAAI,CAAC;AAAA,MAChD,WAAW,gBAAgB,IAAI,GAAG;AACjC,eAAO,oBAAoB,MAAM,OAAO,IAAI,CAAC;AAAA,MAC9C,WAAW,kBAAkB,IAAI,GAAG;AAEnC,eAAO;AAAA,MACR,WAAW,yBAAyB,IAAI,GAAG;AAC1C,eAAO,iCAAiC,MAAM,OAAO,IAAI,CAAC;AAAA,MAC3D,WAAW,aAAa,IAAI,GAAG;AAC9B,eAAO,aAAa,MAAM,OAAO,IAAI,CAAC;AAAA,MACvC,OAAO;AACN,eAAO;AAAA,MACR;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAKA,MAAK,UAAU;AAC5B;;;ACrEA,SAAqB,YAAAC,YAAuB,SAAAC,eAAa;AACzD,SAAS,sBAAAC,2BAA0B;AAMnC,IAAMC,YAAW;AAGjB,SAAS,6BAA6B,SAAqD;AAC1F,SACC,OAAO,YAAY,aAClB,sBAAsB,WAAW,sBAAsB,WAAW,aAAa;AAElF;AAKA,SAAS,uBAAuB,OAAmB,SAAqC;AACvF,MAAI,sBAAsB,SAAS;AAClC,UAAM,4BAA4B,IAAI,QAAQ;AAAA,EAC/C;AACA,MAAI,sBAAsB,SAAS;AAClC,UAAM,4BAA4B,IAAI,QAAQ;AAAA,EAC/C;AACA,MAAI,aAAa,SAAS;AACzB,UAAM,mBAAmB,IAAI,QAAQ;AAAA,EACtC;AACD;AAEA,IAAM,oBAA+D;AAAA,EACpE,OAAO,UAAU,QAAwE;AACxF,UAAM,OAAO;AACb,QAAI,QAAoB,CAAC;AACzB,QAAI,MAAM,QAAQ,KAAK,CAAC,CAAC,GAAG;AAC3B,YAAM,OAAO,KAAK,CAAC;AACnB,cAAQ;AAAA;AAAA,QAEP,gBAAgB,KAAK,CAAC;AAAA,QACtB,2BAA2B,KAAK;AAAA,QAChC,yBAAyB;AAAA,MAC1B;AAAA,IACD,OAAO;AACN,cAAQ;AAAA,QACP,gBAAgB,KAAK,CAAC;AAAA,QACtB,oBAAoB;AAAA,MACrB;AAAA,IACD;AACA,QAAI,KAAK,CAAC,GAAG;AACZ,6BAAuB,OAAO,KAAK,CAAC,CAAC;AAAA,IACtC;AACA,WAAO;AAAA,EACR;AAAA,EACA,UAAU,UAAU;AACnB,UAAM,OAAO;AACb,QAAI,QAAoB,CAAC;AACzB,QAAI,KAAK,CAAC,GAAG;AACZ,6BAAuB,OAAO,KAAK,CAAC,CAAC;AAAA,IACtC;AACA,WAAO;AAAA,EACR;AAAA,EACA,IAAI,UAAU;AACb,UAAM,OAAO;AACb,QAAI,QAAoB,CAAC;AACzB,QAAI,MAAM,QAAQ,KAAK,CAAC,CAAC,GAAG;AAC3B,YAAM,OAAO,KAAK,CAAC;AACnB,cAAQ;AAAA;AAAA,QAEP,gBAAgB,KAAK,CAAC;AAAA,QACtB,2BAA2B,KAAK;AAAA,MACjC;AAAA,IACD,OAAO;AACN,cAAQ;AAAA,QACP,gBAAgB,KAAK,CAAC;AAAA,MACvB;AAAA,IACD;AACA,QAAI,KAAK,CAAC,GAAG;AACZ,6BAAuB,OAAO,KAAK,CAAC,CAAC;AAAA,IACtC;AACA,WAAO;AAAA,EACR;AAAA,EACA,KAAK,UAAU,QAAsE;AACpF,UAAM,OAAO;AACb,UAAM,QAAoB;AAAA,MACzB,8BAA8B,OAAO;AAAA,IACtC;AACA,QAAI,KAAK,CAAC,GAAG;AACZ,YAAM,UAAU,KAAK,CAAC;AACtB,6BAAuB,OAAO,OAAO;AACrC,UAAI,WAAW,SAAS;AACvB,cAAM,gBAAgB,IAAI,QAAQ;AAAA,MACnC;AACA,UAAI,gBAAgB,SAAS;AAC5B,cAAM,sBAAsB,IAAI,QAAQ;AAAA,MACzC;AACA,UAAI,SAAS,SAAS;AACrB,cAAM,cAAc,IAAI,QAAQ;AAAA,MACjC;AACA,UAAI,YAAY,SAAS;AACxB,cAAM,iBAAiB,IAAI,QAAQ;AAAA,MACpC;AACA,UAAI,aAAa,SAAS;AACzB,cAAM,kBAAkB,IAAI,QAAQ;AAAA,MACrC;AACA,UAAI,WAAW,SAAS;AACvB,cAAM,gBAAgB,IAAI,QAAQ;AAAA,MACnC;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EACA,IAAI,UAAU;AACb,UAAM,OAAO;AACb,UAAM,QAAoB,CAAC;AAC3B,QAAI,OAAO,KAAK,CAAC,MAAM,UAAU;AAChC,YAAM,cAAc,IAAI,KAAK,CAAC;AAC9B,UAAI,KAAK,CAAC,GAAG;AACZ,+BAAuB,OAAO,KAAK,CAAC,CAAC;AAAA,MACtC;AAAA,IACD,OAAO;AACN,YAAM,OAAO,OAAO,KAAK,KAAK,CAAC,CAAC;AAEhC,YAAM,cAAc,IAAI,KAAK,CAAC;AAC9B,YAAM,yBAAyB,IAAI,KAAK;AACxC,UAAI,6BAA6B,KAAK,CAAC,CAAC,GAAG;AAC1C,+BAAuB,OAAO,KAAK,CAAC,CAAC;AAAA,MACtC;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EACA,SAAS,UAAU;AAClB,UAAM,OAAO;AACb,UAAM,QAAoB,CAAC;AAC3B,QAAI,KAAK,CAAC,GAAG;AACZ,6BAAuB,OAAO,KAAK,CAAC,CAAC;AAAA,IACtC;AACA,WAAO;AAAA,EACR;AAAA,EACA,SAAS,UAAU;AAClB,UAAM,OAAO;AACb,UAAM,QAAoB,CAAC;AAC3B,QAAI,KAAK,CAAC,aAAa,MAAM;AAC5B,YAAM,qBAAqB,IAAI,KAAK,CAAC,EAAE,QAAQ;AAAA,IAChD,OAAO;AACN,YAAM,qBAAqB,IAAI,KAAK,CAAC;AAAA,IACtC;AACA,QAAI,KAAK,CAAC,GAAG;AACZ,6BAAuB,OAAO,KAAK,CAAC,CAAC;AAAA,IACtC;AACA,WAAO;AAAA,EACR;AAAA,EACA,YAAY,UAAU;AACrB,UAAM,OAAO;AACb,UAAM,QAAoB,CAAC;AAC3B,QAAI,KAAK,CAAC,GAAG;AACZ,6BAAuB,OAAO,KAAK,CAAC,CAAC;AAAA,IACtC;AACA,WAAO;AAAA,EACR;AACD;AAEA,SAAS,oBAAoB,IAAc,WAAmB;AAC7D,QAAMC,UAASC,QAAM,UAAU,YAAY;AAC3C,QAAM,YAA+B;AAAA,IACpC,OAAO,CAAC,QAAQ,SAAS,aAAa;AACrC,YAAM,aAAa;AAAA,QAClB,CAACC,oBAAmB,SAAS,GAAGH;AAAA,QAChC,CAACG,oBAAmB,YAAY,GAAG;AAAA,QACnC,CAACA,oBAAmB,YAAY,GAAG,GAAG,SAAS,IAAI,SAAS,CAAC,CAAC;AAAA,MAC/D;AACA,YAAM,UAAuB;AAAA,QAC5B,MAAMC,WAAS;AAAA,QACf,YAAY;AAAA,UACX,GAAG;AAAA,UACH;AAAA,QACD;AAAA,MACD;AACA,aAAOH,QAAO,gBAAgB,0BAA0B,SAAS,IAAI,SAAS,OAAO,SAAS;AAC7F,cAAM,SAAS,MAAM,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAC5D,cAAM,eAAe,kBAAkB,SAAS;AAChD,cAAM,aAAa,eAAe,aAAa,UAAU,MAAM,IAAI,CAAC;AACpE,aAAK,cAAc,UAAU;AAC7B,aAAK,aAAa,uBAAuB,CAAC,CAAC,MAAM;AACjD,aAAK,IAAI;AACT,eAAO;AAAA,MACR,CAAC;AAAA,IACF;AAAA,EACD;AACA,SAAO,KAAK,IAAI,SAAS;AAC1B;AAEO,SAAS,kBAAkB,SAAqD;AACtF,QAAM,iBAAqD;AAAA,IAC1D,KAAK,CAAC,QAAQ,MAAM,aAAa;AAChC,YAAM,YAAY,OAAO,IAAI;AAC7B,YAAM,KAAK,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAC7C,aAAO,oBAAoB,IAAI,SAAS;AAAA,IACzC;AAAA,EACD;AACA,SAAO,KAAK,SAAS,cAAc;AACpC;;;AN1LA,SAAS,iBAAiB,0BAA0B;AAOpD,SAAS,sBAAsB,MAAyB,QAAmC;AAC1F,QAAM,cAAyC;AAAA,IAC9C,IAAI,QAAQ,MAAM,UAAU;AAC3B,UAAI,SAAS,SAAS;AACrB,cAAM,UAAU,QAAQ,IAAI,QAAQ,IAAI;AACxC,cAAM,QAAQ;AAAA,UACb,MAAM,kBAAkB,MAAM;AAAA,UAC9B,gBAAgB;AAAA,UAChB,SAAS,OAAO,GAAG,SAAS;AAAA,UAC5B,cAAc,OAAO,GAAG;AAAA,QACzB;AACA,eAAO,sBAAsB,SAAS,OAAO,EAAE,qBAAqB,KAAK,IAAI,KAAK;AAAA,MACnF,OAAO;AACN,eAAO,eAAe,QAAQ,MAAM,QAAQ;AAAA,MAC7C;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,MAAM,WAAW;AAC9B;AAEA,SAAS,qBAAqB,OAAsC,QAA+C;AAClH,QAAM,aAA0D;AAAA,IAC/D,MAAM,QAAQ,SAAS,UAAU;AAChC,YAAM,OAA0B,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AACvE,aAAO,sBAAsB,MAAM,MAAM;AAAA,IAC1C;AAAA,EACD;AACA,SAAO,KAAK,OAAO,UAAU;AAC9B;AAEO,SAAS,oBAAoB,IAA4B,QAAgB;AAC/E,QAAM,YAAqC;AAAA,IAC1C,IAAI,QAAQ,MAAM,UAAU;AAC3B,UAAI,SAAS,OAAO;AACnB,cAAM,KAAK,QAAQ,IAAI,IAAI,MAAM,QAAQ;AACzC,eAAO,qBAAqB,IAAI,MAAM;AAAA,MACvC,OAAO;AACN,eAAO,eAAe,QAAQ,MAAM,QAAQ;AAAA,MAC7C;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,IAAI,SAAS;AAC1B;AAEO,SAAS,gBAAgB,OAA2B;AAC1D,QAAM,eAAiD;AAAA,IACtD,IAAI,QAAQ,MAAM,UAAU;AAC3B,YAAM,SAAS,QAAQ,IAAI,QAAQ,MAAM,OAAO,QAAQ,CAAC;AACzD,UAAI,SAAS,WAAW;AACvB,eAAO,kBAAkB,OAAO,KAAK,MAAM,CAAC;AAAA,MAC7C,WAAW,OAAO,WAAW,YAAY;AACxC,eAAO,OAAO,KAAK,MAAM;AAAA,MAC1B,OAAO;AACN,eAAO;AAAA,MACR;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,OAAO,YAAY;AAChC;AAEA,IAAI,aAAa;AACV,SAAS,eAAe,SAAkB,SAAkB,IAAwC;AAC1G,QAAM,cAAc,4BAA4B,QAAQ,OAAO;AAE/D,QAAMI,UAASC,QAAM,UAAU,iBAAiB;AAChD,QAAM,aAAa;AAAA,IAClB,CAACC,oBAAmB,YAAY,GAAG;AAAA,IACnC,CAACA,oBAAmB,cAAc,GAAG;AAAA,EACtC;AACA,eAAa;AACb,SAAO,OAAO,YAAY,wBAAwB,OAAO,CAAC;AAC1D,SAAO,OAAO,YAAY,2BAA2B,OAAO,CAAC;AAC7D,QAAM,UAAuB;AAAA,IAC5B;AAAA,IACA,MAAMC,WAAS;AAAA,EAChB;AAEA,QAAM,OAAO,GAAG,QAAQ;AACxB,QAAM,UAAUH,QAAO,gBAAgB,wBAAwB,IAAI,IAAI,SAAS,aAAa,OAAO,SAAS;AAC5G,QAAI;AACH,YAAM,WAAqB,MAAM,QAAQ,OAAO;AAChD,UAAI,SAAS,IAAI;AAChB,aAAK,UAAU,EAAE,MAAMI,gBAAe,GAAG,CAAC;AAAA,MAC3C;AACA,WAAK,cAAc,yBAAyB,QAAQ,CAAC;AACrD,WAAK,IAAI;AAET,aAAO;AAAA,IACR,SAAS,OAAO;AACf,WAAK,gBAAgB,KAAkB;AACvC,WAAK,UAAU,EAAE,MAAMA,gBAAe,MAAM,CAAC;AAC7C,WAAK,IAAI;AACT,YAAM;AAAA,IACP;AAAA,EACD,CAAC;AACD,SAAO;AACR;AAEO,SAAS,eAAe,SAA+B,IAAoC;AACjG,QAAMJ,UAASC,QAAM,UAAU,iBAAiB;AAEhD,QAAM,OAAO,GAAG,QAAQ;AACxB,QAAM,UAAUD,QAAO,gBAAgB,wBAAwB,IAAI,IAAI,OAAO,SAAS;AACtF,SAAK,aAAaE,oBAAmB,gBAAgB,UAAU;AAC/D,iBAAa;AACb,SAAK,aAAa,SAAS,GAAG,SAAS,CAAC;AACxC,QAAI,GAAG,KAAM,MAAK,aAAa,WAAW,GAAG,IAAI;AAEjD,QAAI;AACH,YAAM,QAAQ;AACd,WAAK,IAAI;AAAA,IACV,SAAS,OAAO;AACf,WAAK,gBAAgB,KAAkB;AACvC,WAAK,UAAU,EAAE,MAAME,gBAAe,MAAM,CAAC;AAC7C,WAAK,IAAI;AACT,YAAM;AAAA,IACP;AAAA,EACD,CAAC;AACD,SAAO;AACR;AAEA,SAAS,kBAAkB,SAAkB,aAA0BC,MAAU,IAA8B;AAC9G,QAAM,eAAsC;AAAA,IAC3C,MAAM,MAAM,QAAQ,SAAS,UAA+B;AAC3D,YAAM,UAAU,SAAS,CAAC;AAC1B,YAAM,SAAS,YAAYA,MAAK,OAAO;AACvC,YAAMC,WAAU,UAAU,MAAM;AAChC,UAAI;AACH,cAAM,QAAQ,OAAO,KAAK,OAAO,OAAO,CAAC;AACzC,eAAO,MAAMC,aAAY,KAAKD,UAAS,gBAAgB,QAAW,OAAO,SAAS,EAAE;AAAA,MACrF,SAAS,OAAO;AACf,cAAM;AAAA,MACP;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,SAAS,YAAY;AAClC;AAEA,SAAS,kBAAkB,SAAkB,aAA0BD,MAAU,IAAqB;AACrG,MAAI,CAAC,QAAS,QAAO;AAErB,QAAM,eAAmD;AAAA,IACxD,MAAM,MAAM,QAAQ,SAAS;AAC5B,YAAM,SAAS,YAAYA,MAAK,UAAU;AAC1C,YAAMC,WAAU,UAAU,MAAM;AAChC,UAAI;AACH,cAAM,QAAQ,OAAO,KAAK,OAAO,OAAO,CAAC;AACzC,eAAO,MAAMC,aAAY,KAAKD,UAAS,gBAAgB,QAAW,OAAO,EAAE;AAAA,MAC5E,SAAS,OAAO;AACf,cAAM;AAAA,MACP;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,SAAS,YAAY;AAClC;AAEA,SAAS,gBAAgB,IAAe,aAA0BD,MAAU,KAAsB;AACjG,MAAI,CAAC,GAAI,QAAO;AAEhB,QAAM,YAAqC;AAAA,IAC1C,MAAM,MAAM,QAAQ,SAAS,UAAc;AAC1C,gBAAU,OAAO,OAAO;AACxB,YAAM,SAAS,YAAYA,MAAK,UAAU;AAC1C,YAAMC,WAAU,UAAU,MAAM;AAChC,UAAI;AACH,cAAM,QAAQ,OAAO,KAAK,OAAO,OAAO,CAAC;AACzC,eAAO,MAAMC,aAAY,KAAKD,UAAS,MAAM,MAAM,MAAM,SAAS,QAAQ,GAAG,MAAS;AAAA,MACvF,SAAS,OAAO;AACf,cAAM;AAAA,MACP;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,IAAI,SAAS;AAC1B;AAEA,SAAS,wBACR,OACA,aACAD,MACA,OACA,YACC;AACD,QAAM,aAA0C;AAAA,IAC/C,IAAI,QAAQ,MAAM;AACjB,UAAI,cAAc,SAAS,OAAO;AACjC,eAAO;AAAA,MACR,WAAW,cAAc,SAAS,OAAO;AACxC,eAAOA;AAAA,MACR,WAAW,SAAS,SAAS;AAC5B,cAAM,UAAU,QAAQ,IAAI,QAAQ,IAAI;AACxC,eAAO,kBAAkB,SAAS,aAAaA,MAAK,MAAM,EAAE;AAAA,MAC7D,WAAW,SAAS,SAAS;AAC5B,cAAM,UAAU,QAAQ,IAAI,QAAQ,IAAI;AACxC,eAAO,kBAAkB,SAAS,aAAaA,MAAK,MAAM,EAAE;AAAA,MAC7D,OAAO;AACN,cAAM,SAAS,QAAQ,IAAI,QAAQ,IAAI;AACvC,YAAI,OAAO,WAAW,YAAY;AACjC,iBAAO,KAAK,KAAK;AACjB,iBAAO,gBAAgB,QAAQ,aAAaA,MAAK,MAAM,EAAE;AAAA,QAC1D;AACA,eAAO;AAAA,MACR;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,OAAO,UAAU;AAC9B;AAIO,SAAS,kBAAqC,SAAY,aAA6B;AAC7F,QAAM,eAAgC;AAAA,IACrC,UAAU,QAAQ,CAAC,YAAY,QAAQ,GAAmC;AACzE,YAAM,UAAgC;AAAA,QACrC,IAAI,WAAW,GAAG,SAAS;AAAA,QAC3B,MAAM,WAAW,GAAG;AAAA,MACrB;AACA,YAAM,oBAAoB,YAAY,UAAU,OAAO;AACvD,YAAMC,WAAU,UAAU,iBAAiB;AAC3C,YAAM,QAAQ,gBAAgB,UAAU;AACxC,YAAMD,OAAM,cAAc,QAAQ;AAClC,YAAM,aAAa,QAAQ,qBAAqB;AAChD,YAAM,WAAW,MAAM;AACtB,YAAI,YAAY;AACf,iBAAO,IAAI,OAAO,YAAY,QAAQ;AAAA,QACvC,OAAO;AACN,iBAAO,IAAI,OAAO,OAAOA,IAAG;AAAA,QAC7B;AAAA,MACD;AACA,YAAM,QAAQE,aAAY,KAAKD,UAAS,QAAQ;AAEhD,aAAO,wBAAwB,OAAO,aAAaD,MAAK,OAAO,UAAU;AAAA,IAC1E;AAAA,EACD;AACA,SAAO,KAAK,SAAS,YAAY;AAClC;;;AOhQA,SAAS,YAAAG,kBAAgB;AAEzB;AAAA,EACC;AAAA,EACA;AAAA,EACA,qBAAAC;AAAA,EACA;AAAA,OACM;AAEA,IAAM,2BAAyF;AAAA,EACrG,oBAAoB,SAAU,YAAkD;AAC/E,WAAO;AAAA,MACN,MAAM,oBAAoB,WAAW,IAAI;AAAA,MACzC,SAAS;AAAA,QACR,YAAY;AAAA,UACX,CAACA,kBAAiB,GAAG;AAAA,UACrB,CAAC,cAAc,GAAG,WAAW;AAAA,UAC7B,CAAC,cAAc,GAAG,IAAI,KAAK,WAAW,aAAa,EAAE,YAAY;AAAA,QAClE;AAAA,QACA,MAAMD,WAAS;AAAA,MAChB;AAAA,IACD;AAAA,EACD;AACD;;;ACrBO,SAAS,kBAAkBE,MAAkD;AACnF,QAAM,aAAa,CAAC;AAEpB,MAAI,OAAOA,SAAQ,YAAYA,SAAQ,MAAM;AAC5C,eAAW,CAAC,SAAS,IAAI,KAAK,OAAO,QAAQA,IAAG,GAAG;AAClD,UAAI,kBAAkB,IAAI,GAAG;AAC5B,mBAAW,qCAAqC,IAAI;AACpD,mBAAW,gCAAgC,IAAI,KAAK;AACpD,mBAAW,iCAAiC,IAAI,KAAK;AAErD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;;;AClBA,SAAS,SAAAC,eAAa;AAOf,IAAM,iBAAN,MAAqB;AAAA,EAC3B,uBAA2C,CAAC;AAAA,EAE5C,IAAI,0BAA0B;AAC7B,WAAO,KAAK,qBAAqB;AAAA,EAClC;AAAA,EAEA,MAAM,SAAiC;AACtC,SAAK,qBAAqB,KAAK,OAAO;AAAA,EACvC;AAAA,EAEA,MAAM,OAAO;AACZ,UAAM,kBAAkB,KAAK,oBAAoB;AAAA,EAClD;AACD;AAEA,SAAS,gBAAgB,IAAiBC,UAA2B,SAAsC;AAC1G,QAAM,UAAqC;AAAA,IAC1C,MAAM,QAAQ,UAAU,UAAU;AACjC,cAAQ,MAAM,SAAS,CAAC,CAAC;AACzB,aAAO,QAAQ,MAAM,QAAQA,UAAS,QAAQ;AAAA,IAC/C;AAAA,EACD;AACA,SAAO,KAAK,IAAI,OAAO;AACxB;AAEO,SAAS,sBAAsBA,UAA8C;AACnF,QAAM,UAAU,IAAI,eAAe;AACnC,QAAM,MAAM,IAAI,MAAMA,UAAS;AAAA,IAC9B,IAAI,QAAQ,MAAM;AACjB,UAAI,SAAS,aAAa;AACzB,cAAM,KAAK,QAAQ,IAAI,QAAQ,IAAI;AACnC,eAAO,gBAAgB,IAAIA,UAAS,OAAO;AAAA,MAC5C,OAAO;AACN,eAAO,eAAe,QAAQ,IAAI;AAAA,MACnC;AAAA,IACD;AAAA,EACD,CAAC;AACD,SAAO,EAAE,KAAK,QAAQ;AACvB;AAEA,eAAsB,YAAY,SAA0B;AAC3D,QAAMC,UAASC,QAAM,UAAU,QAAQ;AACvC,MAAID,mBAAkB,cAAc;AACnC,UAAM,UAAU,KAAK,CAAC;AACtB,UAAM,SAAS,KAAK;AACpB,UAAMA,QAAO,WAAW;AAAA,EACzB,OAAO;AACN,YAAQ,MAAM,wEAAwE;AAAA,EACvF;AACD;AAGA,eAAe,kBAAkB,UAAwE;AACxG,MAAI;AAGJ,KAAG;AACF,aAAS,MAAM,QAAQ,WAAW,QAAQ;AAAA,EAC3C,SAAS,OAAO,WAAW,SAAS;AACpC,SAAO;AACR;;;ACpEA,SAAS,YAAAE,kBAAkC;AAC3C;AAAA,EACC,qBAAAC;AAAA,EACA;AAAA,EACA;AAAA,OACM;AAcP,SAAS,iBAAiB,SAAwD;AACjF,SAAO,OAAO,YAAY,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,gBAAgB,GAAG,IAAI,KAAK,CAAU,CAAC;AAC9G;AAEO,IAAM,uBAAyF;AAAA,EACrG,oBAAoB,CAAC,YAAY;AAChC,UAAM,aAAa;AAAA,MAClB,CAACA,kBAAiB,GAAG;AAAA,MACrB,CAAC,mBAAmB,GAAG,QAAQ,QAAQ,IAAI,YAAY,KAAK;AAAA,MAC5D,CAAC,+BAA+B,GAAG,QAAQ;AAAA,IAC5C;AACA,WAAO,OAAO,YAAY,iBAAiB,OAAO,CAAC;AACnD,UAAM,UAAU;AAAA,MACf;AAAA,MACA,MAAMD,WAAS;AAAA,IAChB;AAEA,WAAO;AAAA,MACN,MAAM,gBAAgB,QAAQ,EAAE;AAAA,MAChC;AAAA,IACD;AAAA,EACD;AACD;;;AxBnBA,SAAS,WAAW;;;AyBnBpB,SAAoB,YAAAE,YAAuB,kBAAAC,iBAAgB,WAAWC,cAAa,SAAAC,eAAa;AA6LhG,IAAIC,cAAa;AACV,SAAS,mBAAmB,SAAqC,CAAC,KAAK,GAAuC;AACpH,QAAM,EAAE,MAAM,IAAI;AAClB,QAAM,cAAc,4BAA4B,MAAM,OAAO;AAE7D,QAAMC,UAASC,QAAM,UAAU,cAAc;AAC7C,QAAM,aAAa;AAAA,IAClB,CAAC,cAAc,GAAG;AAAA,IAClB,CAAC,gBAAgB,GAAGF;AAAA,IACpB,CAAC,oBAAoB,GAAG,MAAM,QAAQ,QAAQ,IAAI,QAAQ,KAAK;AAAA,EAChE;AACA,EAAAA,cAAa;AACb,SAAO,OAAO,YAAY,wBAAwB,MAAM,OAAO,CAAC;AAChE,SAAO,OAAO,YAAY,2BAA2B,MAAM,OAAO,CAAC;AACnE,QAAM,UAAuB;AAAA,IAC5B;AAAA,IACA,MAAMG,WAAS;AAAA,EAChB;AAEA,QAAM,UAAUF,QAAO;AAAA,IACtB,GAAG,MAAM,QAAQ,MAAM,IAAI,MAAM,IAAI,QAAQ;AAAA,IAC7C;AAAA,IACA;AAAA,IACA,OAAO,SAAS;AACf,YAAM,WAAW;AACjB,YAAM,SAAS,MAAM,QAAQ,OAAO,YAAY;AAChD,UAAI;AACH,cAAM,WAAqB,MAAM,QAAQ,KAAK;AAC9C,aAAK,cAAc,yBAAyB,QAAQ,CAAC;AACrD,YAAI,SAAS,WAAW,YAAY,GAAG;AACtC,eAAK,WAAW,GAAG,MAAM,QAAQ,MAAM,IAAI,SAAS,WAAW,YAAY,CAAC,EAAE;AAAA,QAC/E;AACA,aAAK,IAAI;AAET,eAAO;AAAA,MACR,SAAS,OAAO;AACf,aAAK,gBAAgB,KAAkB;AACvC,aAAK,UAAU,EAAE,MAAMG,gBAAe,MAAM,CAAC;AAC7C,cAAM;AAAA,MACP,UAAE;AACD,YAAI,SAAS,WAAW,YAAY,GAAG;AACtC,eAAK,WAAW,gBAAgB,MAAM,IAAI,SAAS,WAAW,YAAY,CAAC,EAAE;AAAA,QAC9E;AACA,aAAK,IAAI;AAAA,MACV;AAAA,IACD;AAAA,EACD;AACA,SAAO;AACR;AAEO,SAAS,kBAAkB,QAAoC,aAA0B;AAC/F,QAAM,eAAyD;AAAA,IAC9D,OAAO,OAAO,QAAQ,UAAU,aAAwE;AACvG,YAAM,CAAC,KAAK,IAAI;AAChB,YAAM,EAAE,MAAM,IAAI;AAElB,UAAI,EAAE,KAAAC,MAAK,SAAAC,SAAQ,IAAI,MAAM;AAC7B,YAAM,SAAS,YAAYD,MAAgC,MAAM,OAAO;AACxE,YAAM,gBAAgB,UAAU,MAAM;AAEtC,YAAM,OAAO,MAAM,cAAcA,IAA8B;AAC/D,YAAM,QAAQ,sBAAsB,MAAM,OAAO,CAACE,YAAWA,QAAO,KAAK;AACzE,YAAM,EAAE,KAAK,QAAQ,IAAI,sBAAsBD,QAAO;AAEtD,YAAM,OAAO,MAAM;AAEnB,UAAI;AACH,cAAM,OAAwB,CAAC,KAAK;AACpC,eAAO,MAAME,aAAY,KAAK,eAAe,oBAAoB,QAAW,QAAQ,IAAI;AAAA,MACzF,SAAS,OAAO;AACf,cAAM;AAAA,MACP,UAAE;AACD,QAAAF,SAAQ,UAAU,YAAY,OAAO,CAAC;AAAA,MACvC;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,QAAQ,YAAY;AACjC;;;AC7QA;AAAA,EACC,YAAAG;AAAA,EAEA,SAAAC;AAAA,EACA,WAAWC;AAAA,EAEX,eAAAC;AAAA,OAEM;AAIP,SAAS,sBAAAC,2BAA0B;AACnC,SAAS,wBAAwB;AAIjC,IAAM,gBAAgB,OAAO,SAAS;AAE/B,IAAe,yBAAf,cAAiF,iBAAoB;AAAA,EACnG;AAAA,EAER,YAAY,KAAuBC,MAAQ;AAC1C,UAAM,KAAKA,IAAG;AACd,SAAK,cAAc,CAAC;AAAA,EACrB;AAAA,EAEA,IAAW,gBAAgBA,MAAQ;AAClC,SAAK,cAAcA;AAAA,EACpB;AAAA,EAEU,oBAA0D;AACnE,WAAO;AAAA,MACN,KAAK,KAAK;AAAA,MACV,OAAO,KAAK;AAAA,IACb;AAAA,EACD;AACD;AAEO,SAAS,6BAA6B,UAAkE;AAC9G,SAAOC,aAAY,QAAiCC,aAAY,OAAO,GAAG,UAAU;AAAA,IACnF,IAAI,SAAS,KAAK;AACjB,YAAM,QAAQ,QAAQ,GAAG,KAAK;AAC9B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACzB,eAAO;AAAA,MACR;AACA,aAAO;AAAA,IACR;AAAA,IACA,KAAK,MAAM;AACV,aAAO,CAAC,GAAG,OAAO,KAAK,IAAI,CAAC;AAAA,IAC7B;AAAA,EACD,CAAC;AACF;AAEA,SAAS,+BACR,cACA,SACC;AACD,MAAI,iBAAiB,QAAW;AAC/B,WAAOA,aAAY,OAAO;AAAA,EAC3B;AAEA,QAAM,qBAAqB,aAAa,SAAS,MAAM,sBAAsB;AAC7E,SAAO,sBAAsB,CAAC,CAAC,UAC5B,6BAA8B,QAAQ,UAAU,KAAuD,CAAC,CAAC,IACzGA,aAAY,OAAO;AACvB;AAEO,SAAS,wBAA2D,aAA2C;AAErH,QAAM,YAA6B,CAClC,QACA,aACA,eACI;AACJ,UAAM,WAAW,WAAW;AAC5B,eAAW,QAAQ,kBAAmB,MAAiB;AACtD,YAAM,UAAU,MAAM,SAAS,IAAK,KAAK,CAAC,IAAgC,CAAC;AAC3E,YAAM,cAAc;AAEpB,YAAM,WAAW,YAAY;AAE7B,YAAM,WAAW,YAAY;AAC7B,YAAM,SAAS,YAAY,UAAqC,IAAI;AACpE,YAAMF,OAAM,cAAc,QAAmC;AAE7D,kBAAY,QAAQ,sBAAsB,YAAY,OAAO,CAACG,YAAWA,QAAO,KAAK;AACrF,YAAM,EAAE,QAAQ,IAAI,sBAAsB,QAAQ;AAClD,YAAMC,WAAU,UAAU,MAAM;AAEhC,UAAI;AAEH,oBAAY,kBAAkBJ;AAC9B,cAAM,2BAA2B,MAAwB;AACxD,gBAAM,cAAc,+BAA+B,QAAQ,OAAO;AAClE,gBAAMK,UAASC,QAAM,UAAU,YAAY;AAC3C,gBAAM,UAAuB;AAAA,YAC5B,YAAY;AAAA,cACX,CAACC,oBAAmB,YAAY,GAAG;AAAA,cACnC,qBAAqB;AAAA,YACtB;AAAA,YACA,MAAMC,WAAS;AAAA,UAChB;AACA,gBAAM,UAAUH,QAAO;AAAA,YACtB,OAAO,OAAO,YAAY,IAAI,IAAI,WAAW;AAAA,YAC7C;AAAA,YACA;AAAA,YACA,OAAO,SAAS;AACf,oBAAM,UAAU,KAAK,YAAY,EAAE;AACnC,cAAAH,aAAY,OAAO,EAAE,SAAS,eAAe,OAAO;AACpD,kBAAI;AACH,sBAAM,SAAS,MAAM,SAAS,MAAM,aAAa,IAAI;AACrD,qBAAK,IAAI;AACT,uBAAO;AAAA,cACR,SAAS,OAAO;AACf,qBAAK,gBAAgB,KAAkB;AACvC,qBAAK,IAAI;AACT,sBAAM;AAAA,cACP;AAAA,YACD;AAAA,UACD;AACA,iBAAO;AAAA,QACR;AACA,eAAO,MAAMA,aAAY,KAAKE,UAAS,wBAAwB;AAAA,MAChE,SAAS,OAAO;AACf,cAAM;AAAA,MACP,UAAE;AACD,iBAAS,UAAU,YAAY,OAAO,CAAC;AAAA,MACxC;AAAA,IACD;AACA,WAAO;AAAA,EACR;AACA,SAAO;AACR;;;A1B7FO,SAAS,UAAU,SAAsC;AAC/D,SAAO,mBAAmB;AAC3B;AAEO,SAAS,eAAe,SAA2C;AACzE,SAAO,CAAC,CAAE,QAAyB;AACpC;AAEO,SAAS,QAAQ,SAAyC;AAChE,SAAO,YAAY;AACpB;AAEA,SAAS,kBAAqD;AAC7D,SAAO,OAAO,OAAO,GAAG,EAAE,KAAK,CAAC,YAAiB;AAChD,WACC,OAAO,eAAe,OAAO,EAAE,YAAY,SAAS,YACpD,QAAQ,OAAO,UACf,QAAQ,QAAQ;AAAA,EAElB,CAAC;AACF;AAEA,IAAM,iBAAiB,CAAC,QAA6B,gBAAkD;AACtG,UAAQ,IAAI,EAAE,YAAY,CAAC;AAC3B,QAAM,sBAAsB;AAAA,IAC3B,kBAAkB;AAAA,IAClB,kBAAkB;AAAA,IAClB,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,IACnB,0BAA0B;AAAA,IAC1B,sBAAsB;AAAA,IACtB,yBAAkCK;AAAA,IAClC,oCAA6C;AAAA,IAC7C,wBAAwB,aAAa;AAAA,IACrC,yBAAyB,aAAa;AAAA,IACtC,+BAA+B,aAAa;AAAA,EAC7C;AACA,QAAM,kBAAkB,uBAAuB;AAAA,IAC9C,gBAAgB,OAAO,QAAQ;AAAA,IAC/B,qBAAqB,OAAO,QAAQ;AAAA,IACpC,mBAAmB,OAAO,QAAQ;AAAA,EACnC,CAAC;AACD,QAAM,WAAW,uBAAuB,mBAAmB;AAC3D,SAAO,SAAS,MAAM,eAAe;AACtC;AAEA,IAAI,cAAc;AAClB,SAAS,KAAK,QAAmC;AAChD,MAAI,CAAC,aAAa;AACjB,QAAI,OAAO,gBAAgB,uBAAuB;AACjD,4BAAsB;AAAA,IACvB;AACA,QAAI,OAAO,gBAAgB,uBAAuB;AACjD,4BAAsB;AAAA,IACvB;AACA,IAAAC,aAAY,oBAAoB,OAAO,UAAU;AACjD,UAAM,WAAW,eAAe,QAAQ,gBAAgB,CAAC;AAEzD,UAAM,WAAW,IAAI,qBAAqB,OAAO,gBAAgB,QAAQ;AACzE,aAAS,SAAS;AAClB,kBAAc;AAAA,EACf;AACD;AAEA,SAAS,kBAAkB,QAA0C;AACpE,MAAI,OAAO,WAAW,YAAY;AACjC,WAAO,CAACC,MAAK,YAAY;AACxB,YAAM,OAAO,YAAY,OAAOA,MAAK,OAAO,CAAC;AAC7C,WAAK,IAAI;AACT,aAAO;AAAA,IACR;AAAA,EACD,OAAO;AACN,WAAO,MAAM;AACZ,YAAM,OAAO,YAAY,MAAM;AAC/B,WAAK,IAAI;AACT,aAAO;AAAA,IACR;AAAA,EACD;AACD;AAEO,SAAS,qBAAqB,QAA8C;AAClF,QAAM,cAAc,kBAAkB,MAAM;AAC5C,SAAO,wBAAwB,WAAW;AAC3C;AAEA,eAAsBC,aAAY,SAAiB,SAA0B;AAC5E,QAAMC,UAASC,QAAM,UAAU,QAAQ;AACvC,MAAID,mBAAkB,cAAc;AACnC,UAAM,UAAU,KAAK,CAAC;AACtB,UAAM,SAAS,KAAK;AACpB,UAAMA,QAAO,WAAW,OAAO;AAAA,EAChC,OAAO;AACN,YAAQ,MAAM,wEAAwE;AAAA,EACvF;AACD;AAKA,IAAIE,cAAa;AACjB,SAAS,oBACR,iBACkH;AAClH,SAAO,CAAC,WAAW,SAAS;AAC3B,UAAM,CAAC,SAASJ,MAAKK,QAAO,IAAI;AAChC,UAAM,aAAa,cAAcL,IAAG;AACpC,UAAM,EAAE,KAAK,YAAY,QAAQ,IAAI,sBAAsBK,QAAO;AAElE,UAAM,sBAAsB,gBAAgB,oBAAoB,gBAAgB,kBAAkB,OAAO,IAAI;AAE7G,UAAMH,UAASC,QAAM,UAAU,SAAS;AAExC,UAAM,EAAE,MAAM,SAAS,SAAS,YAAY,IAAI,gBAAgB,mBAAmB,OAAO;AAC1F,UAAM,QAAQ,QAAQ,cAAc,CAAC;AACrC,UAAM,gBAAgB,IAAIC;AAC1B,YAAQ,aAAa;AACrB,WAAO,OAAO,OAAO,kBAAkBJ,IAAG,CAAC;AAC3C,IAAAI,cAAa;AAEb,UAAM,gBAAgB,eAAeE,aAAY,OAAO;AACxD,UAAM,SAASJ,QAAO,gBAAgB,MAAM,SAAS,eAAe,OAAO,SAAS;AACnF,UAAI;AACH,cAAMK,UAAS,MAAM,UAAU,qBAAqB,YAAY,UAAU;AAE1E,YAAI,gBAAgB,yBAAyB;AAC5C,gBAAM,aAAa,gBAAgB,wBAAwBA,OAAM;AACjE,eAAK,cAAc,UAAU;AAAA,QAC9B;AAEA,YAAI,gBAAgB,iBAAiB;AACpC,0BAAgB,gBAAgB,MAAM,SAASA,OAAM;AAAA,QACtD;AACA,eAAOA;AAAA,MACR,SAAS,OAAO;AACf,aAAK,gBAAgB,KAAkB;AACvC,aAAK,UAAU,EAAE,MAAMC,gBAAe,MAAM,CAAC;AAC7C,YAAI,gBAAgB,iBAAiB;AACpC,0BAAgB,gBAAgB,MAAM,SAAS,KAAK;AAAA,QACrD;AACA,cAAM;AAAA,MACP,UAAE;AACD,aAAK,IAAI;AACT,QAAAH,SAAQ,UAAUJ,aAAY,KAAK,YAAY,EAAE,SAAS,OAAO,CAAC;AAAA,MACnE;AAAA,IACD,CAAC;AAED,WAAO;AAAA,EACR;AACD;AAEA,SAAS,mBACR,SACA,WACA,aACA,iBACqB;AACrB,SAAO,CAAC,SAAYD,MAAQ,QAA0D;AACrF,UAAM,SAAS,YAAYA,MAAK,OAAO;AACvC,UAAMK,WAAU,UAAU,MAAM;AAEhC,UAAM,SAAS,oBAA6B,eAAe;AAC3D,WAAOC,aAAY,KAAKD,UAAS,QAAQ,SAAS,WAAW,CAAC,SAASL,MAAK,GAAG,CAAC;AAAA,EACjF;AACD;AAEO,SAAS,WACf,SACA,QAC2B;AAC3B,QAAM,cAAc,kBAAkB,MAAM;AAE5C,MAAI,QAAQ,OAAO;AAClB,UAAM,UAAU,OAAO,QAAQ,KAAK;AACpC,YAAQ,QAAQ,mBAAmB,SAAS,SAAS,aAAa,oBAAoB;AAAA,EACvF;AAEA,MAAI,QAAQ,WAAW;AACtB,UAAMS,aAAY,OAAO,QAAQ,SAAS;AAC1C,YAAQ,YAAY,mBAAmB,SAASA,YAAW,aAAa,wBAAwB;AAAA,EACjG;AAEA,MAAI,QAAQ,OAAO;AAClB,UAAM,SAAS,OAAO,QAAQ,KAAK;AACnC,YAAQ,QAAQ,mBAAmB,SAAS,QAAQ,aAAa,IAAI,qBAAqB,CAAC;AAAA,EAC5F;AAEA,MAAI,QAAQ,OAAO;AAClB,UAAM,UAAU,OAAO,QAAQ,KAAK;AACpC,YAAQ,QAAQ,mBAAmB,SAAS,SAAS,aAAa,oBAAoB;AAAA,EACvF;AAEA,SAAO;AACR;AAEO,SAAS,aAAa,SAAkB,QAA6B;AAC3E,QAAM,cAAc,kBAAkB,MAAM;AAE5C,SAAO,kBAAkB,SAAS,WAAW;AAC9C;AAEO,SAAS,eACf,cACA,QAC6B;AAC7B,QAAM,cAAc,kBAAkB,MAAM;AAC5C,iBAAe,kBAAkB,cAAc,WAAW;AAC1D,SAAO;AACR;AAEO,IAAM,mBAAmB,OAAO,KAAK;;;A2BxP5C,SAAuB,oBAAAC,yBAAwB;AAIxC,IAAM,oBAAN,MAAgD;AAAA,EAC9C;AAAA,EACR,YAAY,WAAgC;AAC3C,SAAK,YAAY;AAAA,EAClB;AAAA,EAEA,OAAO,OAAc,gBAAsD;AAC1E,eAAW,YAAY,KAAK,WAAW;AACtC,eAAS,OAAO,OAAO,cAAc;AAAA,IACtC;AAAA,EACD;AAAA,EAEA,MAAM,WAA0B;AAC/B,eAAW,YAAY,KAAK,WAAW;AACtC,YAAM,SAAS,SAAS;AAAA,IACzB;AAAA,EACD;AACD;AAIO,IAAM,yBAAN,MAAqD;AAAA,EACnD;AAAA,EACR,YAAY,WAAgC;AAC3C,SAAK,YAAY;AAAA,EAClB;AAAA,EAEA,OAAO,OAAc,gBAAsD;AAC1E,UAAM,WAAW,KAAK,UAAU;AAAA,MAC/B,CAAC,aACA,IAAI,QAAsB,CAAC,YAAY;AACtC,iBAAS,OAAO,OAAO,OAAO;AAAA,MAC/B,CAAC;AAAA,IACH;AAEA,YAAQ,IAAI,QAAQ,EAAE,KAAK,CAAC,YAAY;AACvC,YAAM,SAAS,QAAQ,OAAO,CAAC,WAAW,OAAO,SAASA,kBAAiB,MAAM;AACjF,UAAI,OAAO,SAAS,GAAG;AAEtB,uBAAe,EAAE,MAAMA,kBAAiB,QAAQ,OAAO,OAAO,CAAC,EAAG,MAAM,CAAC;AAAA,MAC1E,OAAO;AACN,uBAAe,EAAE,MAAMA,kBAAiB,QAAQ,CAAC;AAAA,MAClD;AAAA,IACD,CAAC;AAAA,EACF;AAAA,EAEA,MAAM,WAA0B;AAC/B,UAAM,QAAQ,IAAI,KAAK,UAAU,IAAI,CAAC,aAAa,SAAS,SAAS,CAAC,CAAC;AAAA,EACxE;AACD;","names":["api_context","propagation","SpanStatusCode","trace","@microlabs/otel-cf-workers","@microlabs/otel-cf-workers","ExportResultCode","ExportResultCode","context","trace","context","TraceFlags","SpanKind","sanitizeAttributes","SpanStatusCode","init","context","SpanKind","sanitizeAttributes","TraceFlags","span","trace","context","trace","SpanKind","api_context","SpanStatusCode","api_context","headers","SpanKind","tracer","trace","SpanStatusCode","SpanKind","trace","trace","SpanKind","trace","SpanKind","propagation","api_context","trace","target","prop","SpanKind","propagation","api_context","tracer","api_context","trace","SpanKind","SpanStatusCode","SemanticAttributes","SpanKind","trace","SemanticAttributes","tracer","trace","SemanticAttributes","SpanKind","api_context","propagation","SpanKind","SpanStatusCode","trace","fetcher","tracer","trace","SpanKind","propagation","api_context","SpanStatusCode","SpanKind","SpanStatusCode","trace","SemanticAttributes","dbSystem","SemanticAttributes","SpanKind","tracer","trace","SpanStatusCode","SpanKind","trace","SemanticAttributes","dbSystem","tracer","trace","SemanticAttributes","SpanKind","env","SpanKind","trace","SemanticAttributes","dbSystem","tracer","trace","SemanticAttributes","SpanKind","tracer","trace","SemanticAttributes","SpanKind","SpanStatusCode","env","context","api_context","SpanKind","ATTR_FAAS_TRIGGER","env","trace","context","tracer","trace","SpanKind","ATTR_FAAS_TRIGGER","SpanKind","SpanStatusCode","api_context","trace","cold_start","tracer","trace","SpanKind","SpanStatusCode","env","context","config","api_context","SpanKind","trace","api_context","propagation","SemanticAttributes","env","propagation","api_context","config","context","tracer","trace","SemanticAttributes","SpanKind","@microlabs/otel-cf-workers","propagation","env","exportSpans","tracer","trace","cold_start","context","api_context","result","SpanStatusCode","scheduler","ExportResultCode"]}