{"version":3,"sources":["../src/index.ts","../src/buffer.ts","../src/sampling.ts","../src/sdk.ts","../src/config.ts","../src/types.ts","../src/exporter.ts","../src/wrap.ts","../src/spanprocessor.ts","../src/vendor/ts-checked-fsm/StateMachine.ts","../src/provider.ts","../src/context.ts","../src/tracer.ts","../src/span.ts","../src/instrumentation/fetch.ts","../src/instrumentation/do.ts","../src/instrumentation/common.ts","../src/instrumentation/do-storage.ts","../src/instrumentation/kv.ts","../src/instrumentation/queue.ts","../src/instrumentation/version.ts","../src/instrumentation/service.ts","../src/instrumentation/d1.ts","../src/instrumentation/analytics-engine.ts","../src/instrumentation/env.ts","../src/instrumentation/cache.ts","../src/instrumentation/scheduled.ts","../versions.json","../src/instrumentation/email.ts","../src/instrumentation/page.ts","../src/multiexporter.ts"],"sourcesContent":["export * from './buffer.js'\nexport * from './sampling.js'\nexport * from './sdk.js'\nexport * from './span.js'\nexport * from './exporter.js'\nexport * from './multiexporter.js'\nexport * from './spanprocessor.js'\nexport { withNextSpan } from './tracer.js'\nexport type * from './types.js'\n","//@ts-ignore\nimport { Buffer } from 'node:buffer'\n//@ts-ignore\nglobalThis.Buffer = Buffer\n","import { TraceFlags, SpanStatusCode } from '@opentelemetry/api'\nimport { ParentBasedSampler, ReadableSpan, Sampler, TraceIdRatioBasedSampler } from '@opentelemetry/sdk-trace-base'\nimport { ParentRatioSamplingConfig } from './types'\n\nexport interface LocalTrace {\n\treadonly traceId: string\n\treadonly localRootSpan: ReadableSpan\n\treadonly spans: ReadableSpan[]\n}\n\nexport type TailSampleFn = (traceInfo: LocalTrace) => boolean\n\nexport function multiTailSampler(samplers: TailSampleFn[]): TailSampleFn {\n\treturn (traceInfo) => {\n\t\treturn samplers.reduce((result, sampler) => result || sampler(traceInfo), false)\n\t}\n}\n\nexport const isHeadSampled: TailSampleFn = (traceInfo) => {\n\tconst localRootSpan = traceInfo.localRootSpan\n\treturn (localRootSpan.spanContext().traceFlags & TraceFlags.SAMPLED) === TraceFlags.SAMPLED\n}\n\nexport const isRootErrorSpan: TailSampleFn = (traceInfo) => {\n\tconst localRootSpan = traceInfo.localRootSpan\n\treturn localRootSpan.status.code === SpanStatusCode.ERROR\n}\n\nexport function createSampler(conf: ParentRatioSamplingConfig): Sampler {\n\tconst ratioSampler = new TraceIdRatioBasedSampler(conf.ratio)\n\tif (typeof conf.acceptRemote === 'boolean' && !conf.acceptRemote) {\n\t\treturn new ParentBasedSampler({\n\t\t\troot: ratioSampler,\n\t\t\tremoteParentSampled: ratioSampler,\n\t\t\tremoteParentNotSampled: ratioSampler,\n\t\t})\n\t} else {\n\t\treturn new ParentBasedSampler({ root: ratioSampler })\n\t}\n}\n","import { propagation } from '@opentelemetry/api'\nimport { Resource } from '@opentelemetry/resources'\n\nimport { Initialiser, parseConfig } from './config.js'\nimport { WorkerTracerProvider } from './provider.js'\nimport { Trigger, TraceConfig, ResolvedTraceConfig } from './types.js'\nimport { unwrap } from './wrap.js'\nimport { createFetchHandler, instrumentGlobalFetch } from './instrumentation/fetch.js'\nimport { instrumentGlobalCache } from './instrumentation/cache.js'\nimport { createQueueHandler } from './instrumentation/queue.js'\nimport { DOClass, instrumentDOClass } from './instrumentation/do.js'\nimport { createScheduledHandler } from './instrumentation/scheduled.js'\n//@ts-ignore\nimport * as versions from '../versions.json'\nimport { createEmailHandler } from './instrumentation/email.js'\nimport { createPageHandler } from './instrumentation/page.js'\n\ntype FetchHandler = ExportedHandlerFetchHandler<unknown, unknown>\ntype ScheduledHandler = ExportedHandlerScheduledHandler<unknown>\ntype QueueHandler = ExportedHandlerQueueHandler\ntype EmailHandler = EmailExportedHandler\n\nexport type ResolveConfigFn<Env = any> = (env: Env, trigger: Trigger) => TraceConfig\nexport type ConfigurationOption = TraceConfig | ResolveConfigFn\n\nexport function isRequest(trigger: Trigger): trigger is Request {\n\treturn trigger instanceof Request\n}\n\nexport function isMessageBatch(trigger: Trigger): trigger is MessageBatch {\n\treturn !!(trigger as MessageBatch).ackAll\n}\n\nexport function isAlarm(trigger: Trigger): trigger is 'do-alarm' {\n\treturn trigger === 'do-alarm'\n}\n\nconst createResource = (config: ResolvedTraceConfig): Resource => {\n\tconst workerResourceAttrs = {\n\t\t'cloud.provider': 'cloudflare',\n\t\t'cloud.platform': 'cloudflare.workers',\n\t\t'cloud.region': 'earth',\n\t\t'faas.max_memory': 134217728,\n\t\t'telemetry.sdk.language': 'js',\n\t\t'telemetry.sdk.name': '@microlabs/otel-cf-workers',\n\t\t'telemetry.sdk.version': versions['@microlabs/otel-cf-workers'],\n\t\t'telemetry.sdk.build.node_version': versions['node'],\n\t}\n\tconst serviceResource = new Resource({\n\t\t'service.name': config.service.name,\n\t\t'service.namespace': config.service.namespace,\n\t\t'service.version': config.service.version,\n\t})\n\tconst resource = new Resource(workerResourceAttrs)\n\treturn resource.merge(serviceResource)\n}\n\nlet initialised = false\nfunction init(config: ResolvedTraceConfig): void {\n\tif (!initialised) {\n\t\tif (config.instrumentation.instrumentGlobalCache) {\n\t\t\tinstrumentGlobalCache()\n\t\t}\n\t\tif (config.instrumentation.instrumentGlobalFetch) {\n\t\t\tinstrumentGlobalFetch()\n\t\t}\n\t\tpropagation.setGlobalPropagator(config.propagator)\n\t\tconst resource = createResource(config)\n\n\t\tconst provider = new WorkerTracerProvider(config.spanProcessors, resource)\n\t\tprovider.register()\n\t\tinitialised = true\n\t}\n}\n\nfunction createInitialiser(config: ConfigurationOption): Initialiser {\n\tif (typeof config === 'function') {\n\t\treturn (env, trigger) => {\n\t\t\tconst conf = parseConfig(config(env, trigger))\n\t\t\tinit(conf)\n\t\t\treturn conf\n\t\t}\n\t} else {\n\t\treturn () => {\n\t\t\tconst conf = parseConfig(config)\n\t\t\tinit(conf)\n\t\t\treturn conf\n\t\t}\n\t}\n}\n\nexport function instrumentPage<\n\tE = unknown,\n\tP extends string = any,\n\tD extends Record<string, unknown> = Record<string, unknown>,\n>(handler: PagesFunction<E, P, D>, config: ConfigurationOption): PagesFunction<E, P, D> {\n\tconst initialiser = createInitialiser(config)\n\n\thandler = createPageHandler(handler, initialiser)\n\n\treturn handler\n}\n\nexport function instrument<E, Q, C>(\n\thandler: ExportedHandler<E, Q, C>,\n\tconfig: ConfigurationOption,\n): ExportedHandler<E, Q, C> {\n\tconst initialiser = createInitialiser(config)\n\n\tif (handler.fetch) {\n\t\tconst fetcher = unwrap(handler.fetch) as FetchHandler\n\t\thandler.fetch = createFetchHandler(fetcher, initialiser)\n\t}\n\n\tif (handler.scheduled) {\n\t\tconst scheduler = unwrap(handler.scheduled) as ScheduledHandler\n\t\thandler.scheduled = createScheduledHandler(scheduler, initialiser)\n\t}\n\n\tif (handler.queue) {\n\t\tconst queuer = unwrap(handler.queue) as QueueHandler\n\t\thandler.queue = createQueueHandler(queuer, initialiser)\n\t}\n\n\tif (handler.email) {\n\t\tconst emailer = unwrap(handler.email) as EmailHandler\n\t\thandler.email = createEmailHandler(emailer, initialiser)\n\t}\n\n\treturn handler\n}\n\nexport function instrumentDO(doClass: DOClass, config: ConfigurationOption) {\n\tconst initialiser = createInitialiser(config)\n\n\treturn instrumentDOClass(doClass, initialiser)\n}\n\nexport { waitUntilTrace } from './instrumentation/fetch.js'\n\nexport const __unwrappedFetch = unwrap(fetch)\n","import { context } from '@opentelemetry/api'\nimport {\n\tExporterConfig,\n\tisSpanProcessorConfig,\n\tParentRatioSamplingConfig,\n\tResolvedTraceConfig,\n\tTraceConfig,\n\tTrigger,\n} from './types.js'\nimport { W3CTraceContextPropagator } from '@opentelemetry/core'\nimport { AlwaysOnSampler, ReadableSpan, Sampler, SpanExporter } from '@opentelemetry/sdk-trace-base'\n\nimport { OTLPExporter } from './exporter.js'\nimport { multiTailSampler, isHeadSampled, isRootErrorSpan, createSampler } from './sampling.js'\nimport { BatchTraceSpanProcessor } from './spanprocessor.js'\n\nconst configSymbol = Symbol('Otel Workers Tracing Configuration')\n\nexport type Initialiser = (env: Record<string, unknown>, trigger: Trigger) => ResolvedTraceConfig\n\nexport function setConfig(config: ResolvedTraceConfig, ctx = context.active()) {\n\treturn ctx.setValue(configSymbol, config)\n}\n\nexport function getActiveConfig(): ResolvedTraceConfig | undefined {\n\tconst config = context.active().getValue(configSymbol) as ResolvedTraceConfig\n\treturn config || undefined\n}\n\nfunction isSpanExporter(exporterConfig: ExporterConfig): exporterConfig is SpanExporter {\n\treturn !!(exporterConfig as SpanExporter).export\n}\n\nfunction isSampler(sampler: Sampler | ParentRatioSamplingConfig): sampler is Sampler {\n\treturn !!(sampler as Sampler).shouldSample\n}\n\nexport function parseConfig(supplied: TraceConfig): ResolvedTraceConfig {\n\tif (isSpanProcessorConfig(supplied)) {\n\t\tconst headSampleConf = supplied.sampling?.headSampler\n\t\tconst headSampler = headSampleConf\n\t\t\t? isSampler(headSampleConf)\n\t\t\t\t? headSampleConf\n\t\t\t\t: createSampler(headSampleConf)\n\t\t\t: new AlwaysOnSampler()\n\t\tconst spanProcessors = Array.isArray(supplied.spanProcessors) ? supplied.spanProcessors : [supplied.spanProcessors]\n\t\tif (spanProcessors.length === 0) {\n\t\t\tconsole.log(\n\t\t\t\t'Warning! You must either specify an exporter or your own SpanProcessor(s)/Exporter combination in the open-telemetry configuration.',\n\t\t\t)\n\t\t}\n\t\treturn {\n\t\t\tfetch: {\n\t\t\t\tincludeTraceContext: supplied.fetch?.includeTraceContext ?? true,\n\t\t\t},\n\t\t\thandlers: {\n\t\t\t\tfetch: {\n\t\t\t\t\tacceptTraceContext: supplied.handlers?.fetch?.acceptTraceContext ?? true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tpostProcessor: supplied.postProcessor || ((spans: ReadableSpan[]) => spans),\n\t\t\tsampling: {\n\t\t\t\theadSampler,\n\t\t\t\ttailSampler: supplied.sampling?.tailSampler || multiTailSampler([isHeadSampled, isRootErrorSpan]),\n\t\t\t},\n\t\t\tservice: supplied.service,\n\t\t\tspanProcessors,\n\t\t\tpropagator: supplied.propagator || new W3CTraceContextPropagator(),\n\t\t\tinstrumentation: {\n\t\t\t\tinstrumentGlobalCache: supplied.instrumentation?.instrumentGlobalCache ?? true,\n\t\t\t\tinstrumentGlobalFetch: supplied.instrumentation?.instrumentGlobalFetch ?? true,\n\t\t\t},\n\t\t}\n\t} else {\n\t\tconst exporter = isSpanExporter(supplied.exporter) ? supplied.exporter : new OTLPExporter(supplied.exporter)\n\t\tconst spanProcessors = [new BatchTraceSpanProcessor(exporter)]\n\t\tconst newConfig = Object.assign(supplied, { exporter: undefined, spanProcessors }) as TraceConfig\n\t\treturn parseConfig(newConfig)\n\t}\n}\n","import { TextMapPropagator } from '@opentelemetry/api'\nimport { ReadableSpan, Sampler, SpanExporter, SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { OTLPExporterConfig } from './exporter.js'\nimport { FetchHandlerConfig, FetcherConfig } from './instrumentation/fetch.js'\nimport { TailSampleFn } from './sampling.js'\n\nexport type PostProcessorFn = (spans: ReadableSpan[]) => ReadableSpan[]\n\nexport type ExporterConfig = OTLPExporterConfig | SpanExporter\n\nexport interface HandlerConfig {\n\tfetch?: FetchHandlerConfig\n}\n\nexport interface ServiceConfig {\n\tname: string\n\tnamespace?: string\n\tversion?: string\n}\n\nexport interface ParentRatioSamplingConfig {\n\tacceptRemote?: boolean\n\tratio: number\n}\n\ntype HeadSamplerConf = Sampler | ParentRatioSamplingConfig\nexport interface SamplingConfig<HS extends HeadSamplerConf = HeadSamplerConf> {\n\theadSampler?: HS\n\ttailSampler?: TailSampleFn\n}\n\nexport interface InstrumentationOptions {\n\tinstrumentGlobalFetch?: boolean\n\tinstrumentGlobalCache?: boolean\n}\n\ninterface TraceConfigBase {\n\tservice: ServiceConfig\n\thandlers?: HandlerConfig\n\tfetch?: FetcherConfig\n\tpostProcessor?: PostProcessorFn\n\tsampling?: SamplingConfig\n\tpropagator?: TextMapPropagator\n\tinstrumentation?: InstrumentationOptions\n}\n\ninterface TraceConfigExporter extends TraceConfigBase {\n\texporter: ExporterConfig\n}\n\ninterface TraceConfigSpanProcessors extends TraceConfigBase {\n\tspanProcessors: SpanProcessor | SpanProcessor[]\n}\n\nexport type TraceConfig = TraceConfigExporter | TraceConfigSpanProcessors\n\nexport function isSpanProcessorConfig(config: TraceConfig): config is TraceConfigSpanProcessors {\n\treturn !!(config as TraceConfigSpanProcessors).spanProcessors\n}\n\nexport interface ResolvedTraceConfig extends TraceConfigBase {\n\thandlers: Required<HandlerConfig>\n\tfetch: Required<FetcherConfig>\n\tpostProcessor: PostProcessorFn\n\tsampling: Required<SamplingConfig<Sampler>>\n\tspanProcessors: SpanProcessor[]\n\tpropagator: TextMapPropagator\n\tinstrumentation: InstrumentationOptions\n}\n\nexport interface DOConstructorTrigger {\n\tid: string\n\tname?: string\n}\n\nexport type Trigger =\n\t| Request\n\t| MessageBatch\n\t| ScheduledController\n\t| DOConstructorTrigger\n\t| 'do-alarm'\n\t| ForwardableEmailMessage\n","import { createExportTraceServiceRequest } from '@opentelemetry/otlp-transformer'\nimport { ExportServiceError, OTLPExporterError } from '@opentelemetry/otlp-exporter-base'\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core'\nimport { SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport { unwrap } from './wrap.js'\n\nexport interface OTLPExporterConfig {\n\turl: string\n\theaders?: Record<string, string>\n}\n\nconst defaultHeaders: Record<string, string> = {\n\taccept: 'application/json',\n\t'content-type': 'application/json',\n}\n\nexport class OTLPExporter implements SpanExporter {\n\tprivate headers: Record<string, string>\n\tprivate url: string\n\tconstructor(config: OTLPExporterConfig) {\n\t\tthis.url = config.url\n\t\tthis.headers = Object.assign({}, defaultHeaders, config.headers)\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tthis._export(items)\n\t\t\t.then(() => {\n\t\t\t\tresultCallback({ code: ExportResultCode.SUCCESS })\n\t\t\t})\n\t\t\t.catch((error: ExportServiceError) => {\n\t\t\t\tresultCallback({ code: ExportResultCode.FAILED, error })\n\t\t\t})\n\t}\n\n\tprivate _export(items: any[]): Promise<unknown> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tthis.send(items, resolve, reject)\n\t\t\t} catch (e) {\n\t\t\t\treject(e)\n\t\t\t}\n\t\t})\n\t}\n\n\tsend(items: any[], onSuccess: () => void, onError: (error: OTLPExporterError) => void): void {\n\t\tconst exportMessage = createExportTraceServiceRequest(items, {\n\t\t\tuseHex: true,\n\t\t\tuseLongBits: false,\n\t\t})\n\t\tconst body = JSON.stringify(exportMessage)\n\t\tconst params: RequestInit = {\n\t\t\tmethod: 'POST',\n\t\t\theaders: this.headers,\n\t\t\tbody,\n\t\t}\n\n\t\tunwrap(fetch)(this.url, params)\n\t\t\t.then((response) => {\n\t\t\t\tif (response.ok) {\n\t\t\t\t\tonSuccess()\n\t\t\t\t} else {\n\t\t\t\t\tonError(new OTLPExporterError(`Exporter received a statusCode: ${response.status}`))\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tonError(new OTLPExporterError(`Exception during export: ${error.toString()}`, error.code, error.stack))\n\t\t\t})\n\t}\n\n\tasync shutdown(): Promise<void> {}\n}\n","const unwrapSymbol = Symbol('unwrap')\n\ntype Wrapped<T> = { [unwrapSymbol]: T } & T\n\nexport function isWrapped<T>(item: T): item is Wrapped<T> {\n\treturn item && !!(item as Wrapped<T>)[unwrapSymbol]\n}\n\nexport function isProxyable(item: any) {\n\treturn (item !== null && typeof item === 'object') || typeof item === 'function'\n}\n\nexport function wrap<T extends object>(item: T, handler: ProxyHandler<T>, autoPassthrough: boolean = true): T {\n\tif (isWrapped(item) || !isProxyable(item)) {\n\t\treturn item\n\t}\n\tconst proxyHandler = Object.assign({}, handler)\n\tproxyHandler.get = (target, prop, receiver) => {\n\t\tif (prop === unwrapSymbol) {\n\t\t\treturn item\n\t\t} else {\n\t\t\tif (handler.get) {\n\t\t\t\treturn handler.get(target, prop, receiver)\n\t\t\t} else if (prop === 'bind') {\n\t\t\t\treturn () => receiver\n\t\t\t} else if (autoPassthrough) {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t}\n\t}\n\tproxyHandler.apply = (target, thisArg, argArray) => {\n\t\tif (handler.apply) {\n\t\t\treturn handler.apply(unwrap(target), unwrap(thisArg), argArray)\n\t\t}\n\t}\n\treturn new Proxy(item, proxyHandler)\n}\n\nexport function unwrap<T extends object>(item: T): T {\n\tif (item && isWrapped(item)) {\n\t\treturn item[unwrapSymbol]\n\t} else {\n\t\treturn item\n\t}\n}\n\nexport function passthroughGet(target: any, prop: string | symbol, thisArg?: any) {\n\tconst unwrappedTarget = unwrap(target)\n\tconst value = Reflect.get(unwrappedTarget, prop)\n\tif (typeof value === 'function') {\n\t\tif (value.constructor.name === 'RpcProperty') {\n\t\t\treturn (...args: unknown[]) => unwrappedTarget[prop](...args)\n\t\t}\n\t\tthisArg = thisArg || unwrappedTarget\n\t\treturn value.bind(thisArg)\n\t} else {\n\t\treturn value\n\t}\n}\n","import { Context, Span, trace } from '@opentelemetry/api'\nimport { ReadableSpan, SpanExporter, SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core'\nimport { Action, State, stateMachine } from './vendor/ts-checked-fsm/StateMachine.js'\n\nimport { getActiveConfig } from './config.js'\nimport { TailSampleFn } from './sampling.js'\nimport { PostProcessorFn } from './types.js'\n\ntype CompletedTrace = {\n\ttraceId: string\n\tlocalRootSpan: ReadableSpan\n\tcompletedSpans: ReadableSpan[]\n}\n\ntype InProgressTrace = {\n\tinProgressSpanIds: Set<string>\n} & CompletedTrace\n\ntype InitialState = State<'not_started'>\ntype InProgressTraceState = State<'in_progress', InProgressTrace>\ntype TraceCompleteState = State<'trace_complete', CompletedTrace>\ntype ExportingState = State<'exporting', { promise: Promise<ExportResult> }>\ntype DoneState = State<'done'>\n\ntype StartExportArguments = {\n\texporter: SpanExporter\n\ttailSampler: TailSampleFn\n\tpostProcessor: PostProcessorFn\n}\n\ntype StartSpanAction = Action<'startSpan', { span: Span }>\ntype EndSpanAction = Action<'endSpan', { span: ReadableSpan }>\ntype StartExportAction = Action<'startExport', { args: StartExportArguments }>\n\nfunction newTrace(currentState: InitialState, { span }: StartSpanAction): InProgressTraceState {\n\tconst spanId = span.spanContext().spanId\n\treturn {\n\t\t...currentState,\n\t\tstateName: 'in_progress',\n\t\ttraceId: span.spanContext().traceId,\n\t\tlocalRootSpan: span as unknown as ReadableSpan,\n\t\tcompletedSpans: [] as ReadableSpan[],\n\t\tinProgressSpanIds: new Set([spanId]),\n\t} as const\n}\n\nfunction newSpan(currentState: InProgressTraceState, { span }: StartSpanAction): InProgressTraceState {\n\tconst spanId = span.spanContext().spanId\n\tcurrentState.inProgressSpanIds.add(spanId)\n\treturn { ...currentState }\n}\n\nfunction endSpan(\n\tcurrentState: InProgressTraceState,\n\t{ span }: EndSpanAction,\n): InProgressTraceState | TraceCompleteState {\n\tcurrentState.completedSpans.push(span)\n\tcurrentState.inProgressSpanIds.delete(span.spanContext().spanId)\n\tif (currentState.inProgressSpanIds.size === 0) {\n\t\treturn {\n\t\t\tstateName: 'trace_complete',\n\t\t\ttraceId: currentState.traceId,\n\t\t\tlocalRootSpan: currentState.localRootSpan,\n\t\t\tcompletedSpans: currentState.completedSpans,\n\t\t} as const\n\t} else {\n\t\treturn { ...currentState }\n\t}\n}\n\nfunction startExport(currentState: TraceCompleteState, { args }: StartExportAction): ExportingState | DoneState {\n\tconst { exporter, tailSampler, postProcessor } = args\n\tconst { traceId, localRootSpan, completedSpans: spans } = currentState\n\tconst shouldExport = tailSampler({ traceId, localRootSpan, spans })\n\tif (shouldExport) {\n\t\tconst exportSpans = postProcessor(spans)\n\t\tconst promise = new Promise<ExportResult>((resolve) => {\n\t\t\texporter.export(exportSpans, resolve)\n\t\t})\n\t\treturn { stateName: 'exporting', promise }\n\t} else {\n\t\treturn { stateName: 'done' }\n\t}\n}\n\nconst { nextState } = stateMachine()\n\t.state('not_started')\n\t.state<'in_progress', InProgressTraceState>('in_progress')\n\t.state<'trace_complete', TraceCompleteState>('trace_complete')\n\t.state<'exporting', ExportingState>('exporting')\n\t.state('done')\n\t.transition('not_started', 'in_progress')\n\t.transition('in_progress', 'in_progress')\n\t.transition('in_progress', 'trace_complete')\n\t.transition('trace_complete', 'exporting')\n\t.transition('trace_complete', 'done')\n\t.transition('exporting', 'done')\n\t.action<'startSpan', StartSpanAction>('startSpan')\n\t.action<'endSpan', EndSpanAction>('endSpan')\n\t.action<'startExport', StartExportAction>('startExport')\n\t.action('exportDone')\n\t.actionHandler('not_started', 'startSpan', newTrace)\n\t.actionHandler('in_progress', 'startSpan', newSpan)\n\t.actionHandler('in_progress', 'endSpan', endSpan)\n\t.actionHandler('trace_complete', 'startExport', startExport)\n\t.actionHandler('exporting', 'exportDone', (_c, _a) => {\n\t\treturn { stateName: 'done' } as const\n\t})\n\t.done()\n\ntype AnyTraceState = Parameters<typeof nextState>[0]\ntype AnyTraceAction = Parameters<typeof nextState>[1]\n\nexport class BatchTraceSpanProcessor implements SpanProcessor {\n\tprivate traceLookup: Map<string, AnyTraceState> = new Map()\n\tprivate localRootSpanLookup: Map<string, string> = new Map()\n\tprivate inprogressExports: Map<string, Promise<ExportResult>> = new Map()\n\n\tconstructor(private exporter: SpanExporter) {}\n\n\tprivate action(localRootSpanId: string, action: AnyTraceAction): AnyTraceState {\n\t\tconst state = this.traceLookup.get(localRootSpanId) || { stateName: 'not_started' }\n\t\tconst newState = nextState(state, action)\n\t\tif (newState.stateName === 'done') {\n\t\t\tthis.traceLookup.delete(localRootSpanId)\n\t\t} else {\n\t\t\tthis.traceLookup.set(localRootSpanId, newState)\n\t\t}\n\t\treturn newState\n\t}\n\n\tprivate export(localRootSpanId: string) {\n\t\tconst config = getActiveConfig()\n\t\tif (!config) throw new Error('Config is undefined. This is a bug in the instrumentation logic')\n\n\t\tconst { sampling, postProcessor } = config\n\t\tconst exportArgs = { exporter: this.exporter, tailSampler: sampling.tailSampler, postProcessor }\n\t\tconst newState = this.action(localRootSpanId, { actionName: 'startExport', args: exportArgs })\n\t\tif (newState.stateName === 'exporting') {\n\t\t\tconst promise = newState.promise\n\t\t\tthis.inprogressExports.set(localRootSpanId, promise)\n\t\t\tpromise.then((result) => {\n\t\t\t\tif (result.code === ExportResultCode.FAILED) {\n\t\t\t\t\tconsole.log('Error sending spans to exporter:', result.error)\n\t\t\t\t}\n\t\t\t\tthis.action(localRootSpanId, { actionName: 'exportDone' })\n\t\t\t\tthis.inprogressExports.delete(localRootSpanId)\n\t\t\t})\n\t\t}\n\t}\n\n\tonStart(span: Span, parentContext: Context): void {\n\t\tconst spanId = span.spanContext().spanId\n\t\tconst parentSpanId = trace.getSpan(parentContext)?.spanContext()?.spanId\n\t\tconst parentRootSpanId = parentSpanId ? this.localRootSpanLookup.get(parentSpanId) : undefined\n\t\tconst localRootSpanId = parentRootSpanId || spanId\n\t\tthis.localRootSpanLookup.set(spanId, localRootSpanId)\n\n\t\tthis.action(localRootSpanId, { actionName: 'startSpan', span })\n\t}\n\n\tonEnd(span: ReadableSpan): void {\n\t\tconst spanId = span.spanContext().spanId\n\t\tconst localRootSpanId = this.localRootSpanLookup.get(spanId)\n\t\tif (localRootSpanId) {\n\t\t\tconst state = this.action(localRootSpanId, { actionName: 'endSpan', span })\n\t\t\tif (state.stateName === 'trace_complete') {\n\t\t\t\tstate.completedSpans.forEach((span) => {\n\t\t\t\t\tthis.localRootSpanLookup.delete(span.spanContext().spanId)\n\t\t\t\t})\n\t\t\t\tthis.export(localRootSpanId)\n\t\t\t}\n\t\t}\n\t}\n\n\tasync forceFlush(): Promise<void> {\n\t\tawait Promise.allSettled(this.inprogressExports.values())\n\t}\n\n\tasync shutdown(): Promise<void> {}\n}\n","/**\n * State labels can be strings\n */\ntype StateType = IndexType\n\n/**\n * Action labels can be strings\n */\nexport type ActionNameType = IndexType\n\n/**\n * Represents a state and data and its corresponding data.\n */\nexport type State<S extends StateType, D = {}> = Readonly<D> & {\n\treadonly stateName: S\n}\n\n/**\n * Give Actions to nextState() to (maybe) trigger a transition.\n */\nexport type Action<Name extends ActionNameType, Payload> = Readonly<Payload> & {\n\treadonly actionName: Name\n}\n\n///\n/// Errors\n///\n\n/**\n * Represents a compiler error message. Error brands prevent really clever users from naming their states as one of the error messages\n * and subverting error checking. Yet, the compiler still displays the string at the end of the failed cast indicating what the\n * issue is rather than something puzzling like could not assign to never.\n */\ntype ErrorBrand<T extends IndexType> = { [k in T]: void }\n\ntype IndexType = string | number\n\n/// Validators\ntype AssertStateInMap<StateMap, S extends StateType> =\n\tS extends MapKeys<StateMap> ? S : ErrorBrand<`'${S}' is not a state`>\ntype AssertNewState<S extends StateType, States> =\n\tS extends MapKeys<States> ? ErrorBrand<`'${S}' has already been declared`> : S\ntype AssertNewTransition<S extends StateType, N extends StateType, Transitions> =\n\tN extends MapLookup<Transitions, S> ? ErrorBrand<`There already exists a transition from '${S}' to '${N}'`> : N\ntype AssertActionNotDefined<AN extends ActionNameType, ActionNames extends IndexType> = AN extends ActionNames\n\t? ErrorBrand<`Action '${AN}' already declared`>\n\t: AN\ntype AssertActionIsDefined<AN extends ActionNameType, ActionNames extends IndexType> = AN extends ActionNames\n\t? AN\n\t: ErrorBrand<`'${AN}' is not an action`>\ntype AssertAllNonTerminalStatesHandled<Transitions, HandledStates> =\n\tMapKeys<Transitions> extends HandledStates\n\t\t? void\n\t\t: ErrorBrand<`No handlers declared for ${Exclude<MapKeys<Transitions>, HandledStates>}`>\n\ntype StateMachineDefinition<S, A> = {\n\thandlers: {\n\t\t[s: string]: {\n\t\t\t[a: string]: (cur: MapValues<S>, action: MapValues<A>) => MapValues<S>\n\t\t}\n\t}\n}\n\n// Allows us to append multiple values for the same key in a type map.\ntype AddToTypeMap<M, K extends string | number | symbol, V> = M | [K, V]\n\ntype MapLookup<Map, K extends string | number | symbol> = Map extends [K, infer V] ? V : never\ntype MapKeys<Map> = Map extends [infer K, infer _] ? (K extends IndexType ? K : never) : never\ntype MapValues<Map> = Map extends [infer _, infer V] ? V : never\n\n///\n/// stateMachine() builder\n///\n\n/**\n * A builder from calling stateMachine().\n */\nexport type StateMachineBuilder = {\n\t/**\n\t * Add a state to this state machine.\n\t */\n\treadonly state: StateFunc<never>\n}\n\ntype StateMachineFunc = () => StateMachineBuilder\n\n///\n/// .state() builder\n///\n\n/**\n * A builder from calling .state()\n */\nexport type StateBuilder<StateMap> = {\n\t/**\n\t * Add a state to this state machine.\n\t */\n\treadonly state: StateFunc<StateMap>\n\n\treadonly transition: TransitionFunc<StateMap, never>\n}\n\n/**\n * The signature for calling the state function in the builder.\n */\ntype StateFunc<StateMap> = <S extends StateType, Data = {}>(\n\tstate: AssertNewState<S, StateMap>,\n) => StateBuilder<AddToTypeMap<StateMap, S, State<S, Data>>>\n\n///\n/// .transition() builder\n///\n\n/**\n * The builder returned by .transition()\n */\nexport type TransitionBuilder<StateMap, Transitions> = {\n\t/**\n\t * Add a transition to this state machine.\n\t */\n\treadonly transition: TransitionFunc<StateMap, Transitions>\n\n\treadonly action: ActionFunc<StateMap, Transitions, never>\n}\n\n/**\n * The signature of .transition()\n */\nexport type TransitionFunc<StateMap, Transitions> = <S extends StateType, N extends StateType>(\n\tcurState: AssertStateInMap<StateMap, S>,\n\tnextState: N extends MapKeys<StateMap>\n\t\t? AssertNewTransition<S, N, Transitions>\n\t\t: ErrorBrand<`${S} is not a declared state`>,\n) => TransitionBuilder<StateMap, AddToTypeMap<Transitions, S, N>>\n\n///\n/// .action() builder\n///\n\nexport type ActionBuilder<StateMap, Transitions, ActionsMap> = {\n\treadonly action: ActionFunc<StateMap, Transitions, ActionsMap>\n\n\treadonly actionHandler: ActionHandlerFunc<StateMap, Transitions, ActionsMap, never>\n}\n\nexport type ActionFunc<StateMap, Transitions, ActionsMap> = <AN extends ActionNameType, AP = {}>(\n\tactionName: AssertActionNotDefined<AN, MapKeys<ActionsMap>>,\n) => ActionBuilder<StateMap, Transitions, AddToTypeMap<ActionsMap, AN, Action<AN, AP>>>\n\n///\n/// .actionsHandler() builder.\n///\n\n/**\n * The builder returned by .actionHandler()\n */\nexport type ActionHandlersBuilder<StateMap, Transitions, ActionsMap, HandledStates> = {\n\treadonly actionHandler: ActionHandlerFunc<StateMap, Transitions, ActionsMap, HandledStates>\n\n\treadonly done: DoneFunc<StateMap, ActionsMap, Transitions, HandledStates>\n}\n\n/**\n * The Signature of .actionHandler().\n */\nexport type ActionHandlerFunc<StateMap, Transitions, ActionMap, HandledStates> = <\n\tS extends StateType,\n\tAN extends ActionNameType,\n\tNS extends MapValues<StateMap>,\n>(\n\t// TODO: Checking that the action and state pair haven't already been declared here causes\n\tstate: AssertStateInMap<StateMap, S>,\n\taction: AssertActionIsDefined<AN, MapKeys<ActionMap>>,\n\thandler: ActionHandlerCallback<StateMap, Transitions, S, AN, NS, ActionMap>,\n) => ActionHandlersBuilder<StateMap, Transitions, ActionMap, HandledStates | S>\n\ntype ActionHandlerCallback<\n\tStates,\n\tTransitions,\n\tCS extends StateType,\n\tAN extends ActionNameType,\n\tNS extends MapValues<States>,\n\tActions,\n> = (\n\tstate: MapLookup<States, CS>,\n\taction: MapLookup<Actions, AN>,\n) => NS extends State<infer N, infer ND>\n\t? N extends MapKeys<States>\n\t\t? CS extends MapKeys<Transitions>\n\t\t\t? N extends MapLookup<Transitions, CS>\n\t\t\t\t? State<N, ND>\n\t\t\t\t: ErrorBrand<`No transition declared between ${CS} and ${N}`>\n\t\t\t: ErrorBrand<`State ${CS} is terminal and has no transitions`>\n\t\t: ErrorBrand<`${N} is not a state`>\n\t: ErrorBrand<'The returned value is not a state'>\n\n///\n/// .done()\n///\ntype DoneBuilder = <StateMap, ActionMap, Transitions, HandledStates>(\n\tdefinition: StateMachineDefinition<StateMap, ActionMap>,\n) => DoneFunc<StateMap, ActionMap, Transitions, HandledStates>\n\n// Check that the only unhandled states in the handler map are final states (i.e, they have no transitions out of them)\ntype DoneFunc<StateMap, ActionMap, Transitions, HandledStates> = (\n\t_: AssertAllNonTerminalStatesHandled<Transitions, HandledStates>,\n) => StateMachine<StateMap, ActionMap>\n\n/**\n * A state machine\n */\nexport type StateMachine<StateMap, ActionMap> = {\n\tnextState: (curState: MapValues<StateMap>, action: MapValues<ActionMap>) => MapValues<StateMap>\n}\n\nexport const stateMachine: StateMachineFunc = (): StateMachineBuilder => {\n\tconst stateFunc = state<never>()\n\n\treturn {\n\t\tstate: stateFunc,\n\t}\n}\n\nconst state = <StateMap>(): StateFunc<StateMap> => {\n\treturn <S extends StateType, D = {}>(_s: AssertNewState<S, StateMap>) => {\n\t\ttype NewStateMap = AddToTypeMap<StateMap, S, State<S, D>>\n\n\t\tconst transitionFunc = transition<NewStateMap, never>()\n\t\tconst stateFunc = state<NewStateMap>()\n\n\t\tconst builder = {\n\t\t\tstate: stateFunc,\n\t\t\ttransition: transitionFunc,\n\t\t}\n\n\t\treturn builder\n\t}\n}\n\nconst transition = <StateMap, Transitions>(): TransitionFunc<StateMap, Transitions> => {\n\treturn <S extends StateType, N extends StateType>(\n\t\t_curState: AssertStateInMap<StateMap, S>,\n\t\t_next: N extends MapKeys<StateMap>\n\t\t\t? AssertNewTransition<S, N, Transitions>\n\t\t\t: ErrorBrand<`${S} is not a declared state`>,\n\t) => {\n\t\ttype NewTransitions = AddToTypeMap<Transitions, S, N>\n\n\t\tconst transitionFunction = transition<StateMap, NewTransitions>()\n\t\tconst actionFunc = action<StateMap, NewTransitions, never>()\n\n\t\treturn {\n\t\t\ttransition: transitionFunction,\n\t\t\taction: actionFunc,\n\t\t}\n\t}\n}\n\nconst action = <StateMap, Transitions, ActionMap>(): ActionFunc<StateMap, Transitions, ActionMap> => {\n\treturn <AN extends ActionNameType, AP = {}>(_actionName: AssertActionNotDefined<AN, MapKeys<ActionMap>>) => {\n\t\ttype NewActionMap = AddToTypeMap<ActionMap, AN, Action<AN, AP>>\n\n\t\tconst actionFunc: any = action<StateMap, Transitions, NewActionMap>()\n\t\tconst actionHandlerFunc = actionHandler<StateMap, Transitions, NewActionMap, never>({ handlers: {} })\n\n\t\treturn {\n\t\t\taction: actionFunc,\n\t\t\tactionHandler: actionHandlerFunc,\n\t\t}\n\t}\n}\n\nconst actionHandler = <StateMap, Transitions, ActionMap, HandledStates>(\n\tdefinition: StateMachineDefinition<StateMap, ActionMap>,\n): ActionHandlerFunc<StateMap, Transitions, ActionMap, HandledStates> => {\n\treturn <S extends StateType, AN extends ActionNameType, NS extends MapValues<StateMap>>(\n\t\tstate: AssertStateInMap<StateMap, S>,\n\t\taction: AssertActionIsDefined<AN, MapKeys<ActionMap>>,\n\t\thandler: ActionHandlerCallback<StateMap, Transitions, S, AN, NS, ActionMap>,\n\t) => {\n\t\tconst untypedState = state as unknown as S\n\t\tconst untypedAction = action as unknown as AN\n\t\tconst newDefinition: StateMachineDefinition<StateMap, ActionMap> = {\n\t\t\t...definition,\n\t\t\thandlers: {\n\t\t\t\t...definition.handlers,\n\t\t\t\t[untypedState]: {\n\t\t\t\t\t...(definition.handlers[untypedState] ? definition.handlers[untypedState] : {}),\n\t\t\t\t\t[untypedAction]: handler as any,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttype NextHandledStates = HandledStates | S\n\n\t\tconst doneFunc = done<StateMap, ActionMap, Transitions, NextHandledStates>(newDefinition)\n\t\tconst actionHandlerFunc = actionHandler<StateMap, Transitions, ActionMap, NextHandledStates>(newDefinition)\n\n\t\treturn {\n\t\t\tactionHandler: actionHandlerFunc,\n\t\t\tdone: doneFunc,\n\t\t}\n\t}\n}\n\nconst done: DoneBuilder = <StateMap, ActionMap, Transitions, HandledStates>(\n\tdefinition: StateMachineDefinition<StateMap, ActionMap>,\n) => {\n\tconst doneFunc: DoneFunc<StateMap, ActionMap, Transitions, HandledStates> = (\n\t\t_: AssertAllNonTerminalStatesHandled<Transitions, HandledStates>,\n\t): StateMachine<StateMap, ActionMap> => {\n\t\tconst nextStateFunction = (curState: MapValues<StateMap>, action: MapValues<ActionMap>): MapValues<StateMap> => {\n\t\t\tconst curStateAsState = curState as unknown as State<string, {}>\n\t\t\tconst actionAsAction = action as unknown as Action<string, {}>\n\n\t\t\t// If no handler declared for state, state doesn't change.\n\t\t\tif (definition.handlers[curStateAsState.stateName] == null) {\n\t\t\t\treturn curState\n\t\t\t}\n\n\t\t\t// If no handler declared for action in given state, state doesn't change.\n\t\t\tconst handler = definition.handlers[curStateAsState.stateName]\n\t\t\tif (handler === undefined) {\n\t\t\t\treturn curState\n\t\t\t}\n\t\t\tconst nextAction = handler[actionAsAction.actionName]\n\n\t\t\treturn nextAction != null ? nextAction(curState, action) : curState\n\t\t}\n\n\t\treturn {\n\t\t\tnextState: nextStateFunction,\n\t\t}\n\t}\n\n\treturn doneFunc\n}\n","import { context, trace, Tracer, TracerOptions, TracerProvider } from '@opentelemetry/api'\n\nimport { SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { Resource } from '@opentelemetry/resources'\n\nimport { AsyncLocalStorageContextManager } from './context.js'\nimport { WorkerTracer } from './tracer.js'\n\n/**\n * Register this TracerProvider for use with the OpenTelemetry API.\n * Undefined values may be replaced with defaults, and\n * null values will be skipped.\n *\n * @param config Configuration object for SDK registration\n */\nexport class WorkerTracerProvider implements TracerProvider {\n\tprivate spanProcessors: SpanProcessor[]\n\tprivate resource: Resource\n\tprivate tracers: Record<string, Tracer> = {}\n\n\tconstructor(spanProcessors: SpanProcessor[], resource: Resource) {\n\t\tthis.spanProcessors = spanProcessors\n\t\tthis.resource = resource\n\t}\n\n\tgetTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n\t\tconst key = `${name}@${version || ''}:${options?.schemaUrl || ''}`\n\t\tif (!this.tracers[key]) {\n\t\t\tthis.tracers[key] = new WorkerTracer(this.spanProcessors, this.resource)\n\t\t}\n\t\treturn this.tracers[key]!\n\t}\n\n\tregister(): void {\n\t\ttrace.setGlobalTracerProvider(this)\n\t\tcontext.setGlobalContextManager(new AsyncLocalStorageContextManager())\n\t}\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextManager, Context, ROOT_CONTEXT } from '@opentelemetry/api'\n//@ts-ignore\nimport { AsyncLocalStorage } from 'node:async_hooks'\n//@ts-ignore\nimport { EventEmitter } from 'node:events'\n\ntype Func<T> = (...args: unknown[]) => T\n\n/**\n * Store a map for each event of all original listeners and their \"patched\"\n * version. So when a listener is removed by the user, the corresponding\n * patched function will be also removed.\n */\ninterface PatchMap {\n\t[name: string]: WeakMap<Func<void>, Func<void>>\n}\n\nconst ADD_LISTENER_METHODS = [\n\t'addListener' as const,\n\t'on' as const,\n\t'once' as const,\n\t'prependListener' as const,\n\t'prependOnceListener' as const,\n]\n\nabstract class AbstractAsyncHooksContextManager implements ContextManager {\n\tabstract active(): Context\n\n\tabstract with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\tcontext: Context,\n\t\tfn: F,\n\t\tthisArg?: ThisParameterType<F>,\n\t\t...args: A\n\t): ReturnType<F>\n\n\tabstract enable(): this\n\n\tabstract disable(): this\n\n\t/**\n\t * Binds a the certain context or the active one to the target function and then returns the target\n\t * @param context A context (span) to be bind to target\n\t * @param target a function or event emitter. When target or one of its callbacks is called,\n\t *  the provided context will be used as the active context for the duration of the call.\n\t */\n\tbind<T>(context: Context, target: T): T {\n\t\tif (target instanceof EventEmitter) {\n\t\t\treturn this._bindEventEmitter(context, target)\n\t\t}\n\n\t\tif (typeof target === 'function') {\n\t\t\treturn this._bindFunction(context, target)\n\t\t}\n\t\treturn target\n\t}\n\n\tprivate _bindFunction<T extends Function>(context: Context, target: T): T {\n\t\tconst manager = this\n\t\tconst contextWrapper = function (this: never, ...args: unknown[]) {\n\t\t\treturn manager.with(context, () => target.apply(this, args))\n\t\t}\n\t\tObject.defineProperty(contextWrapper, 'length', {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t\twritable: false,\n\t\t\tvalue: target.length,\n\t\t})\n\t\t/**\n\t\t * It isn't possible to tell Typescript that contextWrapper is the same as T\n\t\t * so we forced to cast as any here.\n\t\t */\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\treturn contextWrapper as any\n\t}\n\n\t/**\n\t * By default, EventEmitter call their callback with their context, which we do\n\t * not want, instead we will bind a specific context to all callbacks that\n\t * go through it.\n\t * @param context the context we want to bind\n\t * @param ee EventEmitter an instance of EventEmitter to patch\n\t */\n\tprivate _bindEventEmitter<T extends EventEmitter>(context: Context, ee: T): T {\n\t\tconst map = this._getPatchMap(ee)\n\t\tif (map !== undefined) return ee\n\t\tthis._createPatchMap(ee)\n\n\t\t// patch methods that add a listener to propagate context\n\t\tADD_LISTENER_METHODS.forEach((methodName) => {\n\t\t\tif (ee[methodName] === undefined) return\n\t\t\tee[methodName] = this._patchAddListener(ee, ee[methodName], context)\n\t\t})\n\t\t// patch methods that remove a listener\n\t\tif (typeof ee.removeListener === 'function') {\n\t\t\tee.removeListener = this._patchRemoveListener(ee, ee.removeListener)\n\t\t}\n\t\tif (typeof ee.off === 'function') {\n\t\t\tee.off = this._patchRemoveListener(ee, ee.off)\n\t\t}\n\t\t// patch method that remove all listeners\n\t\tif (typeof ee.removeAllListeners === 'function') {\n\t\t\tee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners)\n\t\t}\n\t\treturn ee\n\t}\n\n\t/**\n\t * Patch methods that remove a given listener so that we match the \"patched\"\n\t * version of that listener (the one that propagate context).\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t */\n\tprivate _patchRemoveListener(ee: EventEmitter, original: Function) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\tconst events = contextManager._getPatchMap(ee)?.[event]\n\t\t\tif (events === undefined) {\n\t\t\t\treturn original.call(this, event, listener)\n\t\t\t}\n\t\t\tconst patchedListener = events.get(listener)\n\t\t\treturn original.call(this, event, patchedListener || listener)\n\t\t}\n\t}\n\n\t/**\n\t * Patch methods that remove all listeners so we remove our\n\t * internal references for a given event.\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t */\n\tprivate _patchRemoveAllListeners(ee: EventEmitter, original: Function) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string) {\n\t\t\tconst map = contextManager._getPatchMap(ee)\n\t\t\tif (map !== undefined) {\n\t\t\t\tif (arguments.length === 0) {\n\t\t\t\t\tcontextManager._createPatchMap(ee)\n\t\t\t\t} else if (map[event] !== undefined) {\n\t\t\t\t\tdelete map[event]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn original.apply(this, arguments)\n\t\t}\n\t}\n\n\t/**\n\t * Patch methods on an event emitter instance that can add listeners so we\n\t * can force them to propagate a given context.\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t * @param [context] context to propagate when calling listeners\n\t */\n\tprivate _patchAddListener(ee: EventEmitter, original: Function, context: Context) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\t/**\n\t\t\t * This check is required to prevent double-wrapping the listener.\n\t\t\t * The implementation for ee.once wraps the listener and calls ee.on.\n\t\t\t * Without this check, we would wrap that wrapped listener.\n\t\t\t * This causes an issue because ee.removeListener depends on the onceWrapper\n\t\t\t * to properly remove the listener. If we wrap their wrapper, we break\n\t\t\t * that detection.\n\t\t\t */\n\t\t\tif (contextManager._wrapped) {\n\t\t\t\treturn original.call(this, event, listener)\n\t\t\t}\n\t\t\tlet map = contextManager._getPatchMap(ee)\n\t\t\tif (map === undefined) {\n\t\t\t\tmap = contextManager._createPatchMap(ee)\n\t\t\t}\n\t\t\tlet listeners = map[event]\n\t\t\tif (listeners === undefined) {\n\t\t\t\tlisteners = new WeakMap()\n\t\t\t\tmap[event] = listeners\n\t\t\t}\n\t\t\tconst patchedListener = contextManager.bind(context, listener)\n\t\t\t// store a weak reference of the user listener to ours\n\t\t\tlisteners.set(listener, patchedListener)\n\n\t\t\t/**\n\t\t\t * See comment at the start of this function for the explanation of this property.\n\t\t\t */\n\t\t\tcontextManager._wrapped = true\n\t\t\ttry {\n\t\t\t\treturn original.call(this, event, patchedListener)\n\t\t\t} finally {\n\t\t\t\tcontextManager._wrapped = false\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createPatchMap(ee: EventEmitter): PatchMap {\n\t\tconst map = Object.create(null)\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t;(ee as any)[this._kOtListeners] = map\n\t\treturn map\n\t}\n\tprivate _getPatchMap(ee: EventEmitter): PatchMap | undefined {\n\t\treturn (ee as never)[this._kOtListeners]\n\t}\n\n\tprivate readonly _kOtListeners = Symbol('OtListeners')\n\tprivate _wrapped = false\n}\n\nexport class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager {\n\tprivate _asyncLocalStorage: AsyncLocalStorage<Context>\n\n\tconstructor() {\n\t\tsuper()\n\t\tthis._asyncLocalStorage = new AsyncLocalStorage()\n\t}\n\n\tactive(): Context {\n\t\treturn this._asyncLocalStorage.getStore() ?? ROOT_CONTEXT\n\t}\n\n\twith<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\tcontext: Context,\n\t\tfn: F,\n\t\tthisArg?: ThisParameterType<F>,\n\t\t...args: A\n\t): ReturnType<F> {\n\t\tconst cb = thisArg == null ? fn : fn.bind(thisArg)\n\t\treturn this._asyncLocalStorage.run(context, cb as never, ...args)\n\t}\n\n\tenable(): this {\n\t\treturn this\n\t}\n\n\tdisable(): this {\n\t\tthis._asyncLocalStorage.disable()\n\t\treturn this\n\t}\n}\n","import {\n\tAttributes,\n\tTracer,\n\tTraceFlags,\n\tSpan,\n\tSpanKind,\n\tSpanOptions,\n\tContext,\n\tcontext as api_context,\n\ttrace,\n} from '@opentelemetry/api'\nimport { sanitizeAttributes } from '@opentelemetry/core'\nimport { Resource } from '@opentelemetry/resources'\nimport { SpanProcessor, RandomIdGenerator, ReadableSpan, SamplingDecision } from '@opentelemetry/sdk-trace-base'\n\nimport { SpanImpl } from './span.js'\nimport { getActiveConfig } from './config.js'\n\nlet withNextSpanAttributes: Attributes\n\nexport class WorkerTracer implements Tracer {\n\tprivate readonly _spanProcessors: SpanProcessor[]\n\tprivate readonly resource: Resource\n\tprivate readonly idGenerator: RandomIdGenerator = new RandomIdGenerator()\n\tconstructor(spanProcessors: SpanProcessor[], resource: Resource) {\n\t\tthis._spanProcessors = spanProcessors\n\t\tthis.resource = resource\n\t}\n\n\tget spanProcessors() {\n\t\treturn this._spanProcessors\n\t}\n\n\taddToResource(extra: Resource) {\n\t\tthis.resource.merge(extra)\n\t}\n\n\tstartSpan(name: string, options: SpanOptions = {}, context = api_context.active()): Span {\n\t\tif (options.root) {\n\t\t\tcontext = trace.deleteSpan(context)\n\t\t}\n\t\tconst parentSpan = trace.getSpan(context)\n\t\tconst parentSpanContext = parentSpan?.spanContext()\n\t\tconst hasParentContext = parentSpanContext && trace.isSpanContextValid(parentSpanContext)\n\n\t\tconst traceId = hasParentContext ? parentSpanContext.traceId : this.idGenerator.generateTraceId()\n\t\tconst spanKind = options.kind || SpanKind.INTERNAL\n\t\tconst sanitisedAttrs = sanitizeAttributes(options.attributes)\n\n\t\tconst config = getActiveConfig()\n\t\tif (!config) throw new Error('Config is undefined. This is a bug in the instrumentation logic')\n\n\t\tconst sampler = config.sampling.headSampler\n\t\tconst samplingDecision = sampler.shouldSample(context, traceId, name, spanKind, sanitisedAttrs, [])\n\t\tconst { decision, traceState, attributes: attrs } = samplingDecision\n\n\t\tconst attributes = Object.assign({}, sanitisedAttrs, attrs, withNextSpanAttributes)\n\t\twithNextSpanAttributes = {}\n\n\t\tconst spanId = this.idGenerator.generateSpanId()\n\t\tconst parentSpanId = hasParentContext ? parentSpanContext.spanId : undefined\n\t\tconst traceFlags = decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE\n\t\tconst spanContext = { traceId, spanId, traceFlags, traceState }\n\n\t\tconst span = new SpanImpl({\n\t\t\tattributes,\n\t\t\tname,\n\t\t\tonEnd: (span) => {\n\t\t\t\tthis.spanProcessors.forEach((sp) => {\n\t\t\t\t\tsp.onEnd(span as unknown as ReadableSpan)\n\t\t\t\t})\n\t\t\t},\n\t\t\tresource: this.resource,\n\t\t\tspanContext,\n\t\t\tparentSpanId,\n\t\t\tspanKind,\n\t\t\tstartTime: options.startTime,\n\t\t})\n\t\tthis.spanProcessors.forEach((sp) => {\n\t\t\t//Do not get me started on the idosyncracies of the Otel JS libraries.\n\t\t\t//@ts-ignore\n\t\t\tsp.onStart(span, context)\n\t\t})\n\t\treturn span\n\t}\n\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, fn: F): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, options: SpanOptions, fn: F): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(\n\t\tname: string,\n\t\toptions: SpanOptions,\n\t\tcontext: Context,\n\t\tfn: F,\n\t): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, ...args: unknown[]): ReturnType<F> {\n\t\tconst options = args.length > 1 ? (args[0] as SpanOptions) : undefined\n\t\tconst parentContext = args.length > 2 ? (args[1] as Context) : api_context.active()\n\t\tconst fn = args[args.length - 1] as F\n\n\t\tconst span = this.startSpan(name, options, parentContext)\n\t\tconst contextWithSpanSet = trace.setSpan(parentContext, span)\n\n\t\treturn api_context.with(contextWithSpanSet, fn, undefined, span)\n\t}\n}\n\nexport function withNextSpan(attrs: Attributes) {\n\twithNextSpanAttributes = Object.assign({}, withNextSpanAttributes, attrs)\n}\n","import {\n\tSpanContext,\n\tLink,\n\tSpanKind,\n\tTimeInput,\n\tException,\n\tAttributes,\n\tHrTime,\n\tSpan,\n\tSpanStatus,\n\tSpanStatusCode,\n\tAttributeValue,\n} from '@opentelemetry/api'\nimport {\n\thrTimeDuration,\n\tInstrumentationLibrary,\n\tisAttributeKey,\n\tisAttributeValue,\n\tisTimeInput,\n\tsanitizeAttributes,\n} from '@opentelemetry/core'\nimport { IResource } from '@opentelemetry/resources'\nimport { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\n\ntype OnSpanEnd = (span: Span) => void\n\ninterface SpanInit {\n\tattributes: unknown\n\tname: string\n\tonEnd: OnSpanEnd\n\tresource: IResource\n\tspanContext: SpanContext\n\tlinks?: Link[]\n\tparentSpanId?: string\n\tspanKind?: SpanKind\n\tstartTime?: TimeInput\n}\n\nfunction transformExceptionAttributes(exception: Exception): Attributes {\n\tconst attributes: Attributes = {}\n\tif (typeof exception === 'string') {\n\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception\n\t} else {\n\t\tif (exception.code) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString()\n\t\t} else if (exception.name) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name\n\t\t}\n\t\tif (exception.message) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message\n\t\t}\n\t\tif (exception.stack) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack\n\t\t}\n\t}\n\treturn attributes\n}\n\nfunction millisToHr(millis: number): HrTime {\n\treturn [Math.trunc(millis / 1000), (millis % 1000) * 1e6]\n}\n\nfunction getHrTime(input?: TimeInput): HrTime {\n\tconst now = Date.now()\n\tif (!input) {\n\t\treturn millisToHr(now)\n\t} else if (input instanceof Date) {\n\t\treturn millisToHr(input.getTime())\n\t} else if (typeof input === 'number') {\n\t\t//TODO: do something with performance.now something\n\t\treturn millisToHr(input)\n\t} else if (Array.isArray(input)) {\n\t\treturn input\n\t}\n\n\tconst v: never = input\n\tthrow new Error(`unreachable value: ${JSON.stringify(v)}`)\n}\n\nexport class SpanImpl implements Span, ReadableSpan {\n\tname: string\n\tprivate readonly _spanContext: SpanContext\n\tprivate readonly onEnd: OnSpanEnd\n\treadonly parentSpanId?: string\n\treadonly kind: SpanKind\n\treadonly attributes: Attributes\n\tstatus: SpanStatus = {\n\t\tcode: SpanStatusCode.UNSET,\n\t}\n\tendTime: HrTime = [0, 0]\n\tprivate _duration: HrTime = [0, 0]\n\treadonly startTime: HrTime\n\treadonly events: TimedEvent[] = []\n\treadonly links: Link[]\n\treadonly resource: IResource\n\tinstrumentationLibrary: InstrumentationLibrary = { name: '@microlabs/otel-cf-workers' }\n\tprivate _ended: boolean = false\n\tprivate _droppedAttributesCount: number = 0\n\tprivate _droppedEventsCount: number = 0\n\tprivate _droppedLinksCount: number = 0\n\n\tconstructor(init: SpanInit) {\n\t\tthis.name = init.name\n\t\tthis._spanContext = init.spanContext\n\t\tthis.parentSpanId = init.parentSpanId\n\t\tthis.kind = init.spanKind || SpanKind.INTERNAL\n\t\tthis.attributes = sanitizeAttributes(init.attributes)\n\t\tthis.startTime = getHrTime(init.startTime)\n\t\tthis.links = init.links || []\n\t\tthis.resource = init.resource\n\t\tthis.onEnd = init.onEnd\n\t}\n\n\taddLink(link: Link): this {\n\t\tthis.links.push(link)\n\t\treturn this\n\t}\n\taddLinks(links: Link[]): this {\n\t\tthis.links.push(...links)\n\t\treturn this\n\t}\n\n\tspanContext(): SpanContext {\n\t\treturn this._spanContext\n\t}\n\n\tsetAttribute(key: string, value?: AttributeValue): this {\n\t\tif (isAttributeKey(key) && isAttributeValue(value)) {\n\t\t\tthis.attributes[key] = value\n\t\t}\n\t\treturn this\n\t}\n\n\tsetAttributes(attributes: Attributes): this {\n\t\tfor (const [key, value] of Object.entries(attributes)) {\n\t\t\tthis.setAttribute(key, value)\n\t\t}\n\t\treturn this\n\t}\n\n\taddEvent(name: string, attributesOrStartTime?: Attributes | TimeInput, startTime?: TimeInput): this {\n\t\tif (isTimeInput(attributesOrStartTime)) {\n\t\t\tstartTime = attributesOrStartTime\n\t\t\tattributesOrStartTime = undefined\n\t\t}\n\n\t\tconst attributes = sanitizeAttributes(attributesOrStartTime)\n\t\tconst time = getHrTime(startTime)\n\t\tthis.events.push({ name, attributes, time })\n\t\treturn this\n\t}\n\n\tsetStatus(status: SpanStatus): this {\n\t\tthis.status = status\n\t\treturn this\n\t}\n\n\tupdateName(name: string): this {\n\t\tthis.name = name\n\t\treturn this\n\t}\n\n\tend(endTime?: TimeInput): void {\n\t\tif (this._ended) {\n\t\t\treturn\n\t\t}\n\t\tthis._ended = true\n\t\tthis.endTime = getHrTime(endTime)\n\t\tthis._duration = hrTimeDuration(this.startTime, this.endTime)\n\t\tthis.onEnd(this)\n\t}\n\n\tisRecording(): boolean {\n\t\treturn !this._ended\n\t}\n\n\trecordException(exception: Exception, time?: TimeInput): void {\n\t\tconst attributes = transformExceptionAttributes(exception)\n\t\tthis.addEvent('exception', attributes, time)\n\t}\n\n\tget duration(): HrTime {\n\t\treturn this._duration\n\t}\n\n\tget ended(): boolean {\n\t\treturn this._ended\n\t}\n\n\tget droppedAttributesCount(): number {\n\t\treturn this._droppedAttributesCount\n\t}\n\n\tget droppedEventsCount(): number {\n\t\treturn this._droppedEventsCount\n\t}\n\n\tget droppedLinksCount(): number {\n\t\treturn this._droppedLinksCount\n\t}\n}\n","import {\n\ttrace,\n\tSpanOptions,\n\tSpanKind,\n\tpropagation,\n\tcontext as api_context,\n\tAttributes,\n\tException,\n\tContext,\n\tSpanStatusCode,\n} from '@opentelemetry/api'\nimport { Initialiser, getActiveConfig, setConfig } from '../config.js'\nimport { wrap } from '../wrap.js'\nimport { instrumentEnv } from './env.js'\nimport { exportSpans, proxyExecutionContext } from './common.js'\nimport { ResolvedTraceConfig } from '../types.js'\nimport { ReadableSpan } from '@opentelemetry/sdk-trace-base'\nimport { versionAttributes } from './version.js'\n\nexport type IncludeTraceContextFn = (request: Request) => boolean\nexport interface FetcherConfig {\n\tincludeTraceContext?: boolean | IncludeTraceContextFn\n}\n\nexport type AcceptTraceContextFn = (request: Request) => boolean\nexport interface FetchHandlerConfig {\n\t/**\n\t * Whether to enable context propagation for incoming requests to `fetch`.\n\t * This enables or disables distributed tracing from W3C Trace Context headers.\n\t * @default true\n\t */\n\tacceptTraceContext?: boolean | AcceptTraceContextFn\n}\n\ntype FetchHandler = ExportedHandlerFetchHandler\ntype FetchHandlerArgs = Parameters<FetchHandler>\n\nconst netKeysFromCF = new Set(['colo', 'country', 'request_priority', 'tls_cipher', 'tls_version', 'asn', 'tcp_rtt'])\n\nconst camelToSnakeCase = (s: string): string => {\n\treturn s.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n}\n\nconst gatherOutgoingCfAttributes = (cf: RequestInitCfProperties): Attributes => {\n\tconst attrs: Record<string, string | number> = {}\n\tObject.keys(cf).forEach((key) => {\n\t\tconst value = cf[key]\n\t\tconst destKey = camelToSnakeCase(key)\n\t\tif (!netKeysFromCF.has(destKey)) {\n\t\t\tif (typeof value === 'string' || typeof value === 'number') {\n\t\t\t\tattrs[`cf.${destKey}`] = value\n\t\t\t} else {\n\t\t\t\tattrs[`cf.${destKey}`] = JSON.stringify(value)\n\t\t\t}\n\t\t}\n\t})\n\treturn attrs\n}\n\nexport function gatherRequestAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tconst headers = request.headers\n\tattrs['http.request.method'] = request.method.toUpperCase()\n\tattrs['network.protocol.name'] = 'http'\n\tattrs['network.protocol.version'] = request.cf?.httpProtocol as string\n\tattrs['http.request.body.size'] = headers.get('content-length')!\n\tattrs['user_agent.original'] = headers.get('user-agent')!\n\tattrs['http.mime_type'] = headers.get('content-type')!\n\tattrs['http.accepts'] = request.cf?.clientAcceptEncoding as string\n\n\tconst u = new URL(request.url)\n\tattrs['url.full'] = `${u.protocol}//${u.host}${u.pathname}${u.search}`\n\tattrs['server.address'] = u.host\n\tattrs['url.scheme'] = u.protocol\n\tattrs['url.path'] = u.pathname\n\tattrs['url.query'] = u.search\n\n\treturn attrs\n}\n\nexport function gatherResponseAttributes(response: Response): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tattrs['http.response.status_code'] = response.status\n\tif (response.headers.get('content-length')! == null) {\n\t\tattrs['http.response.body.size'] = response.headers.get('content-length')!\n\t}\n\tattrs['http.mime_type'] = response.headers.get('content-type')!\n\treturn attrs\n}\n\nexport function gatherIncomingCfAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tattrs['net.colo'] = request.cf?.colo as string\n\tattrs['net.country'] = request.cf?.country as string\n\tattrs['net.request_priority'] = request.cf?.requestPriority as string\n\tattrs['net.tls_cipher'] = request.cf?.tlsCipher as string\n\tattrs['net.tls_version'] = request.cf?.tlsVersion as string\n\tattrs['net.asn'] = request.cf?.asn as number\n\tattrs['net.tcp_rtt'] = request.cf?.clientTcpRtt as number\n\treturn attrs\n}\n\nexport function getParentContextFromHeaders(headers: Headers): Context {\n\treturn propagation.extract(api_context.active(), headers, {\n\t\tget(headers, key) {\n\t\t\treturn headers.get(key) || undefined\n\t\t},\n\t\tkeys(headers) {\n\t\t\treturn [...headers.keys()]\n\t\t},\n\t})\n}\n\nexport function getParentContextFromRequest(request: Request) {\n\tconst workerConfig = getActiveConfig()\n\n\tif (workerConfig === undefined) {\n\t\treturn api_context.active()\n\t}\n\n\tconst acceptTraceContext =\n\t\ttypeof workerConfig.handlers.fetch.acceptTraceContext === 'function'\n\t\t\t? workerConfig.handlers.fetch.acceptTraceContext(request)\n\t\t\t: (workerConfig.handlers.fetch.acceptTraceContext ?? true)\n\treturn acceptTraceContext ? getParentContextFromHeaders(request.headers) : api_context.active()\n}\n\nexport function waitUntilTrace(fn: () => Promise<any>): Promise<void> {\n\tconst tracer = trace.getTracer('waitUntil')\n\treturn tracer.startActiveSpan('waitUntil', async (span) => {\n\t\tawait fn()\n\t\tspan.end()\n\t})\n}\n\nlet cold_start = true\nexport function executeFetchHandler(fetchFn: FetchHandler, [request, env, ctx]: FetchHandlerArgs): Promise<Response> {\n\tconst spanContext = getParentContextFromRequest(request)\n\n\tconst tracer = trace.getTracer('fetchHandler')\n\tconst attributes = {\n\t\t['faas.trigger']: 'http',\n\t\t['faas.coldstart']: cold_start,\n\t\t['faas.invocation_id']: request.headers.get('cf-ray') ?? undefined,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\tObject.assign(attributes, versionAttributes(env))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst method = request.method.toUpperCase()\n\tconst promise = tracer.startActiveSpan(`fetchHandler ${method}`, options, spanContext, async (span) => {\n\t\tconst readable = span as unknown as ReadableSpan\n\t\ttry {\n\t\t\tconst response = await fetchFn(request, env, ctx)\n\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\n\t\t\treturn response\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tif (readable.attributes['http.route']) {\n\t\t\t\tspan.updateName(`fetchHandler ${method} ${readable.attributes['http.route']}`)\n\t\t\t}\n\t\t\tspan.end()\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function createFetchHandler(fetchFn: FetchHandler, initialiser: Initialiser) {\n\tconst fetchHandler: ProxyHandler<FetchHandler> = {\n\t\tapply: async (target, _thisArg, argArray: Parameters<FetchHandler>): Promise<Response> => {\n\t\t\tconst [request, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, request)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: FetchHandlerArgs = [request, env, ctx]\n\t\t\t\treturn await api_context.with(context, executeFetchHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetchFn, fetchHandler)\n}\n\ntype getFetchConfig = (config: ResolvedTraceConfig) => FetcherConfig\nexport function instrumentClientFetch(\n\tfetchFn: Fetcher['fetch'],\n\tconfigFn: getFetchConfig,\n\tattrs?: Attributes,\n): Fetcher['fetch'] {\n\tconst handler: ProxyHandler<Fetcher['fetch']> = {\n\t\tapply: (target, thisArg, argArray): Response | Promise<Response> => {\n\t\t\tconst request = new Request(argArray[0], argArray[1])\n\t\t\tif (!request.url.startsWith('http')) {\n\t\t\t\treturn Reflect.apply(target, thisArg, argArray)\n\t\t\t}\n\n\t\t\tconst workerConfig = getActiveConfig()\n\t\t\tif (!workerConfig) {\n\t\t\t\treturn Reflect.apply(target, thisArg, [request])\n\t\t\t}\n\t\t\tconst config = configFn(workerConfig)\n\n\t\t\tconst tracer = trace.getTracer('fetcher')\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes: attrs }\n\n\t\t\tconst host = new URL(request.url).host\n\t\t\tconst method = request.method.toUpperCase()\n\t\t\tconst spanName = typeof attrs?.['name'] === 'string' ? attrs?.['name'] : `fetch ${method} ${host}`\n\t\t\tconst promise = tracer.startActiveSpan(spanName, options, async (span) => {\n\t\t\t\tconst includeTraceContext =\n\t\t\t\t\ttypeof config.includeTraceContext === 'function'\n\t\t\t\t\t\t? config.includeTraceContext(request)\n\t\t\t\t\t\t: config.includeTraceContext\n\t\t\t\tif (includeTraceContext ?? true) {\n\t\t\t\t\tpropagation.inject(api_context.active(), request.headers, {\n\t\t\t\t\t\tset: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tspan.setAttributes(gatherRequestAttributes(request))\n\t\t\t\tif (request.cf) span.setAttributes(gatherOutgoingCfAttributes(request.cf))\n\t\t\t\tconst response = await Reflect.apply(target, thisArg, [request])\n\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\tspan.end()\n\t\t\t\treturn response\n\t\t\t})\n\t\t\treturn promise\n\t\t},\n\t}\n\treturn wrap(fetchFn, handler, true)\n}\n\nexport function instrumentGlobalFetch(): void {\n\t//@ts-ignore For some reason the node types are imported and complain.\n\tglobalThis.fetch = instrumentClientFetch(globalThis.fetch, (config) => config.fetch)\n}\n","import { context as api_context, trace, SpanOptions, SpanKind, Exception, SpanStatusCode } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { passthroughGet, unwrap, wrap } from '../wrap.js'\nimport {\n\tgetParentContextFromHeaders,\n\tgatherIncomingCfAttributes,\n\tgatherRequestAttributes,\n\tgatherResponseAttributes,\n\tinstrumentClientFetch,\n} from './fetch.js'\nimport { instrumentEnv } from './env.js'\nimport { Initialiser, setConfig } from '../config.js'\nimport { exportSpans } from './common.js'\nimport { instrumentStorage } from './do-storage.js'\nimport { DOConstructorTrigger } from '../types.js'\n\ntype FetchFn = DurableObject['fetch']\ntype AlarmFn = DurableObject['alarm']\ntype Env = Record<string, unknown>\n\nfunction instrumentBindingStub(stub: DurableObjectStub, nsName: string): DurableObjectStub {\n\tconst stubHandler: ProxyHandler<typeof stub> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetcher = Reflect.get(target, prop)\n\t\t\t\tconst attrs = {\n\t\t\t\t\tname: `Durable Object ${nsName}`,\n\t\t\t\t\t'do.namespace': nsName,\n\t\t\t\t\t'do.id': target.id.toString(),\n\t\t\t\t\t'do.id.name': target.id.name,\n\t\t\t\t}\n\t\t\t\treturn instrumentClientFetch(fetcher, () => ({ includeTraceContext: true }), attrs)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(stub, stubHandler)\n}\n\nfunction instrumentBindingGet(getFn: DurableObjectNamespace['get'], nsName: string): DurableObjectNamespace['get'] {\n\tconst getHandler: ProxyHandler<DurableObjectNamespace['get']> = {\n\t\tapply(target, thisArg, argArray) {\n\t\t\tconst stub: DurableObjectStub = Reflect.apply(target, thisArg, argArray)\n\t\t\treturn instrumentBindingStub(stub, nsName)\n\t\t},\n\t}\n\treturn wrap(getFn, getHandler)\n}\n\nexport function instrumentDOBinding(ns: DurableObjectNamespace, nsName: string) {\n\tconst nsHandler: ProxyHandler<typeof ns> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'get') {\n\t\t\t\tconst fn = Reflect.get(ns, prop)\n\t\t\t\treturn instrumentBindingGet(fn, nsName)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(ns, nsHandler)\n}\n\nexport function instrumentState(state: DurableObjectState) {\n\tconst stateHandler: ProxyHandler<DurableObjectState> = {\n\t\tget(target, prop, receiver) {\n\t\t\tconst result = Reflect.get(target, prop, unwrap(receiver))\n\t\t\tif (prop === 'storage') {\n\t\t\t\treturn instrumentStorage(result)\n\t\t\t} else if (typeof result === 'function') {\n\t\t\t\treturn result.bind(target)\n\t\t\t} else {\n\t\t\t\treturn result\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(state, stateHandler)\n}\n\nlet cold_start = true\nexport type DOClass = { new (state: DurableObjectState, env: any): DurableObject }\nexport function executeDOFetch(fetchFn: FetchFn, request: Request, id: DurableObjectId): Promise<Response> {\n\tconst spanContext = getParentContextFromHeaders(request.headers)\n\n\tconst tracer = trace.getTracer('DO fetchHandler')\n\tconst attributes = {\n\t\t[SemanticAttributes.FAAS_TRIGGER]: 'http',\n\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst name = id.name || ''\n\tconst promise = tracer.startActiveSpan(`Durable Object Fetch ${name}`, options, spanContext, async (span) => {\n\t\ttry {\n\t\t\tconst response: Response = await fetchFn(request)\n\t\t\tif (response.ok) {\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t}\n\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\tspan.end()\n\n\t\t\treturn response\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function executeDOAlarm(alarmFn: NonNullable<AlarmFn>, id: DurableObjectId): Promise<void> {\n\tconst tracer = trace.getTracer('DO alarmHandler')\n\n\tconst name = id.name || ''\n\tconst promise = tracer.startActiveSpan(`Durable Object Alarm ${name}`, async (span) => {\n\t\tspan.setAttribute(SemanticAttributes.FAAS_COLDSTART, cold_start)\n\t\tcold_start = false\n\t\tspan.setAttribute('do.id', id.toString())\n\t\tif (id.name) span.setAttribute('do.name', id.name)\n\n\t\ttry {\n\t\t\tawait alarmFn()\n\t\t\tspan.end()\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n\nfunction instrumentFetchFn(fetchFn: FetchFn, initialiser: Initialiser, env: Env, id: DurableObjectId): FetchFn {\n\tconst fetchHandler: ProxyHandler<FetchFn> = {\n\t\tasync apply(target, thisArg, argArray: Parameters<FetchFn>) {\n\t\t\tconst request = argArray[0]\n\t\t\tconst config = initialiser(env, request)\n\t\t\tconst context = setConfig(config)\n\t\t\ttry {\n\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\treturn await api_context.with(context, executeDOFetch, undefined, bound, request, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\texportSpans()\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetchFn, fetchHandler)\n}\n\nfunction instrumentAlarmFn(alarmFn: AlarmFn, initialiser: Initialiser, env: Env, id: DurableObjectId) {\n\tif (!alarmFn) return undefined\n\n\tconst alarmHandler: ProxyHandler<NonNullable<AlarmFn>> = {\n\t\tasync apply(target, thisArg) {\n\t\t\tconst config = initialiser(env, 'do-alarm')\n\t\t\tconst context = setConfig(config)\n\t\t\ttry {\n\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\treturn await api_context.with(context, executeDOAlarm, undefined, bound, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\texportSpans()\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(alarmFn, alarmHandler)\n}\n\nfunction instrumentDurableObject(doObj: DurableObject, initialiser: Initialiser, env: Env, state: DurableObjectState) {\n\tconst objHandler: ProxyHandler<DurableObject> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetchFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentFetchFn(fetchFn, initialiser, env, state.id)\n\t\t\t} else if (prop === 'alarm') {\n\t\t\t\tconst alarmFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentAlarmFn(alarmFn, initialiser, env, state.id)\n\t\t\t} else {\n\t\t\t\tconst result = Reflect.get(target, prop)\n\t\t\t\tif (typeof result === 'function') {\n\t\t\t\t\tresult.bind(doObj)\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(doObj, objHandler)\n}\n\nexport function instrumentDOClass(doClass: DOClass, initialiser: Initialiser): DOClass {\n\tconst classHandler: ProxyHandler<DOClass> = {\n\t\tconstruct(target, [orig_state, orig_env]: ConstructorParameters<DOClass>) {\n\t\t\tconst trigger: DOConstructorTrigger = {\n\t\t\t\tid: orig_state.id.toString(),\n\t\t\t\tname: orig_state.id.name,\n\t\t\t}\n\t\t\tconst constructorConfig = initialiser(orig_env, trigger)\n\t\t\tconst context = setConfig(constructorConfig)\n\t\t\tconst state = instrumentState(orig_state)\n\t\t\tconst env = instrumentEnv(orig_env)\n\t\t\tconst createDO = () => {\n\t\t\t\treturn new target(state, env)\n\t\t\t}\n\t\t\tconst doObj = api_context.with(context, createDO)\n\n\t\t\treturn instrumentDurableObject(doObj, initialiser, env, state)\n\t\t},\n\t}\n\treturn wrap(doClass, classHandler)\n}\n","import { trace } from '@opentelemetry/api'\nimport { WorkerTracer } from '../tracer.js'\nimport { passthroughGet, wrap } from '../wrap.js'\n\ntype ContextAndTracker = { ctx: ExecutionContext; tracker: PromiseTracker }\ntype WaitUntilFn = ExecutionContext['waitUntil']\n\nexport class PromiseTracker {\n\t_outstandingPromises: Promise<unknown>[] = []\n\n\tget outstandingPromiseCount() {\n\t\treturn this._outstandingPromises.length\n\t}\n\n\ttrack(promise: Promise<unknown>): void {\n\t\tthis._outstandingPromises.push(promise)\n\t}\n\n\tasync wait() {\n\t\tawait allSettledMutable(this._outstandingPromises)\n\t}\n}\n\nfunction createWaitUntil(fn: WaitUntilFn, context: ExecutionContext, tracker: PromiseTracker): WaitUntilFn {\n\tconst handler: ProxyHandler<WaitUntilFn> = {\n\t\tapply(target, _thisArg, argArray) {\n\t\t\ttracker.track(argArray[0])\n\t\t\treturn Reflect.apply(target, context, argArray)\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nexport function proxyExecutionContext(context: ExecutionContext): ContextAndTracker {\n\tconst tracker = new PromiseTracker()\n\tconst ctx = new Proxy(context, {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'waitUntil') {\n\t\t\t\tconst fn = Reflect.get(target, prop)\n\t\t\t\treturn createWaitUntil(fn, context, tracker)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t})\n\treturn { ctx, tracker }\n}\n\nexport async function exportSpans(tracker?: PromiseTracker) {\n\tconst tracer = trace.getTracer('export')\n\tif (tracer instanceof WorkerTracer) {\n\t\tawait scheduler.wait(1)\n\t\tif (tracker) {\n\t\t\tawait tracker.wait()\n\t\t}\n\t\tconst promises = tracer.spanProcessors.map(async (spanProcessor) => {\n\t\t\tawait spanProcessor.forceFlush()\n\t\t})\n\t\tawait Promise.allSettled(promises)\n\t} else {\n\t\tconsole.error('The global tracer is not of type WorkerTracer and can not export spans')\n\t}\n}\n\n/** Like `Promise.allSettled`, but handles modifications to the promises array */\nasync function allSettledMutable(promises: Promise<unknown>[]): Promise<PromiseSettledResult<unknown>[]> {\n\tlet values: PromiseSettledResult<unknown>[]\n\t// when the length of the array changes, there has been a nested call to waitUntil\n\t// and we should await the promises again\n\tdo {\n\t\tvalues = await Promise.allSettled(promises)\n\t} while (values.length !== promises.length)\n\treturn values\n}\n\n/** Overloads extracts up to 4 overloads for the given function. */\nexport type Overloads<T> = T extends {\n\t(...args: infer P1): infer R1\n\t(...args: infer P2): infer R2\n\t(...args: infer P3): infer R3\n\t(...args: infer P4): infer R4\n}\n\t? ((...args: P1) => R1) | ((...args: P2) => R2) | ((...args: P3) => R3) | ((...args: P4) => R4)\n\t: never\n","import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\nimport { Overloads } from './common.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst dbSystem = 'Cloudflare DO'\n\ntype DurableObjectCommonOptions = Pick<DurableObjectPutOptions, 'allowConcurrency' | 'allowUnconfirmed' | 'noCache'>\nfunction isDurableObjectCommonOptions(options: any): options is DurableObjectCommonOptions {\n\treturn (\n\t\ttypeof options === 'object' &&\n\t\t('allowConcurrency' in options || 'allowUnconfirmed' in options || 'noCache' in options)\n\t)\n}\n\n/** Applies attributes for common Durable Objects options:\n * `allowConcurrency`, `allowUnconfirmed`, and `noCache`\n */\nfunction applyOptionsAttributes(attrs: Attributes, options: DurableObjectCommonOptions) {\n\tif ('allowConcurrency' in options) {\n\t\tattrs['db.cf.do.allow_concurrency'] = options.allowConcurrency\n\t}\n\tif ('allowUnconfirmed' in options) {\n\t\tattrs['db.cf.do.allow_unconfirmed'] = options.allowUnconfirmed\n\t}\n\tif ('noCache' in options) {\n\t\tattrs['db.cf.do.no_cache'] = options.noCache\n\t}\n}\n\nconst StorageAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\tdelete(argArray, result: Awaited<ReturnType<Overloads<DurableObjectStorage['delete']>>>) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['delete']>>\n\t\tlet attrs: Attributes = {}\n\t\tif (Array.isArray(args[0])) {\n\t\t\tconst keys = args[0]\n\t\t\tattrs = {\n\t\t\t\t// todo: Maybe set db.cf.do.keys to the whole array here?\n\t\t\t\t'db.cf.do.key': keys[0],\n\t\t\t\t'db.cf.do.number_of_keys': keys.length,\n\t\t\t\t'db.cf.do.keys_deleted': result,\n\t\t\t}\n\t\t} else {\n\t\t\tattrs = {\n\t\t\t\t'db.cf.do.key': args[0],\n\t\t\t\t'db.cf.do.success': result,\n\t\t\t}\n\t\t}\n\t\tif (args[1]) {\n\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tdeleteAll(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['deleteAll']>>\n\t\tlet attrs: Attributes = {}\n\t\tif (args[0]) {\n\t\t\tapplyOptionsAttributes(attrs, args[0])\n\t\t}\n\t\treturn attrs\n\t},\n\tget(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['get']>>\n\t\tlet attrs: Attributes = {}\n\t\tif (Array.isArray(args[0])) {\n\t\t\tconst keys = args[0]\n\t\t\tattrs = {\n\t\t\t\t// todo: Maybe set db.cf.do.keys to the whole array here?\n\t\t\t\t'db.cf.do.key': keys[0],\n\t\t\t\t'db.cf.do.number_of_keys': keys.length,\n\t\t\t}\n\t\t} else {\n\t\t\tattrs = {\n\t\t\t\t'db.cf.do.key': args[0],\n\t\t\t}\n\t\t}\n\t\tif (args[1]) {\n\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tlist(argArray, result: Awaited<ReturnType<Overloads<DurableObjectStorage['list']>>>) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['list']>>\n\t\tconst attrs: Attributes = {\n\t\t\t'db.cf.do.number_of_results': result.size,\n\t\t}\n\t\tif (args[0]) {\n\t\t\tconst options = args[0]\n\t\t\tapplyOptionsAttributes(attrs, options)\n\t\t\tif ('start' in options) {\n\t\t\t\tattrs['db.cf.do.start'] = options.start\n\t\t\t}\n\t\t\tif ('startAfter' in options) {\n\t\t\t\tattrs['db.cf.do.start_after'] = options.startAfter\n\t\t\t}\n\t\t\tif ('end' in options) {\n\t\t\t\tattrs['db.cf.do.end'] = options.end\n\t\t\t}\n\t\t\tif ('prefix' in options) {\n\t\t\t\tattrs['db.cf.do.prefix'] = options.prefix\n\t\t\t}\n\t\t\tif ('reverse' in options) {\n\t\t\t\tattrs['db.cf.do.reverse'] = options.reverse\n\t\t\t}\n\t\t\tif ('limit' in options) {\n\t\t\t\tattrs['db.cf.do.limit'] = options.limit\n\t\t\t}\n\t\t}\n\t\treturn attrs\n\t},\n\tput(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['put']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (typeof args[0] === 'string') {\n\t\t\tattrs['db.cf.do.key'] = args[0]\n\t\t\tif (args[2]) {\n\t\t\t\tapplyOptionsAttributes(attrs, args[2])\n\t\t\t}\n\t\t} else {\n\t\t\tconst keys = Object.keys(args[0])\n\t\t\t// todo: Maybe set db.cf.do.keys to the whole array here?\n\t\t\tattrs['db.cf.do.key'] = keys[0]\n\t\t\tattrs['db.cf.do.number_of_keys'] = keys.length\n\t\t\tif (isDurableObjectCommonOptions(args[1])) {\n\t\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t\t}\n\t\t}\n\t\treturn attrs\n\t},\n\tgetAlarm(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['getAlarm']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (args[0]) {\n\t\t\tapplyOptionsAttributes(attrs, args[0])\n\t\t}\n\t\treturn attrs\n\t},\n\tsetAlarm(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['setAlarm']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (args[0] instanceof Date) {\n\t\t\tattrs['db.cf.do.alarm_time'] = args[0].getTime()\n\t\t} else {\n\t\t\tattrs['db.cf.do.alarm_time'] = args[0]\n\t\t}\n\t\tif (args[1]) {\n\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tdeleteAlarm(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['deleteAlarm']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (args[0]) {\n\t\t\tapplyOptionsAttributes(attrs, args[0])\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentStorageFn(fn: Function, operation: string) {\n\tconst tracer = trace.getTracer('do_storage')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst attributes = {\n\t\t\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t\t\t\t[SemanticAttributes.DB_STATEMENT]: `${operation} ${argArray[0]}`,\n\t\t\t}\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes: {\n\t\t\t\t\t...attributes,\n\t\t\t\t\toperation,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`Durable Object Storage ${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrsFn = StorageAttributes[operation]\n\t\t\t\tconst extraAttrs = extraAttrsFn ? extraAttrsFn(argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tspan.setAttribute('db.cf.do.has_result', !!result)\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentStorage(storage: DurableObjectStorage): DurableObjectStorage {\n\tconst storageHandler: ProxyHandler<DurableObjectStorage> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentStorageFn(fn, operation)\n\t\t},\n\t}\n\treturn wrap(storage, storageHandler)\n}\n","import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst dbSystem = 'Cloudflare KV'\n\nconst KVAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\tdelete(_argArray) {\n\t\treturn {}\n\t},\n\tget(argArray) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts = argArray[1]\n\t\tif (typeof opts === 'string') {\n\t\t\tattrs['db.cf.kv.type'] = opts\n\t\t} else if (typeof opts === 'object') {\n\t\t\tattrs['db.cf.kv.type'] = opts.type\n\t\t\tattrs['db.cf.kv.cache_ttl'] = opts.cacheTtl\n\t\t}\n\t\treturn attrs\n\t},\n\tgetWithMetadata(argArray, result) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts = argArray[1]\n\t\tif (typeof opts === 'string') {\n\t\t\tattrs['db.cf.kv.type'] = opts\n\t\t} else if (typeof opts === 'object') {\n\t\t\tattrs['db.cf.kv.type'] = opts.type\n\t\t\tattrs['db.cf.kv.cache_ttl'] = opts.cacheTtl\n\t\t}\n\n\t\tattrs['db.cf.kv.metadata'] = true\n\t\tconst { cacheStatus } = result as KVNamespaceGetWithMetadataResult<any, any>\n\t\tif (typeof cacheStatus === 'string') {\n\t\t\tattrs['db.cf.kv.cache_status'] = cacheStatus\n\t\t}\n\t\treturn attrs\n\t},\n\tlist(argArray, result) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts: KVNamespaceListOptions = argArray[0] || {}\n\t\tconst { cursor, limit } = opts\n\t\tattrs['db.cf.kv.list_request_cursor'] = cursor || undefined\n\t\tattrs['db.cf.kv.list_limit'] = limit || undefined\n\t\tconst { list_complete, cacheStatus } = result as KVNamespaceListResult<any, any>\n\t\tattrs['db.cf.kv.list_complete'] = list_complete || undefined\n\t\tif (!list_complete) {\n\t\t\tattrs['db.cf.kv.list_response_cursor'] = cursor || undefined\n\t\t}\n\t\tif (typeof cacheStatus === 'string') {\n\t\t\tattrs['db.cf.kv.cache_status'] = cacheStatus\n\t\t}\n\t\treturn attrs\n\t},\n\tput(argArray) {\n\t\tconst attrs: Attributes = {}\n\t\tif (argArray.length > 2 && argArray[2]) {\n\t\t\tconst { expiration, expirationTtl, metadata } = argArray[2] as KVNamespacePutOptions\n\t\t\tattrs['db.cf.kv.expiration'] = expiration\n\t\t\tattrs['db.cf.kv.expiration_ttl'] = expirationTtl\n\t\t\tattrs['db.cf.kv.metadata'] = !!metadata\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentKVFn(fn: Function, name: string, operation: string) {\n\tconst tracer = trace.getTracer('KV')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst attributes = {\n\t\t\t\tbinding_type: 'KV',\n\t\t\t\t[SemanticAttributes.DB_NAME]: name,\n\t\t\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t\t\t}\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes,\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`KV ${name} ${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrsFn = KVAttributes[operation]\n\t\t\t\tconst extraAttrs = extraAttrsFn ? extraAttrsFn(argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tif (operation === 'list') {\n\t\t\t\t\tconst opts: KVNamespaceListOptions = argArray[0] || {}\n\t\t\t\t\tconst { prefix } = opts\n\t\t\t\t\tspan.setAttribute(SemanticAttributes.DB_STATEMENT, `${operation} ${prefix || undefined}`)\n\t\t\t\t} else {\n\t\t\t\t\tspan.setAttribute(SemanticAttributes.DB_STATEMENT, `${operation} ${argArray[0]}`)\n\t\t\t\t\tspan.setAttribute('db.cf.kv.key', argArray[0])\n\t\t\t\t}\n\t\t\t\tif (operation === 'getWithMetadata') {\n\t\t\t\t\tconst hasResults = !!result && !!(result as KVNamespaceGetWithMetadataResult<string, unknown>).value\n\t\t\t\t\tspan.setAttribute('db.cf.kv.has_result', hasResults)\n\t\t\t\t} else {\n\t\t\t\t\tspan.setAttribute('db.cf.kv.has_result', !!result)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentKV(kv: KVNamespace, name: string): KVNamespace {\n\tconst kvHandler: ProxyHandler<KVNamespace> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentKVFn(fn, name, operation)\n\t\t},\n\t}\n\treturn wrap(kv, kvHandler)\n}\n","import { trace, SpanOptions, SpanKind, Attributes, Exception, context as api_context } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { Initialiser, setConfig } from '../config.js'\nimport { exportSpans, proxyExecutionContext } from './common.js'\nimport { instrumentEnv } from './env.js'\nimport { unwrap, wrap } from '../wrap.js'\nimport { versionAttributes } from './version.js'\n\ntype QueueHandler = ExportedHandlerQueueHandler<unknown, unknown>\nexport type QueueHandlerArgs = Parameters<QueueHandler>\n\nconst traceIdSymbol = Symbol('traceId')\n\nclass MessageStatusCount {\n\tsucceeded = 0\n\tfailed = 0\n\treadonly total: number\n\tconstructor(total: number) {\n\t\tthis.total = total\n\t}\n\n\tack() {\n\t\tthis.succeeded = this.succeeded + 1\n\t}\n\n\tackRemaining() {\n\t\tthis.succeeded = this.total - this.failed\n\t}\n\n\tretry() {\n\t\tthis.failed = this.failed + 1\n\t}\n\n\tretryRemaining() {\n\t\tthis.failed = this.total - this.succeeded\n\t}\n\n\ttoAttributes(): Attributes {\n\t\treturn {\n\t\t\t'queue.messages_count': this.total,\n\t\t\t'queue.messages_success': this.succeeded,\n\t\t\t'queue.messages_failed': this.failed,\n\t\t\t'queue.batch_success': this.succeeded === this.total,\n\t\t}\n\t}\n}\n\nconst addEvent = (name: string, msg?: Message) => {\n\tconst attrs: Attributes = {}\n\tif (msg) {\n\t\tattrs['queue.message_id'] = msg.id\n\t\tattrs['queue.message_timestamp'] = msg.timestamp.toISOString()\n\t}\n\ttrace.getActiveSpan()?.addEvent(name, attrs)\n}\n\nconst proxyQueueMessage = <Q>(msg: Message<Q>, count: MessageStatusCount): Message<Q> => {\n\tconst msgHandler: ProxyHandler<Message<Q>> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'ack') {\n\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('messageAck', msg)\n\t\t\t\t\t\tcount.ack()\n\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, msg, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else if (prop === 'retry') {\n\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('messageRetry', msg)\n\t\t\t\t\t\tcount.retry()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tconst result = Reflect.apply(fnTarget, msg, [])\n\t\t\t\t\t\treturn result\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop, msg)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(msg, msgHandler)\n}\n\nconst proxyMessageBatch = (batch: MessageBatch, count: MessageStatusCount) => {\n\tconst batchHandler: ProxyHandler<MessageBatch> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'messages') {\n\t\t\t\tconst messages = Reflect.get(target, prop)\n\t\t\t\tconst messagesHandler: ProxyHandler<MessageBatch['messages']> = {\n\t\t\t\t\tget: (target, prop) => {\n\t\t\t\t\t\tif (typeof prop === 'string' && !isNaN(parseInt(prop))) {\n\t\t\t\t\t\t\tconst message = Reflect.get(target, prop)\n\t\t\t\t\t\t\treturn proxyQueueMessage(message, count)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn wrap(messages, messagesHandler)\n\t\t\t} else if (prop === 'ackAll') {\n\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('ackAll')\n\t\t\t\t\t\tcount.ackRemaining()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else if (prop === 'retryAll') {\n\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('retryAll')\n\t\t\t\t\t\tcount.retryRemaining()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop)\n\t\t},\n\t}\n\treturn wrap(batch, batchHandler)\n}\n\nexport function executeQueueHandler(queueFn: QueueHandler, [batch, env, ctx]: QueueHandlerArgs): Promise<void> {\n\tconst count = new MessageStatusCount(batch.messages.length)\n\tbatch = proxyMessageBatch(batch, count)\n\tconst tracer = trace.getTracer('queueHandler')\n\tconst options: SpanOptions = {\n\t\tattributes: {\n\t\t\t[SemanticAttributes.FAAS_TRIGGER]: 'pubsub',\n\t\t\t'queue.name': batch.queue,\n\t\t},\n\t\tkind: SpanKind.CONSUMER,\n\t}\n\tObject.assign(options.attributes!, versionAttributes(env))\n\tconst promise = tracer.startActiveSpan(`queueHandler ${batch.queue}`, options, async (span) => {\n\t\tconst traceId = span.spanContext().traceId\n\t\tapi_context.active().setValue(traceIdSymbol, traceId)\n\t\ttry {\n\t\t\tconst result = await queueFn(batch, env, ctx)\n\t\t\tspan.setAttribute('queue.implicitly_acked', count.total - count.succeeded - count.failed)\n\t\t\tcount.ackRemaining()\n\t\t\tspan.setAttributes(count.toAttributes())\n\t\t\tspan.end()\n\t\t\treturn result\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setAttribute('queue.implicitly_retried', count.total - count.succeeded - count.failed)\n\t\t\tcount.retryRemaining()\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function createQueueHandler(queueFn: QueueHandler, initialiser: Initialiser) {\n\tconst queueHandler: ProxyHandler<QueueHandler> = {\n\t\tasync apply(target, _thisArg, argArray: Parameters<QueueHandler>): Promise<void> {\n\t\t\tconst [batch, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, batch)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: QueueHandlerArgs = [batch, env, ctx]\n\n\t\t\t\treturn await api_context.with(context, executeQueueHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(queueFn, queueHandler)\n}\n\nfunction instrumentQueueSend(fn: Queue<unknown>['send'], name: string): Queue<unknown>['send'] {\n\tconst tracer = trace.getTracer('queueSender')\n\tconst handler: ProxyHandler<Queue<unknown>['send']> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\treturn tracer.startActiveSpan(`Queues ${name} send`, async (span) => {\n\t\t\t\tspan.setAttribute('queue.operation', 'send')\n\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\tspan.end()\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nfunction instrumentQueueSendBatch(fn: Queue<unknown>['sendBatch'], name: string): Queue<unknown>['sendBatch'] {\n\tconst tracer = trace.getTracer('queueSender')\n\tconst handler: ProxyHandler<Queue<unknown>['sendBatch']> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\treturn tracer.startActiveSpan(`Queues ${name} sendBatch`, async (span) => {\n\t\t\t\tspan.setAttribute('queue.operation', 'sendBatch')\n\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\tspan.end()\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nexport function instrumentQueueSender(queue: Queue<unknown>, name: string) {\n\tconst queueHandler: ProxyHandler<Queue<unknown>> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'send') {\n\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentQueueSend(sendFn, name)\n\t\t\t} else if (prop === 'sendBatch') {\n\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentQueueSendBatch(sendFn, name)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(queue, queueHandler)\n}\n","import { isVersionMetadata } from './env.js'\n\nexport function versionAttributes(env: unknown): Record<string, string | undefined> {\n\tconst attributes = {} as Record<string, string | undefined>\n\n\tif (typeof env === 'object' && env !== null) {\n\t\tfor (const [binding, data] of Object.entries(env)) {\n\t\t\tif (isVersionMetadata(data)) {\n\t\t\t\tattributes['cf.workers_version_metadata.binding'] = binding\n\t\t\t\tattributes['cf.workers_version_metadata.id'] = data.id\n\t\t\t\tattributes['cf.workers_version_metadata.tag'] = data.tag\n\t\t\t\t// Version metadata bindings are identical, so we can stop after the first one found\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn attributes\n}\n","import { passthroughGet, wrap } from '../wrap.js'\nimport { instrumentClientFetch } from './fetch.js'\n\nexport function instrumentServiceBinding(fetcher: Fetcher, envName: string): Fetcher {\n\tconst fetcherHandler: ProxyHandler<Fetcher> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetcher = Reflect.get(target, prop)\n\t\t\t\tconst attrs = {\n\t\t\t\t\tname: `Service Binding ${envName}`,\n\t\t\t\t}\n\t\t\t\treturn instrumentClientFetch(fetcher, () => ({ includeTraceContext: true }), attrs)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetcher, fetcherHandler)\n}\n","import { Attributes, SpanKind, SpanOptions, SpanStatusCode, Exception, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\n\nconst dbSystem = 'Cloudflare D1'\n\n// We need to peak into D1 \"internals\" to instrument batch queries\n// See: https://github.com/cloudflare/workerd/blob/5d27f8f7f1f9b584f673d2f11c9032f5a776ec55/src/cloudflare/internal/d1-api.ts#L173\ninterface D1StatementInternals {\n\tstatement: string\n\tparams: unknown[]\n}\n\nfunction metaAttributes(meta: D1Meta): Attributes {\n\treturn {\n\t\t'db.cf.d1.rows_read': meta.rows_read,\n\t\t'db.cf.d1.rows_written': meta.rows_written,\n\t\t'db.cf.d1.duration': meta.duration,\n\t\t'db.cf.d1.size_after': meta.size_after,\n\t\t'db.cf.d1.last_row_id': meta.last_row_id,\n\t\t'db.cf.d1.changed_db': meta.changed_db,\n\t\t'db.cf.d1.changes': meta.changes,\n\t}\n}\nfunction spanOptions(dbName: string, operation: string, sql?: string): SpanOptions {\n\tconst attributes: Attributes = {\n\t\tbinding_type: 'D1',\n\t\t[SemanticAttributes.DB_NAME]: dbName,\n\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t}\n\tif (sql) {\n\t\tattributes[SemanticAttributes.DB_STATEMENT] = sql\n\t}\n\treturn {\n\t\tkind: SpanKind.CLIENT,\n\t\tattributes,\n\t}\n}\n\nfunction instrumentD1StatementFn(fn: Function, dbName: string, operation: string, sql: string) {\n\tconst tracer = trace.getTracer('D1')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tif (operation === 'bind') {\n\t\t\t\tconst newStmt = Reflect.apply(target, thisArg, argArray) as D1PreparedStatement\n\t\t\t\treturn instrumentD1PreparedStatement(newStmt, dbName, sql)\n\t\t\t}\n\n\t\t\tconst options = spanOptions(dbName, operation, sql)\n\t\t\treturn tracer.startActiveSpan(`${dbName} ${operation}`, options, async (span) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\t\tif (operation === 'all' || operation === 'run') {\n\t\t\t\t\t\tspan.setAttributes(metaAttributes((result as D1Result).meta))\n\t\t\t\t\t}\n\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t\treturn result\n\t\t\t\t} catch (error) {\n\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\tthrow error\n\t\t\t\t} finally {\n\t\t\t\t\tspan.end()\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nfunction instrumentD1PreparedStatement(\n\tstmt: D1PreparedStatement,\n\tdbName: string,\n\tstatement: string,\n): D1PreparedStatement {\n\tconst statementHandler: ProxyHandler<D1PreparedStatement> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\tif (typeof fn === 'function') {\n\t\t\t\treturn instrumentD1StatementFn(fn, dbName, operation, statement)\n\t\t\t}\n\t\t\treturn fn\n\t\t},\n\t}\n\treturn wrap(stmt, statementHandler)\n}\n\nexport function instrumentD1Fn(fn: Function, dbName: string, operation: string) {\n\tconst tracer = trace.getTracer('D1')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tif (operation === 'prepare') {\n\t\t\t\tconst sql = argArray[0] as string\n\t\t\t\tconst stmt = Reflect.apply(target, thisArg, argArray) as D1PreparedStatement\n\t\t\t\treturn instrumentD1PreparedStatement(stmt, dbName, sql)\n\t\t\t} else if (operation === 'exec') {\n\t\t\t\tconst sql = argArray[0] as string\n\t\t\t\tconst options = spanOptions(dbName, operation, sql)\n\t\t\t\treturn tracer.startActiveSpan(`${dbName} ${operation}`, options, async (span) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t\t\treturn result\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tspan.end()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else if (operation === 'batch') {\n\t\t\t\t// Create span for each statement, requires peeaking into D1 internals ...\n\t\t\t\tconst statements = argArray[0] as D1StatementInternals[]\n\t\t\t\treturn tracer.startActiveSpan(`${dbName} ${operation}`, async (span) => {\n\t\t\t\t\t// Create a span per query in the batch\n\t\t\t\t\tconst subSpans = statements.map((s) =>\n\t\t\t\t\t\ttracer.startSpan(`${dbName} ${operation} > query`, spanOptions(dbName, operation, s.statement)),\n\t\t\t\t\t)\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = (await Reflect.apply(target, thisArg, argArray)) as D1Result[]\n\t\t\t\t\t\tresult.forEach((r, i) => subSpans[i]?.setAttributes(metaAttributes(r.meta)))\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t\t\treturn result\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubSpans.forEach((s) => s.end())\n\t\t\t\t\t\tspan.end()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn Reflect.apply(target, thisArg, argArray)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentD1(database: D1Database, dbName: string): D1Database {\n\tconst dbHandler: ProxyHandler<D1Database> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\tif (typeof fn === 'function') {\n\t\t\t\treturn instrumentD1Fn(fn, dbName, operation)\n\t\t\t}\n\t\t\treturn fn\n\t\t},\n\t}\n\treturn wrap(database, dbHandler)\n}\n","import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst dbSystem = 'Cloudflare Analytics Engine'\n\nconst AEAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\twriteDataPoint(argArray) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts = argArray[0]\n\t\tif (typeof opts === 'object') {\n\t\t\tattrs['db.cf.ae.indexes'] = opts.indexes.length\n\t\t\tattrs['db.cf.ae.index'] = (opts.indexes[0] as ArrayBuffer | string).toString()\n\t\t\tattrs['db.cf.ae.doubles'] = opts.doubles.length\n\t\t\tattrs['db.cf.ae.blobs'] = opts.blobs.length\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentAEFn(fn: Function, name: string, operation: string) {\n\tconst tracer = trace.getTracer('AnalyticsEngine')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst attributes = {\n\t\t\t\tbinding_type: 'AnalyticsEngine',\n\t\t\t\t[SemanticAttributes.DB_NAME]: name,\n\t\t\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t\t\t}\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes,\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`Analytics Engine ${name} ${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrsFn = AEAttributes[operation]\n\t\t\t\tconst extraAttrs = extraAttrsFn ? extraAttrsFn(argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tspan.setAttribute(SemanticAttributes.DB_STATEMENT, `${operation} ${argArray[0]}`)\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentAnalyticsEngineDataset(\n\tdataset: AnalyticsEngineDataset,\n\tname: string,\n): AnalyticsEngineDataset {\n\tconst datasetHandler: ProxyHandler<AnalyticsEngineDataset> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentAEFn(fn, name, operation)\n\t\t},\n\t}\n\treturn wrap(dataset, datasetHandler)\n}\n","import { isProxyable, wrap } from '../wrap.js'\nimport { instrumentDOBinding } from './do.js'\nimport { instrumentKV } from './kv.js'\nimport { instrumentQueueSender } from './queue.js'\nimport { instrumentServiceBinding } from './service.js'\nimport { instrumentD1 } from './d1'\nimport { instrumentAnalyticsEngineDataset } from './analytics-engine.js'\n\nconst isJSRPC = (item?: unknown): item is Service => {\n\t// @ts-expect-error The point of RPC types is to block non-existent properties, but that's the goal here\n\treturn !!(item as Service)?.['__some_property_that_will_never_exist' + Math.random()]\n}\n\nconst isKVNamespace = (item?: unknown): item is KVNamespace => {\n\treturn !isJSRPC(item) && !!(item as KVNamespace)?.getWithMetadata\n}\n\nconst isQueue = (item?: unknown): item is Queue<unknown> => {\n\treturn !isJSRPC(item) && !!(item as Queue<unknown>)?.sendBatch\n}\n\nconst isDurableObject = (item?: unknown): item is DurableObjectNamespace => {\n\treturn !isJSRPC(item) && !!(item as DurableObjectNamespace)?.idFromName\n}\n\nexport const isVersionMetadata = (item?: unknown): item is WorkerVersionMetadata => {\n\treturn (\n\t\t!isJSRPC(item) &&\n\t\ttypeof (item as WorkerVersionMetadata)?.id === 'string' &&\n\t\ttypeof (item as WorkerVersionMetadata)?.tag === 'string'\n\t)\n}\n\nconst isAnalyticsEngineDataset = (item?: unknown): item is AnalyticsEngineDataset => {\n\treturn !isJSRPC(item) && !!(item as AnalyticsEngineDataset)?.writeDataPoint\n}\n\nconst isD1Database = (item?: unknown): item is D1Database => {\n\treturn !!(item as D1Database)?.exec && !!(item as D1Database)?.prepare\n}\n\nconst instrumentEnv = (env: Record<string, unknown>): Record<string, unknown> => {\n\tconst envHandler: ProxyHandler<Record<string, unknown>> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst item = Reflect.get(target, prop, receiver)\n\t\t\tif (!isProxyable(item)) {\n\t\t\t\treturn item\n\t\t\t}\n\t\t\tif (isJSRPC(item)) {\n\t\t\t\treturn instrumentServiceBinding(item, String(prop))\n\t\t\t} else if (isKVNamespace(item)) {\n\t\t\t\treturn instrumentKV(item, String(prop))\n\t\t\t} else if (isQueue(item)) {\n\t\t\t\treturn instrumentQueueSender(item, String(prop))\n\t\t\t} else if (isDurableObject(item)) {\n\t\t\t\treturn instrumentDOBinding(item, String(prop))\n\t\t\t} else if (isVersionMetadata(item)) {\n\t\t\t\t// we do not need to log accesses to the metadata\n\t\t\t\treturn item\n\t\t\t} else if (isAnalyticsEngineDataset(item)) {\n\t\t\t\treturn instrumentAnalyticsEngineDataset(item, String(prop))\n\t\t\t} else if (isD1Database(item)) {\n\t\t\t\treturn instrumentD1(item, String(prop))\n\t\t\t} else {\n\t\t\t\treturn item\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(env, envHandler)\n}\n\nexport { instrumentEnv }\n","import { SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { wrap } from '../wrap.js'\n\ntype CacheFns = Cache[keyof Cache]\n\nconst tracer = trace.getTracer('cache instrumentation')\n\nfunction sanitiseURL(url: string): string {\n\tconst u = new URL(url)\n\treturn `${u.protocol}//${u.host}${u.pathname}${u.search}`\n}\n\nfunction instrumentFunction<T extends CacheFns>(fn: T, cacheName: string, op: string): T {\n\tconst handler: ProxyHandler<typeof fn> = {\n\t\tasync apply(target, thisArg, argArray) {\n\t\t\tconst attributes = {\n\t\t\t\t'cache.name': cacheName,\n\t\t\t\t'http.url': argArray[0].url ? sanitiseURL(argArray[0].url) : undefined,\n\t\t\t\t'cache.operation': op,\n\t\t\t}\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes }\n\t\t\treturn tracer.startActiveSpan(`Cache ${cacheName} ${op}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tif (op === 'match') {\n\t\t\t\t\tspan.setAttribute('cache.hit', !!result)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nfunction instrumentCache(cache: Cache, cacheName: string): Cache {\n\tconst handler: ProxyHandler<typeof cache> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'delete' || prop === 'match' || prop === 'put') {\n\t\t\t\tconst fn = Reflect.get(target, prop).bind(target)\n\t\t\t\treturn instrumentFunction(fn, cacheName, prop)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(cache, handler)\n}\n\nfunction instrumentOpen(openFn: CacheStorage['open']): CacheStorage['open'] {\n\tconst handler: ProxyHandler<typeof openFn> = {\n\t\tasync apply(target, thisArg, argArray) {\n\t\t\tconst cacheName = argArray[0]\n\t\t\tconst cache = await Reflect.apply(target, thisArg, argArray)\n\t\t\treturn instrumentCache(cache, cacheName)\n\t\t},\n\t}\n\treturn wrap(openFn, handler)\n}\n\nfunction _instrumentGlobalCache() {\n\tconst handler: ProxyHandler<typeof caches> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'default') {\n\t\t\t\tconst cache = target.default\n\t\t\t\treturn instrumentCache(cache, 'default')\n\t\t\t} else if (prop === 'open') {\n\t\t\t\tconst openFn = Reflect.get(target, prop).bind(target)\n\t\t\t\treturn instrumentOpen(openFn)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\t//@ts-ignore\n\tglobalThis.caches = wrap(caches, handler)\n}\n\nexport function instrumentGlobalCache() {\n\treturn _instrumentGlobalCache()\n}\n","import { trace, SpanOptions, SpanKind, Exception, context as api_context, SpanStatusCode } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { Initialiser, setConfig } from '../config.js'\nimport { exportSpans, proxyExecutionContext } from './common.js'\nimport { instrumentEnv } from './env.js'\nimport { wrap } from '../wrap.js'\nimport { versionAttributes } from './version.js'\n\ntype ScheduledHandler = ExportedHandlerScheduledHandler<unknown>\nexport type ScheduledHandlerArgs = Parameters<ScheduledHandler>\n\nconst traceIdSymbol = Symbol('traceId')\n\nlet cold_start = true\nexport function executeScheduledHandler(\n\tscheduledFn: ScheduledHandler,\n\t[controller, env, ctx]: ScheduledHandlerArgs,\n): Promise<void> {\n\tconst tracer = trace.getTracer('scheduledHandler')\n\tconst attributes = {\n\t\t[SemanticAttributes.FAAS_TRIGGER]: 'timer',\n\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t\t[SemanticAttributes.FAAS_CRON]: controller.cron,\n\t\t[SemanticAttributes.FAAS_TIME]: new Date(controller.scheduledTime).toISOString(),\n\t}\n\tcold_start = false\n\tObject.assign(attributes, versionAttributes(env))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst promise = tracer.startActiveSpan(`scheduledHandler ${controller.cron}`, options, async (span) => {\n\t\tconst traceId = span.spanContext().traceId\n\t\tapi_context.active().setValue(traceIdSymbol, traceId)\n\t\ttry {\n\t\t\tawait scheduledFn(controller, env, ctx)\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tspan.end()\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function createScheduledHandler(scheduledFn: ScheduledHandler, initialiser: Initialiser) {\n\tconst scheduledHandler: ProxyHandler<ScheduledHandler> = {\n\t\tasync apply(target, _thisArg, argArray: Parameters<ScheduledHandler>): Promise<void> {\n\t\t\tconst [controller, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, controller)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: ScheduledHandlerArgs = [controller, env, ctx]\n\n\t\t\t\treturn await api_context.with(context, executeScheduledHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(scheduledFn, scheduledHandler)\n}\n","{\n  \"@microlabs/otel-cf-workers\": \"1.0.0-rc.49\",\n  \"npm\": \"9.8.1\",\n  \"node\": \"18.18.2\",\n  \"acorn\": \"8.10.0\",\n  \"ada\": \"2.6.0\",\n  \"ares\": \"1.19.1\",\n  \"brotli\": \"1.0.9\",\n  \"cldr\": \"43.1\",\n  \"icu\": \"73.2\",\n  \"llhttp\": \"6.0.11\",\n  \"modules\": \"108\",\n  \"napi\": \"9\",\n  \"nghttp2\": \"1.57.0\",\n  \"nghttp3\": \"0.7.0\",\n  \"ngtcp2\": \"0.8.1\",\n  \"openssl\": \"3.0.10+quic\",\n  \"simdutf\": \"3.2.14\",\n  \"tz\": \"2023c\",\n  \"undici\": \"5.26.3\",\n  \"unicode\": \"15.0\",\n  \"uv\": \"1.44.2\",\n  \"uvwasi\": \"0.0.18\",\n  \"v8\": \"10.2.154.26-node.26\",\n  \"zlib\": \"1.2.13.1-motley\"\n}\n","import { setConfig, type Initialiser } from '../config'\nimport { wrap } from '../wrap'\nimport { exportSpans, proxyExecutionContext } from './common'\nimport { context as api_context, Exception, SpanKind, type SpanOptions, trace } from '@opentelemetry/api'\nimport { instrumentEnv } from './env'\nimport { versionAttributes } from './version'\nimport {\n\tATTR_FAAS_TRIGGER,\n\tATTR_MESSAGING_DESTINATION_NAME,\n\tATTR_RPC_MESSAGE_ID,\n} from '@opentelemetry/semantic-conventions/incubating'\n\ntype EmailHandler = EmailExportedHandler\nexport type EmailHandlerArgs = Parameters<EmailHandler>\n\nexport function createEmailHandler(emailFn: EmailHandler, initialiser: Initialiser): EmailHandler {\n\tconst emailHandler: ProxyHandler<EmailHandler> = {\n\t\tasync apply(target, _thisArg, argArray: Parameters<EmailHandler>): Promise<void> {\n\t\t\tconst [message, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, message)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: EmailHandlerArgs = [message, env, ctx]\n\t\t\t\treturn await api_context.with(context, executeEmailHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(emailFn, emailHandler)\n}\n\n/**\n * Converts the message headers into a record ready to be injected\n * as OpenTelemetry attributes\n *\n * @example\n * ```ts\n * const headers = new Headers({ \"Subject\": \"Hello!\", From: \"hello@example.com\" })\n * headerAttributes({ headers })\n * // => {\"email.header.Subject\": \"Hello!\", \"email.header.From\": \"hello@example.com\"}\n * ```\n */\nfunction headerAttributes(message: { headers: Headers }): Record<string, unknown> {\n\treturn Object.fromEntries([...message.headers].map(([key, value]) => [`email.header.${key}`, value] as const))\n}\n\nasync function executeEmailHandler(emailFn: EmailHandler, [message, env, ctx]: EmailHandlerArgs): Promise<void> {\n\tconst tracer = trace.getTracer('emailHandler')\n\tconst options = {\n\t\tattributes: {\n\t\t\t[ATTR_FAAS_TRIGGER]: 'other',\n\t\t\t[ATTR_RPC_MESSAGE_ID]: message.headers.get('Message-Id') ?? undefined,\n\t\t\t[ATTR_MESSAGING_DESTINATION_NAME]: message.to,\n\t\t},\n\t\tkind: SpanKind.CONSUMER,\n\t} satisfies SpanOptions\n\tObject.assign(options.attributes!, headerAttributes(message), versionAttributes(env))\n\tconst promise = tracer.startActiveSpan(`emailHandler ${message.to}`, options, async (span) => {\n\t\ttry {\n\t\t\tconst result = await emailFn(message, env, ctx)\n\t\t\tspan.end()\n\t\t\treturn result\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n","import { ReadableSpan } from '@opentelemetry/sdk-trace-base'\nimport { Initialiser, setConfig } from '../config'\nimport { exportSpans, proxyExecutionContext } from './common'\nimport { Exception, SpanKind, SpanOptions, SpanStatusCode, context as api_context, trace } from '@opentelemetry/api'\nimport { wrap } from '../wrap'\nimport {\n\tgatherIncomingCfAttributes,\n\tgatherRequestAttributes,\n\tgatherResponseAttributes,\n\tgetParentContextFromRequest,\n} from './fetch'\n\ntype PageHandlerArgs = Parameters<PagesFunction>\n\nlet cold_start = true\nexport function executePageHandler(pagesFn: PagesFunction, [request]: PageHandlerArgs): Promise<Response> {\n\tconst spanContext = getParentContextFromRequest(request.request)\n\n\tconst tracer = trace.getTracer('pagesHandler')\n\tconst attributes = {\n\t\t['faas.trigger']: 'http',\n\t\t['faas.coldstart']: cold_start,\n\t\t['faas.invocation_id']: request.request.headers.get('cf-ray') ?? undefined,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(request.request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(request.request))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst promise = tracer.startActiveSpan(\n\t\t`${request.request.method} ${request.functionPath}`,\n\t\toptions,\n\t\tspanContext,\n\t\tasync (span) => {\n\t\t\tconst readable = span as unknown as ReadableSpan\n\t\t\ttry {\n\t\t\t\tconst response: Response = await pagesFn(request)\n\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\tif (readable.attributes['http.route']) {\n\t\t\t\t\tspan.updateName(`${request.request.method} ${readable.attributes['http.route']}`)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\n\t\t\t\treturn response\n\t\t\t} catch (error) {\n\t\t\t\tif (readable.attributes['http.route']) {\n\t\t\t\t\tspan.updateName(`${request.request.method} ${readable.attributes['http.route']}`)\n\t\t\t\t}\n\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\tspan.end()\n\t\t\t\tthrow error\n\t\t\t}\n\t\t},\n\t)\n\treturn promise\n}\n\nexport function createPageHandler<\n\tE = unknown,\n\tP extends string = any,\n\tD extends Record<string, unknown> = Record<string, unknown>,\n>(pageFn: PagesFunction<E, P, D>, initialiser: Initialiser): PagesFunction<E, P, D> {\n\tconst pagesHandler: ProxyHandler<PagesFunction> = {\n\t\tapply: async (target, _thisArg, argArray: Parameters<PagesFunction>): Promise<Response> => {\n\t\t\tconst [orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_ctx.env as Record<string, unknown>, orig_ctx.request)\n\t\t\t// @ts-expect-error\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tconst args: PageHandlerArgs = [ctx] as PageHandlerArgs\n\t\t\t\treturn await api_context.with(context, executePageHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(pageFn, pagesHandler)\n}\n","import { SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core'\n\n// First implementation, completely synchronous, more tested.\n\nexport class MultiSpanExporter implements SpanExporter {\n\tprivate exporters: Array<SpanExporter>\n\tconstructor(exporters: Array<SpanExporter>) {\n\t\tthis.exporters = exporters\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tfor (const exporter of this.exporters) {\n\t\t\texporter.export(items, resultCallback)\n\t\t}\n\t}\n\n\tasync shutdown(): Promise<void> {\n\t\tfor (const exporter of this.exporters) {\n\t\t\tawait exporter.shutdown()\n\t\t}\n\t}\n}\n\n// async\n\nexport class MultiSpanExporterAsync implements SpanExporter {\n\tprivate exporters: Array<SpanExporter>\n\tconstructor(exporters: Array<SpanExporter>) {\n\t\tthis.exporters = exporters\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tconst promises = this.exporters.map(\n\t\t\t(exporter) =>\n\t\t\t\tnew Promise<ExportResult>((resolve) => {\n\t\t\t\t\texporter.export(items, resolve)\n\t\t\t\t}),\n\t\t)\n\n\t\tPromise.all(promises).then((results) => {\n\t\t\tconst failed = results.filter((result) => result.code === ExportResultCode.FAILED)\n\t\t\tif (failed.length > 0) {\n\t\t\t\t// not ideal, but just return the first error\n\t\t\t\tresultCallback({ code: ExportResultCode.FAILED, error: failed[0]!.error })\n\t\t\t} else {\n\t\t\t\tresultCallback({ code: ExportResultCode.SUCCESS })\n\t\t\t}\n\t\t})\n\t}\n\n\tasync shutdown(): Promise<void> {\n\t\tawait Promise.all(this.exporters.map((exporter) => exporter.shutdown()))\n\t}\n}\n"],"mappings":"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","names":["import_api","import_api","import_core","import_sdk_trace_base","import_api","import_core","state","action","exportSpans","action","state","span","import_api","import_api","context","import_api","import_core","import_sdk_trace_base","import_api","import_core","init","context","api_context","span","import_api","import_api","import_semantic_conventions","import_api","context","tracer","import_api","import_semantic_conventions","tracer","state","tracer","context","api_context","import_api","import_semantic_conventions","dbSystem","tracer","import_api","import_semantic_conventions","target","prop","tracer","api_context","context","fetcher","import_api","import_semantic_conventions","dbSystem","tracer","import_api","import_semantic_conventions","dbSystem","tracer","api_context","headers","tracer","cold_start","context","import_api","import_api","import_semantic_conventions","traceIdSymbol","cold_start","tracer","api_context","context","@microlabs/otel-cf-workers","import_api","context","api_context","tracer","import_api","cold_start","tracer","context","api_context","@microlabs/otel-cf-workers","scheduler","import_core"]}