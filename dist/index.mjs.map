{"version":3,"sources":["../src/buffer.ts","../src/sampling.ts","../src/sdk.ts","../src/config.ts","../src/types.ts","../src/exporter.ts","../src/wrap.ts","../src/spanprocessor.ts","../src/vendor/ts-checked-fsm/StateMachine.ts","../src/provider.ts","../src/context.ts","../src/tracer.ts","../src/span.ts","../src/instrumentation/fetch.ts","../src/instrumentation/do.ts","../src/instrumentation/common.ts","../src/instrumentation/do-storage.ts","../src/instrumentation/kv.ts","../src/instrumentation/queue.ts","../src/instrumentation/version.ts","../src/instrumentation/service.ts","../src/instrumentation/d1.ts","../src/instrumentation/analytics-engine.ts","../src/instrumentation/env.ts","../src/instrumentation/cache.ts","../src/instrumentation/scheduled.ts","../versions.json","../src/instrumentation/email.ts","../src/instrumentation/page.ts","../src/instrumentation/entrypoint.ts","../src/multiexporter.ts"],"sourcesContent":["//@ts-ignore\nimport { Buffer } from 'node:buffer'\n//@ts-ignore\nglobalThis.Buffer = Buffer\n","import { TraceFlags, SpanStatusCode } from '@opentelemetry/api'\nimport { ParentBasedSampler, ReadableSpan, Sampler, TraceIdRatioBasedSampler } from '@opentelemetry/sdk-trace-base'\nimport { ParentRatioSamplingConfig } from './types'\n\nexport interface LocalTrace {\n\treadonly traceId: string\n\treadonly localRootSpan: ReadableSpan\n\treadonly spans: ReadableSpan[]\n}\n\nexport type TailSampleFn = (traceInfo: LocalTrace) => boolean\n\nexport function multiTailSampler(samplers: TailSampleFn[]): TailSampleFn {\n\treturn (traceInfo) => {\n\t\treturn samplers.reduce((result, sampler) => result || sampler(traceInfo), false)\n\t}\n}\n\nexport const isHeadSampled: TailSampleFn = (traceInfo) => {\n\tconst localRootSpan = traceInfo.localRootSpan\n\treturn (localRootSpan.spanContext().traceFlags & TraceFlags.SAMPLED) === TraceFlags.SAMPLED\n}\n\nexport const isRootErrorSpan: TailSampleFn = (traceInfo) => {\n\tconst localRootSpan = traceInfo.localRootSpan\n\treturn localRootSpan.status.code === SpanStatusCode.ERROR\n}\n\nexport function createSampler(conf: ParentRatioSamplingConfig): Sampler {\n\tconst ratioSampler = new TraceIdRatioBasedSampler(conf.ratio)\n\tif (typeof conf.acceptRemote === 'boolean' && !conf.acceptRemote) {\n\t\treturn new ParentBasedSampler({\n\t\t\troot: ratioSampler,\n\t\t\tremoteParentSampled: ratioSampler,\n\t\t\tremoteParentNotSampled: ratioSampler,\n\t\t})\n\t} else {\n\t\treturn new ParentBasedSampler({ root: ratioSampler })\n\t}\n}\n","import { propagation } from '@opentelemetry/api'\nimport { Resource } from '@opentelemetry/resources'\n\nimport { Initialiser, parseConfig } from './config.js'\nimport { WorkerTracerProvider } from './provider.js'\nimport { Trigger, TraceConfig, ResolvedTraceConfig } from './types.js'\nimport { unwrap } from './wrap.js'\nimport { createFetchHandler, instrumentGlobalFetch } from './instrumentation/fetch.js'\nimport { instrumentGlobalCache } from './instrumentation/cache.js'\nimport { createQueueHandler } from './instrumentation/queue.js'\nimport { DOClass, instrumentDOClass } from './instrumentation/do.js'\nimport { createScheduledHandler } from './instrumentation/scheduled.js'\n//@ts-ignore\nimport * as versions from '../versions.json'\nimport { createEmailHandler } from './instrumentation/email.js'\nimport { createPageHandler, ExportedSvelteEventHandler } from './instrumentation/page.js'\nimport { createEntrypointHandler } from './instrumentation/entrypoint.js'\n\ntype FetchHandler = ExportedHandlerFetchHandler<unknown, unknown>\ntype ScheduledHandler = ExportedHandlerScheduledHandler<unknown>\ntype QueueHandler = ExportedHandlerQueueHandler\ntype EmailHandler = EmailExportedHandler\n\nexport type ResolveConfigFn<Env = any> = (env: Env, trigger: Trigger) => TraceConfig\nexport type ConfigurationOption = TraceConfig | ResolveConfigFn\n\nexport { InstrumentedEntrypoint } from './instrumentation/entrypoint.js'\n\nexport function isRequest(trigger: Trigger): trigger is Request {\n\treturn trigger instanceof Request\n}\n\nexport function isMessageBatch(trigger: Trigger): trigger is MessageBatch {\n\treturn !!(trigger as MessageBatch).ackAll\n}\n\nexport function isAlarm(trigger: Trigger): trigger is 'do-alarm' {\n\treturn trigger === 'do-alarm'\n}\n\nconst createResource = (config: ResolvedTraceConfig): Resource => {\n\tconst workerResourceAttrs = {\n\t\t'cloud.provider': 'cloudflare',\n\t\t'cloud.platform': 'cloudflare.workers',\n\t\t'cloud.region': 'earth',\n\t\t'faas.max_memory': 134217728,\n\t\t'telemetry.sdk.language': 'js',\n\t\t'telemetry.sdk.name': '@microlabs/otel-cf-workers',\n\t\t'telemetry.sdk.version': versions['@microlabs/otel-cf-workers'],\n\t\t'telemetry.sdk.build.node_version': versions['node'],\n\t}\n\tconst serviceResource = new Resource({\n\t\t'service.name': config.service.name,\n\t\t'service.namespace': config.service.namespace,\n\t\t'service.version': config.service.version,\n\t})\n\tconst resource = new Resource(workerResourceAttrs)\n\treturn resource.merge(serviceResource)\n}\n\nlet initialised = false\nfunction init(config: ResolvedTraceConfig): void {\n\tif (!initialised) {\n\t\tif (config.instrumentation.instrumentGlobalCache) {\n\t\t\tinstrumentGlobalCache()\n\t\t}\n\t\tif (config.instrumentation.instrumentGlobalFetch) {\n\t\t\tinstrumentGlobalFetch()\n\t\t}\n\t\tpropagation.setGlobalPropagator(config.propagator)\n\t\tconst resource = createResource(config)\n\n\t\tconst provider = new WorkerTracerProvider(config.spanProcessors, resource)\n\t\tprovider.register()\n\t\tinitialised = true\n\t}\n}\n\nfunction createInitialiser(config: ConfigurationOption): Initialiser {\n\tif (typeof config === 'function') {\n\t\treturn (env, trigger) => {\n\t\t\tconst conf = parseConfig(config(env, trigger))\n\t\t\tinit(conf)\n\t\t\treturn conf\n\t\t}\n\t} else {\n\t\treturn () => {\n\t\t\tconst conf = parseConfig(config)\n\t\t\tinit(conf)\n\t\t\treturn conf\n\t\t}\n\t}\n}\n\nexport function instrumentEntrypoint(config: ConfigurationOption): MethodDecorator {\n\tconst initialiser = createInitialiser(config)\n\treturn createEntrypointHandler(initialiser)\n}\n\nexport function instrumentPage(\n\teventHandler: ExportedSvelteEventHandler,\n\tconfig: ConfigurationOption,\n): ExportedSvelteEventHandler {\n\tconst initialiser = createInitialiser(config)\n\n\teventHandler = createPageHandler(eventHandler, initialiser)\n\n\treturn eventHandler\n}\n\nexport function instrument<E, Q, C>(\n\thandler: ExportedHandler<E, Q, C>,\n\tconfig: ConfigurationOption,\n): ExportedHandler<E, Q, C> {\n\tconst initialiser = createInitialiser(config)\n\n\tif (handler.fetch) {\n\t\tconst fetcher = unwrap(handler.fetch) as FetchHandler\n\t\thandler.fetch = createFetchHandler(fetcher, initialiser)\n\t}\n\n\tif (handler.scheduled) {\n\t\tconst scheduler = unwrap(handler.scheduled) as ScheduledHandler\n\t\thandler.scheduled = createScheduledHandler(scheduler, initialiser)\n\t}\n\n\tif (handler.queue) {\n\t\tconst queuer = unwrap(handler.queue) as QueueHandler\n\t\thandler.queue = createQueueHandler(queuer, initialiser)\n\t}\n\n\tif (handler.email) {\n\t\tconst emailer = unwrap(handler.email) as EmailHandler\n\t\thandler.email = createEmailHandler(emailer, initialiser)\n\t}\n\n\treturn handler\n}\n\nexport function instrumentDO(doClass: DOClass, config: ConfigurationOption) {\n\tconst initialiser = createInitialiser(config)\n\n\treturn instrumentDOClass(doClass, initialiser)\n}\n\nexport { waitUntilTrace } from './instrumentation/fetch.js'\n\nexport const __unwrappedFetch = unwrap(fetch)\n","import { context } from '@opentelemetry/api'\nimport {\n\tExporterConfig,\n\tisSpanProcessorConfig,\n\tParentRatioSamplingConfig,\n\tResolvedTraceConfig,\n\tTraceConfig,\n\tTrigger,\n} from './types.js'\nimport { W3CTraceContextPropagator } from '@opentelemetry/core'\nimport { AlwaysOnSampler, ReadableSpan, Sampler, SpanExporter } from '@opentelemetry/sdk-trace-base'\n\nimport { OTLPExporter } from './exporter.js'\nimport { multiTailSampler, isHeadSampled, isRootErrorSpan, createSampler } from './sampling.js'\nimport { BatchTraceSpanProcessor } from './spanprocessor.js'\n\nconst configSymbol = Symbol('Otel Workers Tracing Configuration')\n\nexport type Initialiser = (env: Record<string, unknown>, trigger: Trigger) => ResolvedTraceConfig\n\nexport function setConfig(config: ResolvedTraceConfig, ctx = context.active()) {\n\treturn ctx.setValue(configSymbol, config)\n}\n\nexport function getActiveConfig(): ResolvedTraceConfig | undefined {\n\tconst config = context.active().getValue(configSymbol) as ResolvedTraceConfig\n\treturn config || undefined\n}\n\nfunction isSpanExporter(exporterConfig: ExporterConfig): exporterConfig is SpanExporter {\n\treturn !!(exporterConfig as SpanExporter).export\n}\n\nfunction isSampler(sampler: Sampler | ParentRatioSamplingConfig): sampler is Sampler {\n\treturn !!(sampler as Sampler).shouldSample\n}\n\nexport function parseConfig(supplied: TraceConfig): ResolvedTraceConfig {\n\tif (isSpanProcessorConfig(supplied)) {\n\t\tconst headSampleConf = supplied.sampling?.headSampler\n\t\tconst headSampler = headSampleConf\n\t\t\t? isSampler(headSampleConf)\n\t\t\t\t? headSampleConf\n\t\t\t\t: createSampler(headSampleConf)\n\t\t\t: new AlwaysOnSampler()\n\t\tconst spanProcessors = Array.isArray(supplied.spanProcessors) ? supplied.spanProcessors : [supplied.spanProcessors]\n\t\tif (spanProcessors.length === 0) {\n\t\t\tconsole.log(\n\t\t\t\t'Warning! You must either specify an exporter or your own SpanProcessor(s)/Exporter combination in the open-telemetry configuration.',\n\t\t\t)\n\t\t}\n\t\treturn {\n\t\t\tfetch: {\n\t\t\t\tincludeTraceContext: supplied.fetch?.includeTraceContext ?? true,\n\t\t\t},\n\t\t\thandlers: {\n\t\t\t\tfetch: {\n\t\t\t\t\tacceptTraceContext: supplied.handlers?.fetch?.acceptTraceContext ?? true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tpostProcessor: supplied.postProcessor || ((spans: ReadableSpan[]) => spans),\n\t\t\tsampling: {\n\t\t\t\theadSampler,\n\t\t\t\ttailSampler: supplied.sampling?.tailSampler || multiTailSampler([isHeadSampled, isRootErrorSpan]),\n\t\t\t},\n\t\t\tservice: supplied.service,\n\t\t\tspanProcessors,\n\t\t\tpropagator: supplied.propagator || new W3CTraceContextPropagator(),\n\t\t\tinstrumentation: {\n\t\t\t\tinstrumentGlobalCache: supplied.instrumentation?.instrumentGlobalCache ?? true,\n\t\t\t\tinstrumentGlobalFetch: supplied.instrumentation?.instrumentGlobalFetch ?? true,\n\t\t\t},\n\t\t}\n\t} else {\n\t\tconst exporter = isSpanExporter(supplied.exporter) ? supplied.exporter : new OTLPExporter(supplied.exporter)\n\t\tconst spanProcessors = [new BatchTraceSpanProcessor(exporter)]\n\t\tconst newConfig = Object.assign(supplied, { exporter: undefined, spanProcessors }) as TraceConfig\n\t\treturn parseConfig(newConfig)\n\t}\n}\n","import { TextMapPropagator } from '@opentelemetry/api'\nimport { ReadableSpan, Sampler, SpanExporter, SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { OTLPExporterConfig } from './exporter.js'\nimport { FetchHandlerConfig, FetcherConfig } from './instrumentation/fetch.js'\nimport { TailSampleFn } from './sampling.js'\n\nexport type PostProcessorFn = (spans: ReadableSpan[]) => ReadableSpan[]\n\nexport type ExporterConfig = OTLPExporterConfig | SpanExporter\n\nexport interface HandlerConfig {\n\tfetch?: FetchHandlerConfig\n}\n\nexport interface ServiceConfig {\n\tname: string\n\tnamespace?: string\n\tversion?: string\n}\n\nexport interface ParentRatioSamplingConfig {\n\tacceptRemote?: boolean\n\tratio: number\n}\n\ntype HeadSamplerConf = Sampler | ParentRatioSamplingConfig\nexport interface SamplingConfig<HS extends HeadSamplerConf = HeadSamplerConf> {\n\theadSampler?: HS\n\ttailSampler?: TailSampleFn\n}\n\nexport interface InstrumentationOptions {\n\tinstrumentGlobalFetch?: boolean\n\tinstrumentGlobalCache?: boolean\n}\n\ninterface TraceConfigBase {\n\tservice: ServiceConfig\n\thandlers?: HandlerConfig\n\tfetch?: FetcherConfig\n\tpostProcessor?: PostProcessorFn\n\tsampling?: SamplingConfig\n\tpropagator?: TextMapPropagator\n\tinstrumentation?: InstrumentationOptions\n}\n\ninterface TraceConfigExporter extends TraceConfigBase {\n\texporter: ExporterConfig\n}\n\ninterface TraceConfigSpanProcessors extends TraceConfigBase {\n\tspanProcessors: SpanProcessor | SpanProcessor[]\n}\n\nexport type TraceConfig = TraceConfigExporter | TraceConfigSpanProcessors\n\nexport function isSpanProcessorConfig(config: TraceConfig): config is TraceConfigSpanProcessors {\n\treturn !!(config as TraceConfigSpanProcessors).spanProcessors\n}\n\nexport interface ResolvedTraceConfig extends TraceConfigBase {\n\thandlers: Required<HandlerConfig>\n\tfetch: Required<FetcherConfig>\n\tpostProcessor: PostProcessorFn\n\tsampling: Required<SamplingConfig<Sampler>>\n\tspanProcessors: SpanProcessor[]\n\tpropagator: TextMapPropagator\n\tinstrumentation: InstrumentationOptions\n}\n\nexport interface DOConstructorTrigger {\n\tid: string\n\tname?: string\n}\n\nexport type Trigger =\n\t| Request\n\t| MessageBatch\n\t| ScheduledController\n\t| DOConstructorTrigger\n\t| 'do-alarm'\n\t| ForwardableEmailMessage\n\t| PropertyDescriptor\n","import { createExportTraceServiceRequest } from '@opentelemetry/otlp-transformer'\nimport { ExportServiceError, OTLPExporterError } from '@opentelemetry/otlp-exporter-base'\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core'\nimport { SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport { unwrap } from './wrap.js'\n\nexport interface OTLPExporterConfig {\n\turl: string\n\theaders?: Record<string, string>\n}\n\nconst defaultHeaders: Record<string, string> = {\n\taccept: 'application/json',\n\t'content-type': 'application/json',\n}\n\nexport class OTLPExporter implements SpanExporter {\n\tprivate headers: Record<string, string>\n\tprivate url: string\n\tconstructor(config: OTLPExporterConfig) {\n\t\tthis.url = config.url\n\t\tthis.headers = Object.assign({}, defaultHeaders, config.headers)\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tthis._export(items)\n\t\t\t.then(() => {\n\t\t\t\tresultCallback({ code: ExportResultCode.SUCCESS })\n\t\t\t})\n\t\t\t.catch((error: ExportServiceError) => {\n\t\t\t\tresultCallback({ code: ExportResultCode.FAILED, error })\n\t\t\t})\n\t}\n\n\tprivate _export(items: any[]): Promise<unknown> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tthis.send(items, resolve, reject)\n\t\t\t} catch (e) {\n\t\t\t\treject(e)\n\t\t\t}\n\t\t})\n\t}\n\n\tsend(items: any[], onSuccess: () => void, onError: (error: OTLPExporterError) => void): void {\n\t\tconst exportMessage = createExportTraceServiceRequest(items, {\n\t\t\tuseHex: true,\n\t\t\tuseLongBits: false,\n\t\t})\n\t\tconst body = JSON.stringify(exportMessage)\n\t\tconst params: RequestInit = {\n\t\t\tmethod: 'POST',\n\t\t\theaders: this.headers,\n\t\t\tbody,\n\t\t}\n\n\t\tunwrap(fetch)(this.url, params)\n\t\t\t.then((response) => {\n\t\t\t\tif (response.ok) {\n\t\t\t\t\tonSuccess()\n\t\t\t\t} else {\n\t\t\t\t\tonError(new OTLPExporterError(`Exporter received a statusCode: ${response.status}`))\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tonError(new OTLPExporterError(`Exception during export: ${error.toString()}`, error.code, error.stack))\n\t\t\t})\n\t}\n\n\tasync shutdown(): Promise<void> {}\n}\n","const unwrapSymbol = Symbol('unwrap')\n\ntype Wrapped<T> = { [unwrapSymbol]: T } & T\n\nexport function isWrapped<T>(item: T): item is Wrapped<T> {\n\treturn item && !!(item as Wrapped<T>)[unwrapSymbol]\n}\n\nexport function isProxyable(item: any) {\n\treturn (item !== null && typeof item === 'object') || typeof item === 'function'\n}\n\nexport function wrap<T extends object>(item: T, handler: ProxyHandler<T>, autoPassthrough: boolean = true): T {\n\tif (isWrapped(item) || !isProxyable(item)) {\n\t\treturn item\n\t}\n\tconst proxyHandler = Object.assign({}, handler)\n\tproxyHandler.get = (target, prop, receiver) => {\n\t\tif (prop === unwrapSymbol) {\n\t\t\treturn item\n\t\t} else {\n\t\t\tif (handler.get) {\n\t\t\t\treturn handler.get(target, prop, receiver)\n\t\t\t} else if (prop === 'bind') {\n\t\t\t\treturn () => receiver\n\t\t\t} else if (autoPassthrough) {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t}\n\t}\n\tproxyHandler.apply = (target, thisArg, argArray) => {\n\t\tif (handler.apply) {\n\t\t\treturn handler.apply(unwrap(target), unwrap(thisArg), argArray)\n\t\t}\n\t}\n\treturn new Proxy(item, proxyHandler)\n}\n\nexport function unwrap<T extends object>(item: T): T {\n\tif (item && isWrapped(item)) {\n\t\treturn item[unwrapSymbol]\n\t} else {\n\t\treturn item\n\t}\n}\n\nexport function passthroughGet(target: any, prop: string | symbol, thisArg?: any) {\n\tconst unwrappedTarget = unwrap(target)\n\tconst value = Reflect.get(unwrappedTarget, prop)\n\tif (typeof value === 'function') {\n\t\tif (value.constructor.name === 'RpcProperty') {\n\t\t\treturn (...args: unknown[]) => unwrappedTarget[prop](...args)\n\t\t}\n\t\tthisArg = thisArg || unwrappedTarget\n\t\treturn value.bind(thisArg)\n\t} else {\n\t\treturn value\n\t}\n}\n","import { Context, Span, trace } from '@opentelemetry/api'\nimport { ReadableSpan, SpanExporter, SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core'\nimport { Action, State, stateMachine } from './vendor/ts-checked-fsm/StateMachine.js'\n\nimport { getActiveConfig } from './config.js'\nimport { TailSampleFn } from './sampling.js'\nimport { PostProcessorFn } from './types.js'\n\ntype CompletedTrace = {\n\ttraceId: string\n\tlocalRootSpan: ReadableSpan\n\tcompletedSpans: ReadableSpan[]\n}\n\ntype InProgressTrace = {\n\tinProgressSpanIds: Set<string>\n} & CompletedTrace\n\ntype InitialState = State<'not_started'>\ntype InProgressTraceState = State<'in_progress', InProgressTrace>\ntype TraceCompleteState = State<'trace_complete', CompletedTrace>\ntype ExportingState = State<'exporting', { promise: Promise<ExportResult> }>\ntype DoneState = State<'done'>\n\ntype StartExportArguments = {\n\texporter: SpanExporter\n\ttailSampler: TailSampleFn\n\tpostProcessor: PostProcessorFn\n}\n\ntype StartSpanAction = Action<'startSpan', { span: Span }>\ntype EndSpanAction = Action<'endSpan', { span: ReadableSpan }>\ntype StartExportAction = Action<'startExport', { args: StartExportArguments }>\n\nfunction newTrace(currentState: InitialState, { span }: StartSpanAction): InProgressTraceState {\n\tconst spanId = span.spanContext().spanId\n\treturn {\n\t\t...currentState,\n\t\tstateName: 'in_progress',\n\t\ttraceId: span.spanContext().traceId,\n\t\tlocalRootSpan: span as unknown as ReadableSpan,\n\t\tcompletedSpans: [] as ReadableSpan[],\n\t\tinProgressSpanIds: new Set([spanId]),\n\t} as const\n}\n\nfunction newSpan(currentState: InProgressTraceState, { span }: StartSpanAction): InProgressTraceState {\n\tconst spanId = span.spanContext().spanId\n\tcurrentState.inProgressSpanIds.add(spanId)\n\treturn { ...currentState }\n}\n\nfunction endSpan(\n\tcurrentState: InProgressTraceState,\n\t{ span }: EndSpanAction,\n): InProgressTraceState | TraceCompleteState {\n\tcurrentState.completedSpans.push(span)\n\tcurrentState.inProgressSpanIds.delete(span.spanContext().spanId)\n\tif (currentState.inProgressSpanIds.size === 0) {\n\t\treturn {\n\t\t\tstateName: 'trace_complete',\n\t\t\ttraceId: currentState.traceId,\n\t\t\tlocalRootSpan: currentState.localRootSpan,\n\t\t\tcompletedSpans: currentState.completedSpans,\n\t\t} as const\n\t} else {\n\t\treturn { ...currentState }\n\t}\n}\n\nfunction startExport(currentState: TraceCompleteState, { args }: StartExportAction): ExportingState | DoneState {\n\tconst { exporter, tailSampler, postProcessor } = args\n\tconst { traceId, localRootSpan, completedSpans: spans } = currentState\n\tconst shouldExport = tailSampler({ traceId, localRootSpan, spans })\n\tif (shouldExport) {\n\t\tconst exportSpans = postProcessor(spans)\n\t\tconst promise = new Promise<ExportResult>((resolve) => {\n\t\t\texporter.export(exportSpans, resolve)\n\t\t})\n\t\treturn { stateName: 'exporting', promise }\n\t} else {\n\t\treturn { stateName: 'done' }\n\t}\n}\n\nconst { nextState } = stateMachine()\n\t.state('not_started')\n\t.state<'in_progress', InProgressTraceState>('in_progress')\n\t.state<'trace_complete', TraceCompleteState>('trace_complete')\n\t.state<'exporting', ExportingState>('exporting')\n\t.state('done')\n\t.transition('not_started', 'in_progress')\n\t.transition('in_progress', 'in_progress')\n\t.transition('in_progress', 'trace_complete')\n\t.transition('trace_complete', 'exporting')\n\t.transition('trace_complete', 'done')\n\t.transition('exporting', 'done')\n\t.action<'startSpan', StartSpanAction>('startSpan')\n\t.action<'endSpan', EndSpanAction>('endSpan')\n\t.action<'startExport', StartExportAction>('startExport')\n\t.action('exportDone')\n\t.actionHandler('not_started', 'startSpan', newTrace)\n\t.actionHandler('in_progress', 'startSpan', newSpan)\n\t.actionHandler('in_progress', 'endSpan', endSpan)\n\t.actionHandler('trace_complete', 'startExport', startExport)\n\t.actionHandler('exporting', 'exportDone', (_c, _a) => {\n\t\treturn { stateName: 'done' } as const\n\t})\n\t.done()\n\ntype AnyTraceState = Parameters<typeof nextState>[0]\ntype AnyTraceAction = Parameters<typeof nextState>[1]\n\nexport class BatchTraceSpanProcessor implements SpanProcessor {\n\tprivate traceLookup: Map<string, AnyTraceState> = new Map()\n\tprivate localRootSpanLookup: Map<string, string> = new Map()\n\tprivate inprogressExports: Map<string, Promise<ExportResult>> = new Map()\n\n\tconstructor(private exporter: SpanExporter) {}\n\n\tprivate action(localRootSpanId: string, action: AnyTraceAction): AnyTraceState {\n\t\tconst state = this.traceLookup.get(localRootSpanId) || { stateName: 'not_started' }\n\t\tconst newState = nextState(state, action)\n\t\tif (newState.stateName === 'done') {\n\t\t\tthis.traceLookup.delete(localRootSpanId)\n\t\t} else {\n\t\t\tthis.traceLookup.set(localRootSpanId, newState)\n\t\t}\n\t\treturn newState\n\t}\n\n\tprivate export(localRootSpanId: string) {\n\t\tconst config = getActiveConfig()\n\t\tif (!config) throw new Error('Config is undefined. This is a bug in the instrumentation logic')\n\n\t\tconst { sampling, postProcessor } = config\n\t\tconst exportArgs = { exporter: this.exporter, tailSampler: sampling.tailSampler, postProcessor }\n\t\tconst newState = this.action(localRootSpanId, { actionName: 'startExport', args: exportArgs })\n\t\tif (newState.stateName === 'exporting') {\n\t\t\tconst promise = newState.promise\n\t\t\tthis.inprogressExports.set(localRootSpanId, promise)\n\t\t\tpromise.then((result) => {\n\t\t\t\tif (result.code === ExportResultCode.FAILED) {\n\t\t\t\t\tconsole.log('Error sending spans to exporter:', result.error)\n\t\t\t\t}\n\t\t\t\tthis.action(localRootSpanId, { actionName: 'exportDone' })\n\t\t\t\tthis.inprogressExports.delete(localRootSpanId)\n\t\t\t})\n\t\t}\n\t}\n\n\tonStart(span: Span, parentContext: Context): void {\n\t\tconst spanId = span.spanContext().spanId\n\t\tconst parentSpanId = trace.getSpan(parentContext)?.spanContext()?.spanId\n\t\tconst parentRootSpanId = parentSpanId ? this.localRootSpanLookup.get(parentSpanId) : undefined\n\t\tconst localRootSpanId = parentRootSpanId || spanId\n\t\tthis.localRootSpanLookup.set(spanId, localRootSpanId)\n\n\t\tthis.action(localRootSpanId, { actionName: 'startSpan', span })\n\t}\n\n\tonEnd(span: ReadableSpan): void {\n\t\tconst spanId = span.spanContext().spanId\n\t\tconst localRootSpanId = this.localRootSpanLookup.get(spanId)\n\t\tif (localRootSpanId) {\n\t\t\tconst state = this.action(localRootSpanId, { actionName: 'endSpan', span })\n\t\t\tif (state.stateName === 'trace_complete') {\n\t\t\t\tstate.completedSpans.forEach((span) => {\n\t\t\t\t\tthis.localRootSpanLookup.delete(span.spanContext().spanId)\n\t\t\t\t})\n\t\t\t\tthis.export(localRootSpanId)\n\t\t\t}\n\t\t}\n\t}\n\n\tasync forceFlush(): Promise<void> {\n\t\tawait Promise.allSettled(this.inprogressExports.values())\n\t}\n\n\tasync shutdown(): Promise<void> {}\n}\n","/**\n * State labels can be strings\n */\ntype StateType = IndexType\n\n/**\n * Action labels can be strings\n */\nexport type ActionNameType = IndexType\n\n/**\n * Represents a state and data and its corresponding data.\n */\nexport type State<S extends StateType, D = {}> = Readonly<D> & {\n\treadonly stateName: S\n}\n\n/**\n * Give Actions to nextState() to (maybe) trigger a transition.\n */\nexport type Action<Name extends ActionNameType, Payload> = Readonly<Payload> & {\n\treadonly actionName: Name\n}\n\n///\n/// Errors\n///\n\n/**\n * Represents a compiler error message. Error brands prevent really clever users from naming their states as one of the error messages\n * and subverting error checking. Yet, the compiler still displays the string at the end of the failed cast indicating what the\n * issue is rather than something puzzling like could not assign to never.\n */\ntype ErrorBrand<T extends IndexType> = { [k in T]: void }\n\ntype IndexType = string | number\n\n/// Validators\ntype AssertStateInMap<StateMap, S extends StateType> =\n\tS extends MapKeys<StateMap> ? S : ErrorBrand<`'${S}' is not a state`>\ntype AssertNewState<S extends StateType, States> =\n\tS extends MapKeys<States> ? ErrorBrand<`'${S}' has already been declared`> : S\ntype AssertNewTransition<S extends StateType, N extends StateType, Transitions> =\n\tN extends MapLookup<Transitions, S> ? ErrorBrand<`There already exists a transition from '${S}' to '${N}'`> : N\ntype AssertActionNotDefined<AN extends ActionNameType, ActionNames extends IndexType> = AN extends ActionNames\n\t? ErrorBrand<`Action '${AN}' already declared`>\n\t: AN\ntype AssertActionIsDefined<AN extends ActionNameType, ActionNames extends IndexType> = AN extends ActionNames\n\t? AN\n\t: ErrorBrand<`'${AN}' is not an action`>\ntype AssertAllNonTerminalStatesHandled<Transitions, HandledStates> =\n\tMapKeys<Transitions> extends HandledStates\n\t\t? void\n\t\t: ErrorBrand<`No handlers declared for ${Exclude<MapKeys<Transitions>, HandledStates>}`>\n\ntype StateMachineDefinition<S, A> = {\n\thandlers: {\n\t\t[s: string]: {\n\t\t\t[a: string]: (cur: MapValues<S>, action: MapValues<A>) => MapValues<S>\n\t\t}\n\t}\n}\n\n// Allows us to append multiple values for the same key in a type map.\ntype AddToTypeMap<M, K extends string | number | symbol, V> = M | [K, V]\n\ntype MapLookup<Map, K extends string | number | symbol> = Map extends [K, infer V] ? V : never\ntype MapKeys<Map> = Map extends [infer K, infer _] ? (K extends IndexType ? K : never) : never\ntype MapValues<Map> = Map extends [infer _, infer V] ? V : never\n\n///\n/// stateMachine() builder\n///\n\n/**\n * A builder from calling stateMachine().\n */\nexport type StateMachineBuilder = {\n\t/**\n\t * Add a state to this state machine.\n\t */\n\treadonly state: StateFunc<never>\n}\n\ntype StateMachineFunc = () => StateMachineBuilder\n\n///\n/// .state() builder\n///\n\n/**\n * A builder from calling .state()\n */\nexport type StateBuilder<StateMap> = {\n\t/**\n\t * Add a state to this state machine.\n\t */\n\treadonly state: StateFunc<StateMap>\n\n\treadonly transition: TransitionFunc<StateMap, never>\n}\n\n/**\n * The signature for calling the state function in the builder.\n */\ntype StateFunc<StateMap> = <S extends StateType, Data = {}>(\n\tstate: AssertNewState<S, StateMap>,\n) => StateBuilder<AddToTypeMap<StateMap, S, State<S, Data>>>\n\n///\n/// .transition() builder\n///\n\n/**\n * The builder returned by .transition()\n */\nexport type TransitionBuilder<StateMap, Transitions> = {\n\t/**\n\t * Add a transition to this state machine.\n\t */\n\treadonly transition: TransitionFunc<StateMap, Transitions>\n\n\treadonly action: ActionFunc<StateMap, Transitions, never>\n}\n\n/**\n * The signature of .transition()\n */\nexport type TransitionFunc<StateMap, Transitions> = <S extends StateType, N extends StateType>(\n\tcurState: AssertStateInMap<StateMap, S>,\n\tnextState: N extends MapKeys<StateMap>\n\t\t? AssertNewTransition<S, N, Transitions>\n\t\t: ErrorBrand<`${S} is not a declared state`>,\n) => TransitionBuilder<StateMap, AddToTypeMap<Transitions, S, N>>\n\n///\n/// .action() builder\n///\n\nexport type ActionBuilder<StateMap, Transitions, ActionsMap> = {\n\treadonly action: ActionFunc<StateMap, Transitions, ActionsMap>\n\n\treadonly actionHandler: ActionHandlerFunc<StateMap, Transitions, ActionsMap, never>\n}\n\nexport type ActionFunc<StateMap, Transitions, ActionsMap> = <AN extends ActionNameType, AP = {}>(\n\tactionName: AssertActionNotDefined<AN, MapKeys<ActionsMap>>,\n) => ActionBuilder<StateMap, Transitions, AddToTypeMap<ActionsMap, AN, Action<AN, AP>>>\n\n///\n/// .actionsHandler() builder.\n///\n\n/**\n * The builder returned by .actionHandler()\n */\nexport type ActionHandlersBuilder<StateMap, Transitions, ActionsMap, HandledStates> = {\n\treadonly actionHandler: ActionHandlerFunc<StateMap, Transitions, ActionsMap, HandledStates>\n\n\treadonly done: DoneFunc<StateMap, ActionsMap, Transitions, HandledStates>\n}\n\n/**\n * The Signature of .actionHandler().\n */\nexport type ActionHandlerFunc<StateMap, Transitions, ActionMap, HandledStates> = <\n\tS extends StateType,\n\tAN extends ActionNameType,\n\tNS extends MapValues<StateMap>,\n>(\n\t// TODO: Checking that the action and state pair haven't already been declared here causes\n\tstate: AssertStateInMap<StateMap, S>,\n\taction: AssertActionIsDefined<AN, MapKeys<ActionMap>>,\n\thandler: ActionHandlerCallback<StateMap, Transitions, S, AN, NS, ActionMap>,\n) => ActionHandlersBuilder<StateMap, Transitions, ActionMap, HandledStates | S>\n\ntype ActionHandlerCallback<\n\tStates,\n\tTransitions,\n\tCS extends StateType,\n\tAN extends ActionNameType,\n\tNS extends MapValues<States>,\n\tActions,\n> = (\n\tstate: MapLookup<States, CS>,\n\taction: MapLookup<Actions, AN>,\n) => NS extends State<infer N, infer ND>\n\t? N extends MapKeys<States>\n\t\t? CS extends MapKeys<Transitions>\n\t\t\t? N extends MapLookup<Transitions, CS>\n\t\t\t\t? State<N, ND>\n\t\t\t\t: ErrorBrand<`No transition declared between ${CS} and ${N}`>\n\t\t\t: ErrorBrand<`State ${CS} is terminal and has no transitions`>\n\t\t: ErrorBrand<`${N} is not a state`>\n\t: ErrorBrand<'The returned value is not a state'>\n\n///\n/// .done()\n///\ntype DoneBuilder = <StateMap, ActionMap, Transitions, HandledStates>(\n\tdefinition: StateMachineDefinition<StateMap, ActionMap>,\n) => DoneFunc<StateMap, ActionMap, Transitions, HandledStates>\n\n// Check that the only unhandled states in the handler map are final states (i.e, they have no transitions out of them)\ntype DoneFunc<StateMap, ActionMap, Transitions, HandledStates> = (\n\t_: AssertAllNonTerminalStatesHandled<Transitions, HandledStates>,\n) => StateMachine<StateMap, ActionMap>\n\n/**\n * A state machine\n */\nexport type StateMachine<StateMap, ActionMap> = {\n\tnextState: (curState: MapValues<StateMap>, action: MapValues<ActionMap>) => MapValues<StateMap>\n}\n\nexport const stateMachine: StateMachineFunc = (): StateMachineBuilder => {\n\tconst stateFunc = state<never>()\n\n\treturn {\n\t\tstate: stateFunc,\n\t}\n}\n\nconst state = <StateMap>(): StateFunc<StateMap> => {\n\treturn <S extends StateType, D = {}>(_s: AssertNewState<S, StateMap>) => {\n\t\ttype NewStateMap = AddToTypeMap<StateMap, S, State<S, D>>\n\n\t\tconst transitionFunc = transition<NewStateMap, never>()\n\t\tconst stateFunc = state<NewStateMap>()\n\n\t\tconst builder = {\n\t\t\tstate: stateFunc,\n\t\t\ttransition: transitionFunc,\n\t\t}\n\n\t\treturn builder\n\t}\n}\n\nconst transition = <StateMap, Transitions>(): TransitionFunc<StateMap, Transitions> => {\n\treturn <S extends StateType, N extends StateType>(\n\t\t_curState: AssertStateInMap<StateMap, S>,\n\t\t_next: N extends MapKeys<StateMap>\n\t\t\t? AssertNewTransition<S, N, Transitions>\n\t\t\t: ErrorBrand<`${S} is not a declared state`>,\n\t) => {\n\t\ttype NewTransitions = AddToTypeMap<Transitions, S, N>\n\n\t\tconst transitionFunction = transition<StateMap, NewTransitions>()\n\t\tconst actionFunc = action<StateMap, NewTransitions, never>()\n\n\t\treturn {\n\t\t\ttransition: transitionFunction,\n\t\t\taction: actionFunc,\n\t\t}\n\t}\n}\n\nconst action = <StateMap, Transitions, ActionMap>(): ActionFunc<StateMap, Transitions, ActionMap> => {\n\treturn <AN extends ActionNameType, AP = {}>(_actionName: AssertActionNotDefined<AN, MapKeys<ActionMap>>) => {\n\t\ttype NewActionMap = AddToTypeMap<ActionMap, AN, Action<AN, AP>>\n\n\t\tconst actionFunc: any = action<StateMap, Transitions, NewActionMap>()\n\t\tconst actionHandlerFunc = actionHandler<StateMap, Transitions, NewActionMap, never>({ handlers: {} })\n\n\t\treturn {\n\t\t\taction: actionFunc,\n\t\t\tactionHandler: actionHandlerFunc,\n\t\t}\n\t}\n}\n\nconst actionHandler = <StateMap, Transitions, ActionMap, HandledStates>(\n\tdefinition: StateMachineDefinition<StateMap, ActionMap>,\n): ActionHandlerFunc<StateMap, Transitions, ActionMap, HandledStates> => {\n\treturn <S extends StateType, AN extends ActionNameType, NS extends MapValues<StateMap>>(\n\t\tstate: AssertStateInMap<StateMap, S>,\n\t\taction: AssertActionIsDefined<AN, MapKeys<ActionMap>>,\n\t\thandler: ActionHandlerCallback<StateMap, Transitions, S, AN, NS, ActionMap>,\n\t) => {\n\t\tconst untypedState = state as unknown as S\n\t\tconst untypedAction = action as unknown as AN\n\t\tconst newDefinition: StateMachineDefinition<StateMap, ActionMap> = {\n\t\t\t...definition,\n\t\t\thandlers: {\n\t\t\t\t...definition.handlers,\n\t\t\t\t[untypedState]: {\n\t\t\t\t\t...(definition.handlers[untypedState] ? definition.handlers[untypedState] : {}),\n\t\t\t\t\t[untypedAction]: handler as any,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttype NextHandledStates = HandledStates | S\n\n\t\tconst doneFunc = done<StateMap, ActionMap, Transitions, NextHandledStates>(newDefinition)\n\t\tconst actionHandlerFunc = actionHandler<StateMap, Transitions, ActionMap, NextHandledStates>(newDefinition)\n\n\t\treturn {\n\t\t\tactionHandler: actionHandlerFunc,\n\t\t\tdone: doneFunc,\n\t\t}\n\t}\n}\n\nconst done: DoneBuilder = <StateMap, ActionMap, Transitions, HandledStates>(\n\tdefinition: StateMachineDefinition<StateMap, ActionMap>,\n) => {\n\tconst doneFunc: DoneFunc<StateMap, ActionMap, Transitions, HandledStates> = (\n\t\t_: AssertAllNonTerminalStatesHandled<Transitions, HandledStates>,\n\t): StateMachine<StateMap, ActionMap> => {\n\t\tconst nextStateFunction = (curState: MapValues<StateMap>, action: MapValues<ActionMap>): MapValues<StateMap> => {\n\t\t\tconst curStateAsState = curState as unknown as State<string, {}>\n\t\t\tconst actionAsAction = action as unknown as Action<string, {}>\n\n\t\t\t// If no handler declared for state, state doesn't change.\n\t\t\tif (definition.handlers[curStateAsState.stateName] == null) {\n\t\t\t\treturn curState\n\t\t\t}\n\n\t\t\t// If no handler declared for action in given state, state doesn't change.\n\t\t\tconst handler = definition.handlers[curStateAsState.stateName]\n\t\t\tif (handler === undefined) {\n\t\t\t\treturn curState\n\t\t\t}\n\t\t\tconst nextAction = handler[actionAsAction.actionName]\n\n\t\t\treturn nextAction != null ? nextAction(curState, action) : curState\n\t\t}\n\n\t\treturn {\n\t\t\tnextState: nextStateFunction,\n\t\t}\n\t}\n\n\treturn doneFunc\n}\n","import { context, trace, Tracer, TracerOptions, TracerProvider } from '@opentelemetry/api'\n\nimport { SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { Resource } from '@opentelemetry/resources'\n\nimport { AsyncLocalStorageContextManager } from './context.js'\nimport { WorkerTracer } from './tracer.js'\n\n/**\n * Register this TracerProvider for use with the OpenTelemetry API.\n * Undefined values may be replaced with defaults, and\n * null values will be skipped.\n *\n * @param config Configuration object for SDK registration\n */\nexport class WorkerTracerProvider implements TracerProvider {\n\tprivate spanProcessors: SpanProcessor[]\n\tprivate resource: Resource\n\tprivate tracers: Record<string, Tracer> = {}\n\n\tconstructor(spanProcessors: SpanProcessor[], resource: Resource) {\n\t\tthis.spanProcessors = spanProcessors\n\t\tthis.resource = resource\n\t}\n\n\tgetTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n\t\tconst key = `${name}@${version || ''}:${options?.schemaUrl || ''}`\n\t\tif (!this.tracers[key]) {\n\t\t\tthis.tracers[key] = new WorkerTracer(this.spanProcessors, this.resource)\n\t\t}\n\t\treturn this.tracers[key]!\n\t}\n\n\tregister(): void {\n\t\ttrace.setGlobalTracerProvider(this)\n\t\tcontext.setGlobalContextManager(new AsyncLocalStorageContextManager())\n\t}\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextManager, Context, ROOT_CONTEXT } from '@opentelemetry/api'\n//@ts-ignore\nimport { AsyncLocalStorage } from 'node:async_hooks'\n//@ts-ignore\nimport { EventEmitter } from 'node:events'\n\ntype Func<T> = (...args: unknown[]) => T\n\n/**\n * Store a map for each event of all original listeners and their \"patched\"\n * version. So when a listener is removed by the user, the corresponding\n * patched function will be also removed.\n */\ninterface PatchMap {\n\t[name: string]: WeakMap<Func<void>, Func<void>>\n}\n\nconst ADD_LISTENER_METHODS = [\n\t'addListener' as const,\n\t'on' as const,\n\t'once' as const,\n\t'prependListener' as const,\n\t'prependOnceListener' as const,\n]\n\nabstract class AbstractAsyncHooksContextManager implements ContextManager {\n\tabstract active(): Context\n\n\tabstract with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\tcontext: Context,\n\t\tfn: F,\n\t\tthisArg?: ThisParameterType<F>,\n\t\t...args: A\n\t): ReturnType<F>\n\n\tabstract enable(): this\n\n\tabstract disable(): this\n\n\t/**\n\t * Binds a the certain context or the active one to the target function and then returns the target\n\t * @param context A context (span) to be bind to target\n\t * @param target a function or event emitter. When target or one of its callbacks is called,\n\t *  the provided context will be used as the active context for the duration of the call.\n\t */\n\tbind<T>(context: Context, target: T): T {\n\t\tif (target instanceof EventEmitter) {\n\t\t\treturn this._bindEventEmitter(context, target)\n\t\t}\n\n\t\tif (typeof target === 'function') {\n\t\t\treturn this._bindFunction(context, target)\n\t\t}\n\t\treturn target\n\t}\n\n\tprivate _bindFunction<T extends Function>(context: Context, target: T): T {\n\t\tconst manager = this\n\t\tconst contextWrapper = function (this: never, ...args: unknown[]) {\n\t\t\treturn manager.with(context, () => target.apply(this, args))\n\t\t}\n\t\tObject.defineProperty(contextWrapper, 'length', {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t\twritable: false,\n\t\t\tvalue: target.length,\n\t\t})\n\t\t/**\n\t\t * It isn't possible to tell Typescript that contextWrapper is the same as T\n\t\t * so we forced to cast as any here.\n\t\t */\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\treturn contextWrapper as any\n\t}\n\n\t/**\n\t * By default, EventEmitter call their callback with their context, which we do\n\t * not want, instead we will bind a specific context to all callbacks that\n\t * go through it.\n\t * @param context the context we want to bind\n\t * @param ee EventEmitter an instance of EventEmitter to patch\n\t */\n\tprivate _bindEventEmitter<T extends EventEmitter>(context: Context, ee: T): T {\n\t\tconst map = this._getPatchMap(ee)\n\t\tif (map !== undefined) return ee\n\t\tthis._createPatchMap(ee)\n\n\t\t// patch methods that add a listener to propagate context\n\t\tADD_LISTENER_METHODS.forEach((methodName) => {\n\t\t\tif (ee[methodName] === undefined) return\n\t\t\tee[methodName] = this._patchAddListener(ee, ee[methodName], context)\n\t\t})\n\t\t// patch methods that remove a listener\n\t\tif (typeof ee.removeListener === 'function') {\n\t\t\tee.removeListener = this._patchRemoveListener(ee, ee.removeListener)\n\t\t}\n\t\tif (typeof ee.off === 'function') {\n\t\t\tee.off = this._patchRemoveListener(ee, ee.off)\n\t\t}\n\t\t// patch method that remove all listeners\n\t\tif (typeof ee.removeAllListeners === 'function') {\n\t\t\tee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners)\n\t\t}\n\t\treturn ee\n\t}\n\n\t/**\n\t * Patch methods that remove a given listener so that we match the \"patched\"\n\t * version of that listener (the one that propagate context).\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t */\n\tprivate _patchRemoveListener(ee: EventEmitter, original: Function) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\tconst events = contextManager._getPatchMap(ee)?.[event]\n\t\t\tif (events === undefined) {\n\t\t\t\treturn original.call(this, event, listener)\n\t\t\t}\n\t\t\tconst patchedListener = events.get(listener)\n\t\t\treturn original.call(this, event, patchedListener || listener)\n\t\t}\n\t}\n\n\t/**\n\t * Patch methods that remove all listeners so we remove our\n\t * internal references for a given event.\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t */\n\tprivate _patchRemoveAllListeners(ee: EventEmitter, original: Function) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string) {\n\t\t\tconst map = contextManager._getPatchMap(ee)\n\t\t\tif (map !== undefined) {\n\t\t\t\tif (arguments.length === 0) {\n\t\t\t\t\tcontextManager._createPatchMap(ee)\n\t\t\t\t} else if (map[event] !== undefined) {\n\t\t\t\t\tdelete map[event]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn original.apply(this, arguments)\n\t\t}\n\t}\n\n\t/**\n\t * Patch methods on an event emitter instance that can add listeners so we\n\t * can force them to propagate a given context.\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t * @param [context] context to propagate when calling listeners\n\t */\n\tprivate _patchAddListener(ee: EventEmitter, original: Function, context: Context) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\t/**\n\t\t\t * This check is required to prevent double-wrapping the listener.\n\t\t\t * The implementation for ee.once wraps the listener and calls ee.on.\n\t\t\t * Without this check, we would wrap that wrapped listener.\n\t\t\t * This causes an issue because ee.removeListener depends on the onceWrapper\n\t\t\t * to properly remove the listener. If we wrap their wrapper, we break\n\t\t\t * that detection.\n\t\t\t */\n\t\t\tif (contextManager._wrapped) {\n\t\t\t\treturn original.call(this, event, listener)\n\t\t\t}\n\t\t\tlet map = contextManager._getPatchMap(ee)\n\t\t\tif (map === undefined) {\n\t\t\t\tmap = contextManager._createPatchMap(ee)\n\t\t\t}\n\t\t\tlet listeners = map[event]\n\t\t\tif (listeners === undefined) {\n\t\t\t\tlisteners = new WeakMap()\n\t\t\t\tmap[event] = listeners\n\t\t\t}\n\t\t\tconst patchedListener = contextManager.bind(context, listener)\n\t\t\t// store a weak reference of the user listener to ours\n\t\t\tlisteners.set(listener, patchedListener)\n\n\t\t\t/**\n\t\t\t * See comment at the start of this function for the explanation of this property.\n\t\t\t */\n\t\t\tcontextManager._wrapped = true\n\t\t\ttry {\n\t\t\t\treturn original.call(this, event, patchedListener)\n\t\t\t} finally {\n\t\t\t\tcontextManager._wrapped = false\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createPatchMap(ee: EventEmitter): PatchMap {\n\t\tconst map = Object.create(null)\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t;(ee as any)[this._kOtListeners] = map\n\t\treturn map\n\t}\n\tprivate _getPatchMap(ee: EventEmitter): PatchMap | undefined {\n\t\treturn (ee as never)[this._kOtListeners]\n\t}\n\n\tprivate readonly _kOtListeners = Symbol('OtListeners')\n\tprivate _wrapped = false\n}\n\nexport class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager {\n\tprivate _asyncLocalStorage: AsyncLocalStorage<Context>\n\n\tconstructor() {\n\t\tsuper()\n\t\tthis._asyncLocalStorage = new AsyncLocalStorage()\n\t}\n\n\tactive(): Context {\n\t\treturn this._asyncLocalStorage.getStore() ?? ROOT_CONTEXT\n\t}\n\n\twith<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\tcontext: Context,\n\t\tfn: F,\n\t\tthisArg?: ThisParameterType<F>,\n\t\t...args: A\n\t): ReturnType<F> {\n\t\tconst cb = thisArg == null ? fn : fn.bind(thisArg)\n\t\treturn this._asyncLocalStorage.run(context, cb as never, ...args)\n\t}\n\n\tenable(): this {\n\t\treturn this\n\t}\n\n\tdisable(): this {\n\t\tthis._asyncLocalStorage.disable()\n\t\treturn this\n\t}\n}\n","import {\n\tAttributes,\n\tTracer,\n\tTraceFlags,\n\tSpan,\n\tSpanKind,\n\tSpanOptions,\n\tContext,\n\tcontext as api_context,\n\ttrace,\n} from '@opentelemetry/api'\nimport { sanitizeAttributes } from '@opentelemetry/core'\nimport { Resource } from '@opentelemetry/resources'\nimport { SpanProcessor, RandomIdGenerator, ReadableSpan, SamplingDecision } from '@opentelemetry/sdk-trace-base'\n\nimport { SpanImpl } from './span.js'\nimport { getActiveConfig } from './config.js'\n\nlet withNextSpanAttributes: Attributes\n\nexport class WorkerTracer implements Tracer {\n\tprivate readonly _spanProcessors: SpanProcessor[]\n\tprivate readonly resource: Resource\n\tprivate readonly idGenerator: RandomIdGenerator = new RandomIdGenerator()\n\tconstructor(spanProcessors: SpanProcessor[], resource: Resource) {\n\t\tthis._spanProcessors = spanProcessors\n\t\tthis.resource = resource\n\t}\n\n\tget spanProcessors() {\n\t\treturn this._spanProcessors\n\t}\n\n\taddToResource(extra: Resource) {\n\t\tthis.resource.merge(extra)\n\t}\n\n\tstartSpan(name: string, options: SpanOptions = {}, context = api_context.active()): Span {\n\t\tif (options.root) {\n\t\t\tcontext = trace.deleteSpan(context)\n\t\t}\n\t\tconst parentSpan = trace.getSpan(context)\n\t\tconst parentSpanContext = parentSpan?.spanContext()\n\t\tconst hasParentContext = parentSpanContext && trace.isSpanContextValid(parentSpanContext)\n\n\t\tconst traceId = hasParentContext ? parentSpanContext.traceId : this.idGenerator.generateTraceId()\n\t\tconst spanKind = options.kind || SpanKind.INTERNAL\n\t\tconst sanitisedAttrs = sanitizeAttributes(options.attributes)\n\n\t\tconst config = getActiveConfig()\n\t\tif (!config) throw new Error('Config is undefined. This is a bug in the instrumentation logic')\n\n\t\tconst sampler = config.sampling.headSampler\n\t\tconst samplingDecision = sampler.shouldSample(context, traceId, name, spanKind, sanitisedAttrs, [])\n\t\tconst { decision, traceState, attributes: attrs } = samplingDecision\n\n\t\tconst attributes = Object.assign({}, sanitisedAttrs, attrs, withNextSpanAttributes)\n\t\twithNextSpanAttributes = {}\n\n\t\tconst spanId = this.idGenerator.generateSpanId()\n\t\tconst parentSpanId = hasParentContext ? parentSpanContext.spanId : undefined\n\t\tconst traceFlags = decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE\n\t\tconst spanContext = { traceId, spanId, traceFlags, traceState }\n\n\t\tconst span = new SpanImpl({\n\t\t\tattributes,\n\t\t\tname,\n\t\t\tonEnd: (span) => {\n\t\t\t\tthis.spanProcessors.forEach((sp) => {\n\t\t\t\t\tsp.onEnd(span as unknown as ReadableSpan)\n\t\t\t\t})\n\t\t\t},\n\t\t\tresource: this.resource,\n\t\t\tspanContext,\n\t\t\tparentSpanId,\n\t\t\tspanKind,\n\t\t\tstartTime: options.startTime,\n\t\t})\n\t\tthis.spanProcessors.forEach((sp) => {\n\t\t\t//Do not get me started on the idosyncracies of the Otel JS libraries.\n\t\t\t//@ts-ignore\n\t\t\tsp.onStart(span, context)\n\t\t})\n\t\treturn span\n\t}\n\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, fn: F): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, options: SpanOptions, fn: F): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(\n\t\tname: string,\n\t\toptions: SpanOptions,\n\t\tcontext: Context,\n\t\tfn: F,\n\t): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, ...args: unknown[]): ReturnType<F> {\n\t\tconst options = args.length > 1 ? (args[0] as SpanOptions) : undefined\n\t\tconst parentContext = args.length > 2 ? (args[1] as Context) : api_context.active()\n\t\tconst fn = args[args.length - 1] as F\n\n\t\tconst span = this.startSpan(name, options, parentContext)\n\t\tconst contextWithSpanSet = trace.setSpan(parentContext, span)\n\n\t\treturn api_context.with(contextWithSpanSet, fn, undefined, span)\n\t}\n}\n\nexport function withNextSpan(attrs: Attributes) {\n\twithNextSpanAttributes = Object.assign({}, withNextSpanAttributes, attrs)\n}\n","import {\n\tSpanContext,\n\tLink,\n\tSpanKind,\n\tTimeInput,\n\tException,\n\tAttributes,\n\tHrTime,\n\tSpan,\n\tSpanStatus,\n\tSpanStatusCode,\n\tAttributeValue,\n} from '@opentelemetry/api'\nimport {\n\thrTimeDuration,\n\tInstrumentationLibrary,\n\tisAttributeKey,\n\tisAttributeValue,\n\tisTimeInput,\n\tsanitizeAttributes,\n} from '@opentelemetry/core'\nimport { IResource } from '@opentelemetry/resources'\nimport { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\n\ntype OnSpanEnd = (span: Span) => void\n\ninterface SpanInit {\n\tattributes: unknown\n\tname: string\n\tonEnd: OnSpanEnd\n\tresource: IResource\n\tspanContext: SpanContext\n\tlinks?: Link[]\n\tparentSpanId?: string\n\tspanKind?: SpanKind\n\tstartTime?: TimeInput\n}\n\nfunction transformExceptionAttributes(exception: Exception): Attributes {\n\tconst attributes: Attributes = {}\n\tif (typeof exception === 'string') {\n\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception\n\t} else {\n\t\tif (exception.code) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString()\n\t\t} else if (exception.name) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name\n\t\t}\n\t\tif (exception.message) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message\n\t\t}\n\t\tif (exception.stack) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack\n\t\t}\n\t}\n\treturn attributes\n}\n\nfunction millisToHr(millis: number): HrTime {\n\treturn [Math.trunc(millis / 1000), (millis % 1000) * 1e6]\n}\n\nfunction getHrTime(input?: TimeInput): HrTime {\n\tconst now = Date.now()\n\tif (!input) {\n\t\treturn millisToHr(now)\n\t} else if (input instanceof Date) {\n\t\treturn millisToHr(input.getTime())\n\t} else if (typeof input === 'number') {\n\t\t//TODO: do something with performance.now something\n\t\treturn millisToHr(input)\n\t} else if (Array.isArray(input)) {\n\t\treturn input\n\t}\n\n\tconst v: never = input\n\tthrow new Error(`unreachable value: ${JSON.stringify(v)}`)\n}\n\nexport class SpanImpl implements Span, ReadableSpan {\n\tname: string\n\tprivate readonly _spanContext: SpanContext\n\tprivate readonly onEnd: OnSpanEnd\n\treadonly parentSpanId?: string\n\treadonly kind: SpanKind\n\treadonly attributes: Attributes\n\tstatus: SpanStatus = {\n\t\tcode: SpanStatusCode.UNSET,\n\t}\n\tendTime: HrTime = [0, 0]\n\tprivate _duration: HrTime = [0, 0]\n\treadonly startTime: HrTime\n\treadonly events: TimedEvent[] = []\n\treadonly links: Link[]\n\treadonly resource: IResource\n\tinstrumentationLibrary: InstrumentationLibrary = { name: '@microlabs/otel-cf-workers' }\n\tprivate _ended: boolean = false\n\tprivate _droppedAttributesCount: number = 0\n\tprivate _droppedEventsCount: number = 0\n\tprivate _droppedLinksCount: number = 0\n\n\tconstructor(init: SpanInit) {\n\t\tthis.name = init.name\n\t\tthis._spanContext = init.spanContext\n\t\tthis.parentSpanId = init.parentSpanId\n\t\tthis.kind = init.spanKind || SpanKind.INTERNAL\n\t\tthis.attributes = sanitizeAttributes(init.attributes)\n\t\tthis.startTime = getHrTime(init.startTime)\n\t\tthis.links = init.links || []\n\t\tthis.resource = init.resource\n\t\tthis.onEnd = init.onEnd\n\t}\n\n\taddLink(link: Link): this {\n\t\tthis.links.push(link)\n\t\treturn this\n\t}\n\taddLinks(links: Link[]): this {\n\t\tthis.links.push(...links)\n\t\treturn this\n\t}\n\n\tspanContext(): SpanContext {\n\t\treturn this._spanContext\n\t}\n\n\tsetAttribute(key: string, value?: AttributeValue): this {\n\t\tif (isAttributeKey(key) && isAttributeValue(value)) {\n\t\t\tthis.attributes[key] = value\n\t\t}\n\t\treturn this\n\t}\n\n\tsetAttributes(attributes: Attributes): this {\n\t\tfor (const [key, value] of Object.entries(attributes)) {\n\t\t\tthis.setAttribute(key, value)\n\t\t}\n\t\treturn this\n\t}\n\n\taddEvent(name: string, attributesOrStartTime?: Attributes | TimeInput, startTime?: TimeInput): this {\n\t\tif (isTimeInput(attributesOrStartTime)) {\n\t\t\tstartTime = attributesOrStartTime\n\t\t\tattributesOrStartTime = undefined\n\t\t}\n\n\t\tconst attributes = sanitizeAttributes(attributesOrStartTime)\n\t\tconst time = getHrTime(startTime)\n\t\tthis.events.push({ name, attributes, time })\n\t\treturn this\n\t}\n\n\tsetStatus(status: SpanStatus): this {\n\t\tthis.status = status\n\t\treturn this\n\t}\n\n\tupdateName(name: string): this {\n\t\tthis.name = name\n\t\treturn this\n\t}\n\n\tend(endTime?: TimeInput): void {\n\t\tif (this._ended) {\n\t\t\treturn\n\t\t}\n\t\tthis._ended = true\n\t\tthis.endTime = getHrTime(endTime)\n\t\tthis._duration = hrTimeDuration(this.startTime, this.endTime)\n\t\tthis.onEnd(this)\n\t}\n\n\tisRecording(): boolean {\n\t\treturn !this._ended\n\t}\n\n\trecordException(exception: Exception, time?: TimeInput): void {\n\t\tconst attributes = transformExceptionAttributes(exception)\n\t\tthis.addEvent('exception', attributes, time)\n\t}\n\n\tget duration(): HrTime {\n\t\treturn this._duration\n\t}\n\n\tget ended(): boolean {\n\t\treturn this._ended\n\t}\n\n\tget droppedAttributesCount(): number {\n\t\treturn this._droppedAttributesCount\n\t}\n\n\tget droppedEventsCount(): number {\n\t\treturn this._droppedEventsCount\n\t}\n\n\tget droppedLinksCount(): number {\n\t\treturn this._droppedLinksCount\n\t}\n}\n","import {\n\ttrace,\n\tSpanOptions,\n\tSpanKind,\n\tpropagation,\n\tcontext as api_context,\n\tAttributes,\n\tException,\n\tContext,\n\tSpanStatusCode,\n} from '@opentelemetry/api'\nimport { Initialiser, getActiveConfig, setConfig } from '../config.js'\nimport { wrap } from '../wrap.js'\nimport { instrumentEnv } from './env.js'\nimport { exportSpans, proxyExecutionContext } from './common.js'\nimport { ResolvedTraceConfig } from '../types.js'\nimport { ReadableSpan } from '@opentelemetry/sdk-trace-base'\nimport { versionAttributes } from './version.js'\n\nexport type IncludeTraceContextFn = (request: Request) => boolean\nexport interface FetcherConfig {\n\tincludeTraceContext?: boolean | IncludeTraceContextFn\n}\n\nexport type AcceptTraceContextFn = (request: Request) => boolean\nexport interface FetchHandlerConfig {\n\t/**\n\t * Whether to enable context propagation for incoming requests to `fetch`.\n\t * This enables or disables distributed tracing from W3C Trace Context headers.\n\t * @default true\n\t */\n\tacceptTraceContext?: boolean | AcceptTraceContextFn\n}\n\ntype FetchHandler = ExportedHandlerFetchHandler\ntype FetchHandlerArgs = Parameters<FetchHandler>\n\nconst netKeysFromCF = new Set(['colo', 'country', 'request_priority', 'tls_cipher', 'tls_version', 'asn', 'tcp_rtt'])\n\nconst camelToSnakeCase = (s: string): string => {\n\treturn s.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n}\n\nconst gatherOutgoingCfAttributes = (cf: RequestInitCfProperties): Attributes => {\n\tconst attrs: Record<string, string | number> = {}\n\tObject.keys(cf).forEach((key) => {\n\t\tconst value = cf[key]\n\t\tconst destKey = camelToSnakeCase(key)\n\t\tif (!netKeysFromCF.has(destKey)) {\n\t\t\tif (typeof value === 'string' || typeof value === 'number') {\n\t\t\t\tattrs[`cf.${destKey}`] = value\n\t\t\t} else {\n\t\t\t\tattrs[`cf.${destKey}`] = JSON.stringify(value)\n\t\t\t}\n\t\t}\n\t})\n\treturn attrs\n}\n\nexport function gatherRequestAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tconst headers = request.headers\n\tattrs['http.request.method'] = request.method.toUpperCase()\n\tattrs['network.protocol.name'] = 'http'\n\tattrs['network.protocol.version'] = request.cf?.httpProtocol as string\n\tattrs['http.request.body.size'] = headers.get('content-length')!\n\tattrs['user_agent.original'] = headers.get('user-agent')!\n\tattrs['http.mime_type'] = headers.get('content-type')!\n\tattrs['http.accepts'] = request.cf?.clientAcceptEncoding as string\n\n\tconst u = new URL(request.url)\n\tattrs['url.full'] = `${u.protocol}//${u.host}${u.pathname}${u.search}`\n\tattrs['server.address'] = u.host\n\tattrs['url.scheme'] = u.protocol\n\tattrs['url.path'] = u.pathname\n\tattrs['url.query'] = u.search\n\n\treturn attrs\n}\n\nexport function gatherResponseAttributes(response: Response): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tattrs['http.response.status_code'] = response.status\n\tif (response.headers.get('content-length')! == null) {\n\t\tattrs['http.response.body.size'] = response.headers.get('content-length')!\n\t}\n\tattrs['http.mime_type'] = response.headers.get('content-type')!\n\treturn attrs\n}\n\nexport function gatherIncomingCfAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tattrs['net.colo'] = request.cf?.colo as string\n\tattrs['net.country'] = request.cf?.country as string\n\tattrs['net.request_priority'] = request.cf?.requestPriority as string\n\tattrs['net.tls_cipher'] = request.cf?.tlsCipher as string\n\tattrs['net.tls_version'] = request.cf?.tlsVersion as string\n\tattrs['net.asn'] = request.cf?.asn as number\n\tattrs['net.tcp_rtt'] = request.cf?.clientTcpRtt as number\n\treturn attrs\n}\n\nexport function getParentContextFromHeaders(headers: Headers): Context {\n\treturn propagation.extract(api_context.active(), headers, {\n\t\tget(headers, key) {\n\t\t\treturn headers.get(key) || undefined\n\t\t},\n\t\tkeys(headers) {\n\t\t\treturn [...headers.keys()]\n\t\t},\n\t})\n}\n\nexport function getParentContextFromRequest(request: Request) {\n\tconst workerConfig = getActiveConfig()\n\n\tif (workerConfig === undefined) {\n\t\treturn api_context.active()\n\t}\n\n\tconst acceptTraceContext =\n\t\ttypeof workerConfig.handlers.fetch.acceptTraceContext === 'function'\n\t\t\t? workerConfig.handlers.fetch.acceptTraceContext(request)\n\t\t\t: (workerConfig.handlers.fetch.acceptTraceContext ?? true)\n\treturn acceptTraceContext ? getParentContextFromHeaders(request.headers) : api_context.active()\n}\n\nexport function waitUntilTrace(fn: () => Promise<any>): Promise<void> {\n\tconst tracer = trace.getTracer('waitUntil')\n\treturn tracer.startActiveSpan('waitUntil', async (span) => {\n\t\tawait fn()\n\t\tspan.end()\n\t})\n}\n\nlet cold_start = true\nexport function executeFetchHandler(fetchFn: FetchHandler, [request, env, ctx]: FetchHandlerArgs): Promise<Response> {\n\tconst spanContext = getParentContextFromRequest(request)\n\n\tconst tracer = trace.getTracer('fetchHandler')\n\tconst attributes = {\n\t\t['faas.trigger']: 'http',\n\t\t['faas.coldstart']: cold_start,\n\t\t['faas.invocation_id']: request.headers.get('cf-ray') ?? undefined,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\tObject.assign(attributes, versionAttributes(env))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst method = request.method.toUpperCase()\n\tconst promise = tracer.startActiveSpan(`fetchHandler ${method}`, options, spanContext, async (span) => {\n\t\tconst readable = span as unknown as ReadableSpan\n\t\ttry {\n\t\t\tconst response = await fetchFn(request, env, ctx)\n\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\n\t\t\treturn response\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tif (readable.attributes['http.route']) {\n\t\t\t\tspan.updateName(`fetchHandler ${method} ${readable.attributes['http.route']}`)\n\t\t\t}\n\t\t\tspan.end()\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function createFetchHandler(fetchFn: FetchHandler, initialiser: Initialiser) {\n\tconst fetchHandler: ProxyHandler<FetchHandler> = {\n\t\tapply: async (target, _thisArg, argArray: Parameters<FetchHandler>): Promise<Response> => {\n\t\t\tconst [request, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, request)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: FetchHandlerArgs = [request, env, ctx]\n\t\t\t\treturn await api_context.with(context, executeFetchHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetchFn, fetchHandler)\n}\n\ntype getFetchConfig = (config: ResolvedTraceConfig) => FetcherConfig\nexport function instrumentClientFetch(\n\tfetchFn: Fetcher['fetch'],\n\tconfigFn: getFetchConfig,\n\tattrs?: Attributes,\n): Fetcher['fetch'] {\n\tconst handler: ProxyHandler<Fetcher['fetch']> = {\n\t\tapply: (target, thisArg, argArray): Response | Promise<Response> => {\n\t\t\tconst request = new Request(argArray[0], argArray[1])\n\t\t\tif (!request.url.startsWith('http')) {\n\t\t\t\treturn Reflect.apply(target, thisArg, argArray)\n\t\t\t}\n\n\t\t\tconst workerConfig = getActiveConfig()\n\t\t\tif (!workerConfig) {\n\t\t\t\treturn Reflect.apply(target, thisArg, [request])\n\t\t\t}\n\t\t\tconst config = configFn(workerConfig)\n\n\t\t\tconst tracer = trace.getTracer('fetcher')\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes: attrs }\n\n\t\t\tconst host = new URL(request.url).host\n\t\t\tconst method = request.method.toUpperCase()\n\t\t\tconst spanName = typeof attrs?.['name'] === 'string' ? attrs?.['name'] : `fetch ${method} ${host}`\n\t\t\tconst promise = tracer.startActiveSpan(spanName, options, async (span) => {\n\t\t\t\tconst includeTraceContext =\n\t\t\t\t\ttypeof config.includeTraceContext === 'function'\n\t\t\t\t\t\t? config.includeTraceContext(request)\n\t\t\t\t\t\t: config.includeTraceContext\n\t\t\t\tif (includeTraceContext ?? true) {\n\t\t\t\t\tpropagation.inject(api_context.active(), request.headers, {\n\t\t\t\t\t\tset: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tspan.setAttributes(gatherRequestAttributes(request))\n\t\t\t\tif (request.cf) span.setAttributes(gatherOutgoingCfAttributes(request.cf))\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await Reflect.apply(target, thisArg, [request])\n\t\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\t\treturn response\n\t\t\t\t} catch (err) {\n\t\t\t\t\tspan?.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\tthrow err\n\t\t\t\t} finally {\n\t\t\t\t\tspan.end()\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn promise\n\t\t},\n\t}\n\treturn wrap(fetchFn, handler, true)\n}\n\nexport function instrumentGlobalFetch(): void {\n\t//@ts-ignore For some reason the node types are imported and complain.\n\tglobalThis.fetch = instrumentClientFetch(globalThis.fetch, (config) => config.fetch)\n}\n","import { context as api_context, trace, SpanOptions, SpanKind, Exception, SpanStatusCode } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { passthroughGet, unwrap, wrap } from '../wrap.js'\nimport {\n\tgetParentContextFromHeaders,\n\tgatherIncomingCfAttributes,\n\tgatherRequestAttributes,\n\tgatherResponseAttributes,\n\tinstrumentClientFetch,\n} from './fetch.js'\nimport { instrumentEnv } from './env.js'\nimport { Initialiser, setConfig } from '../config.js'\nimport { exportSpans } from './common.js'\nimport { instrumentStorage } from './do-storage.js'\nimport { DOConstructorTrigger } from '../types.js'\n\ntype FetchFn = DurableObject['fetch']\ntype AlarmFn = DurableObject['alarm']\ntype Env = Record<string, unknown>\n\nfunction instrumentBindingStub(stub: DurableObjectStub, nsName: string): DurableObjectStub {\n\tconst stubHandler: ProxyHandler<typeof stub> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetcher = Reflect.get(target, prop)\n\t\t\t\tconst attrs = {\n\t\t\t\t\tname: `Durable Object ${nsName}`,\n\t\t\t\t\t'do.namespace': nsName,\n\t\t\t\t\t'do.id': target.id.toString(),\n\t\t\t\t\t'do.id.name': target.id.name,\n\t\t\t\t}\n\t\t\t\treturn instrumentClientFetch(fetcher, () => ({ includeTraceContext: true }), attrs)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(stub, stubHandler)\n}\n\nfunction instrumentBindingGet(getFn: DurableObjectNamespace['get'], nsName: string): DurableObjectNamespace['get'] {\n\tconst getHandler: ProxyHandler<DurableObjectNamespace['get']> = {\n\t\tapply(target, thisArg, argArray) {\n\t\t\tconst stub: DurableObjectStub = Reflect.apply(target, thisArg, argArray)\n\t\t\treturn instrumentBindingStub(stub, nsName)\n\t\t},\n\t}\n\treturn wrap(getFn, getHandler)\n}\n\nexport function instrumentDOBinding(ns: DurableObjectNamespace, nsName: string) {\n\tconst nsHandler: ProxyHandler<typeof ns> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'get') {\n\t\t\t\tconst fn = Reflect.get(ns, prop)\n\t\t\t\treturn instrumentBindingGet(fn, nsName)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(ns, nsHandler)\n}\n\nexport function instrumentState(state: DurableObjectState) {\n\tconst stateHandler: ProxyHandler<DurableObjectState> = {\n\t\tget(target, prop, receiver) {\n\t\t\tconst result = Reflect.get(target, prop, unwrap(receiver))\n\t\t\tif (prop === 'storage') {\n\t\t\t\treturn instrumentStorage(result)\n\t\t\t} else if (typeof result === 'function') {\n\t\t\t\treturn result.bind(target)\n\t\t\t} else {\n\t\t\t\treturn result\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(state, stateHandler)\n}\n\nlet cold_start = true\nexport type DOClass = { new (state: DurableObjectState, env: any): DurableObject }\nexport function executeDOFetch(fetchFn: FetchFn, request: Request, id: DurableObjectId): Promise<Response> {\n\tconst spanContext = getParentContextFromHeaders(request.headers)\n\n\tconst tracer = trace.getTracer('DO fetchHandler')\n\tconst attributes = {\n\t\t[SemanticAttributes.FAAS_TRIGGER]: 'http',\n\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst name = id.name || ''\n\tconst promise = tracer.startActiveSpan(`Durable Object Fetch ${name}`, options, spanContext, async (span) => {\n\t\ttry {\n\t\t\tconst response: Response = await fetchFn(request)\n\t\t\tif (response.ok) {\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t}\n\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\tspan.end()\n\n\t\t\treturn response\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function executeDOAlarm(alarmFn: NonNullable<AlarmFn>, id: DurableObjectId): Promise<void> {\n\tconst tracer = trace.getTracer('DO alarmHandler')\n\n\tconst name = id.name || ''\n\tconst promise = tracer.startActiveSpan(`Durable Object Alarm ${name}`, async (span) => {\n\t\tspan.setAttribute(SemanticAttributes.FAAS_COLDSTART, cold_start)\n\t\tcold_start = false\n\t\tspan.setAttribute('do.id', id.toString())\n\t\tif (id.name) span.setAttribute('do.name', id.name)\n\n\t\ttry {\n\t\t\tawait alarmFn()\n\t\t\tspan.end()\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n\nfunction instrumentFetchFn(fetchFn: FetchFn, initialiser: Initialiser, env: Env, id: DurableObjectId): FetchFn {\n\tconst fetchHandler: ProxyHandler<FetchFn> = {\n\t\tasync apply(target, thisArg, argArray: Parameters<FetchFn>) {\n\t\t\tconst request = argArray[0]\n\t\t\tconst config = initialiser(env, request)\n\t\t\tconst context = setConfig(config)\n\t\t\ttry {\n\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\treturn await api_context.with(context, executeDOFetch, undefined, bound, request, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\texportSpans()\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetchFn, fetchHandler)\n}\n\nfunction instrumentAlarmFn(alarmFn: AlarmFn, initialiser: Initialiser, env: Env, id: DurableObjectId) {\n\tif (!alarmFn) return undefined\n\n\tconst alarmHandler: ProxyHandler<NonNullable<AlarmFn>> = {\n\t\tasync apply(target, thisArg) {\n\t\t\tconst config = initialiser(env, 'do-alarm')\n\t\t\tconst context = setConfig(config)\n\t\t\ttry {\n\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\treturn await api_context.with(context, executeDOAlarm, undefined, bound, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\texportSpans()\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(alarmFn, alarmHandler)\n}\n\nfunction instrumentDurableObject(doObj: DurableObject, initialiser: Initialiser, env: Env, state: DurableObjectState) {\n\tconst objHandler: ProxyHandler<DurableObject> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetchFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentFetchFn(fetchFn, initialiser, env, state.id)\n\t\t\t} else if (prop === 'alarm') {\n\t\t\t\tconst alarmFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentAlarmFn(alarmFn, initialiser, env, state.id)\n\t\t\t} else {\n\t\t\t\tconst result = Reflect.get(target, prop)\n\t\t\t\tif (typeof result === 'function') {\n\t\t\t\t\tresult.bind(doObj)\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(doObj, objHandler)\n}\n\nexport function instrumentDOClass(doClass: DOClass, initialiser: Initialiser): DOClass {\n\tconst classHandler: ProxyHandler<DOClass> = {\n\t\tconstruct(target, [orig_state, orig_env]: ConstructorParameters<DOClass>) {\n\t\t\tconst trigger: DOConstructorTrigger = {\n\t\t\t\tid: orig_state.id.toString(),\n\t\t\t\tname: orig_state.id.name,\n\t\t\t}\n\t\t\tconst constructorConfig = initialiser(orig_env, trigger)\n\t\t\tconst context = setConfig(constructorConfig)\n\t\t\tconst state = instrumentState(orig_state)\n\t\t\tconst env = instrumentEnv(orig_env)\n\t\t\tconst createDO = () => {\n\t\t\t\treturn new target(state, env)\n\t\t\t}\n\t\t\tconst doObj = api_context.with(context, createDO)\n\n\t\t\treturn instrumentDurableObject(doObj, initialiser, env, state)\n\t\t},\n\t}\n\treturn wrap(doClass, classHandler)\n}\n","import { trace } from '@opentelemetry/api'\nimport { WorkerTracer } from '../tracer.js'\nimport { passthroughGet, wrap } from '../wrap.js'\n\ntype ContextAndTracker = { ctx: ExecutionContext; tracker: PromiseTracker }\ntype WaitUntilFn = ExecutionContext['waitUntil']\n\nexport class PromiseTracker {\n\t_outstandingPromises: Promise<unknown>[] = []\n\n\tget outstandingPromiseCount() {\n\t\treturn this._outstandingPromises.length\n\t}\n\n\ttrack(promise: Promise<unknown>): void {\n\t\tthis._outstandingPromises.push(promise)\n\t}\n\n\tasync wait() {\n\t\tawait allSettledMutable(this._outstandingPromises)\n\t}\n}\n\nfunction createWaitUntil(fn: WaitUntilFn, context: ExecutionContext, tracker: PromiseTracker): WaitUntilFn {\n\tconst handler: ProxyHandler<WaitUntilFn> = {\n\t\tapply(target, _thisArg, argArray) {\n\t\t\ttracker.track(argArray[0])\n\t\t\treturn Reflect.apply(target, context, argArray)\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nexport function proxyExecutionContext(context: ExecutionContext): ContextAndTracker {\n\tconst tracker = new PromiseTracker()\n\tconst ctx = new Proxy(context, {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'waitUntil') {\n\t\t\t\tconst fn = Reflect.get(target, prop)\n\t\t\t\treturn createWaitUntil(fn, context, tracker)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t})\n\treturn { ctx, tracker }\n}\n\nexport async function exportSpans(tracker?: PromiseTracker) {\n\tconst tracer = trace.getTracer('export')\n\tif (tracer instanceof WorkerTracer) {\n\t\t// await scheduler.wait(1)\n\t\tif (tracker) {\n\t\t\tawait tracker.wait()\n\t\t}\n\t\tconst promises = tracer.spanProcessors.map(async (spanProcessor) => {\n\t\t\tawait spanProcessor.forceFlush()\n\t\t})\n\t\tawait Promise.allSettled(promises)\n\t} else {\n\t\tconsole.error('The global tracer is not of type WorkerTracer and can not export spans')\n\t}\n}\n\n/** Like `Promise.allSettled`, but handles modifications to the promises array */\nasync function allSettledMutable(promises: Promise<unknown>[]): Promise<PromiseSettledResult<unknown>[]> {\n\tlet values: PromiseSettledResult<unknown>[]\n\t// when the length of the array changes, there has been a nested call to waitUntil\n\t// and we should await the promises again\n\tdo {\n\t\tvalues = await Promise.allSettled(promises)\n\t} while (values.length !== promises.length)\n\treturn values\n}\n\n/** Overloads extracts up to 4 overloads for the given function. */\nexport type Overloads<T> = T extends {\n\t(...args: infer P1): infer R1\n\t(...args: infer P2): infer R2\n\t(...args: infer P3): infer R3\n\t(...args: infer P4): infer R4\n}\n\t? ((...args: P1) => R1) | ((...args: P2) => R2) | ((...args: P3) => R3) | ((...args: P4) => R4)\n\t: never\n","import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\nimport { Overloads } from './common.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst dbSystem = 'Cloudflare DO'\n\ntype DurableObjectCommonOptions = Pick<DurableObjectPutOptions, 'allowConcurrency' | 'allowUnconfirmed' | 'noCache'>\nfunction isDurableObjectCommonOptions(options: any): options is DurableObjectCommonOptions {\n\treturn (\n\t\ttypeof options === 'object' &&\n\t\t('allowConcurrency' in options || 'allowUnconfirmed' in options || 'noCache' in options)\n\t)\n}\n\n/** Applies attributes for common Durable Objects options:\n * `allowConcurrency`, `allowUnconfirmed`, and `noCache`\n */\nfunction applyOptionsAttributes(attrs: Attributes, options: DurableObjectCommonOptions) {\n\tif ('allowConcurrency' in options) {\n\t\tattrs['db.cf.do.allow_concurrency'] = options.allowConcurrency\n\t}\n\tif ('allowUnconfirmed' in options) {\n\t\tattrs['db.cf.do.allow_unconfirmed'] = options.allowUnconfirmed\n\t}\n\tif ('noCache' in options) {\n\t\tattrs['db.cf.do.no_cache'] = options.noCache\n\t}\n}\n\nconst StorageAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\tdelete(argArray, result: Awaited<ReturnType<Overloads<DurableObjectStorage['delete']>>>) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['delete']>>\n\t\tlet attrs: Attributes = {}\n\t\tif (Array.isArray(args[0])) {\n\t\t\tconst keys = args[0]\n\t\t\tattrs = {\n\t\t\t\t// todo: Maybe set db.cf.do.keys to the whole array here?\n\t\t\t\t'db.cf.do.key': keys[0],\n\t\t\t\t'db.cf.do.number_of_keys': keys.length,\n\t\t\t\t'db.cf.do.keys_deleted': result,\n\t\t\t}\n\t\t} else {\n\t\t\tattrs = {\n\t\t\t\t'db.cf.do.key': args[0],\n\t\t\t\t'db.cf.do.success': result,\n\t\t\t}\n\t\t}\n\t\tif (args[1]) {\n\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tdeleteAll(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['deleteAll']>>\n\t\tlet attrs: Attributes = {}\n\t\tif (args[0]) {\n\t\t\tapplyOptionsAttributes(attrs, args[0])\n\t\t}\n\t\treturn attrs\n\t},\n\tget(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['get']>>\n\t\tlet attrs: Attributes = {}\n\t\tif (Array.isArray(args[0])) {\n\t\t\tconst keys = args[0]\n\t\t\tattrs = {\n\t\t\t\t// todo: Maybe set db.cf.do.keys to the whole array here?\n\t\t\t\t'db.cf.do.key': keys[0],\n\t\t\t\t'db.cf.do.number_of_keys': keys.length,\n\t\t\t}\n\t\t} else {\n\t\t\tattrs = {\n\t\t\t\t'db.cf.do.key': args[0],\n\t\t\t}\n\t\t}\n\t\tif (args[1]) {\n\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tlist(argArray, result: Awaited<ReturnType<Overloads<DurableObjectStorage['list']>>>) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['list']>>\n\t\tconst attrs: Attributes = {\n\t\t\t'db.cf.do.number_of_results': result.size,\n\t\t}\n\t\tif (args[0]) {\n\t\t\tconst options = args[0]\n\t\t\tapplyOptionsAttributes(attrs, options)\n\t\t\tif ('start' in options) {\n\t\t\t\tattrs['db.cf.do.start'] = options.start\n\t\t\t}\n\t\t\tif ('startAfter' in options) {\n\t\t\t\tattrs['db.cf.do.start_after'] = options.startAfter\n\t\t\t}\n\t\t\tif ('end' in options) {\n\t\t\t\tattrs['db.cf.do.end'] = options.end\n\t\t\t}\n\t\t\tif ('prefix' in options) {\n\t\t\t\tattrs['db.cf.do.prefix'] = options.prefix\n\t\t\t}\n\t\t\tif ('reverse' in options) {\n\t\t\t\tattrs['db.cf.do.reverse'] = options.reverse\n\t\t\t}\n\t\t\tif ('limit' in options) {\n\t\t\t\tattrs['db.cf.do.limit'] = options.limit\n\t\t\t}\n\t\t}\n\t\treturn attrs\n\t},\n\tput(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['put']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (typeof args[0] === 'string') {\n\t\t\tattrs['db.cf.do.key'] = args[0]\n\t\t\tif (args[2]) {\n\t\t\t\tapplyOptionsAttributes(attrs, args[2])\n\t\t\t}\n\t\t} else {\n\t\t\tconst keys = Object.keys(args[0])\n\t\t\t// todo: Maybe set db.cf.do.keys to the whole array here?\n\t\t\tattrs['db.cf.do.key'] = keys[0]\n\t\t\tattrs['db.cf.do.number_of_keys'] = keys.length\n\t\t\tif (isDurableObjectCommonOptions(args[1])) {\n\t\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t\t}\n\t\t}\n\t\treturn attrs\n\t},\n\tgetAlarm(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['getAlarm']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (args[0]) {\n\t\t\tapplyOptionsAttributes(attrs, args[0])\n\t\t}\n\t\treturn attrs\n\t},\n\tsetAlarm(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['setAlarm']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (args[0] instanceof Date) {\n\t\t\tattrs['db.cf.do.alarm_time'] = args[0].getTime()\n\t\t} else {\n\t\t\tattrs['db.cf.do.alarm_time'] = args[0]\n\t\t}\n\t\tif (args[1]) {\n\t\t\tapplyOptionsAttributes(attrs, args[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tdeleteAlarm(argArray) {\n\t\tconst args = argArray as Parameters<Overloads<DurableObjectStorage['deleteAlarm']>>\n\t\tconst attrs: Attributes = {}\n\t\tif (args[0]) {\n\t\t\tapplyOptionsAttributes(attrs, args[0])\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentStorageFn(fn: Function, operation: string) {\n\tconst tracer = trace.getTracer('do_storage')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst attributes = {\n\t\t\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t\t\t\t[SemanticAttributes.DB_STATEMENT]: `${operation} ${argArray[0]}`,\n\t\t\t}\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes: {\n\t\t\t\t\t...attributes,\n\t\t\t\t\toperation,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`Durable Object Storage ${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrsFn = StorageAttributes[operation]\n\t\t\t\tconst extraAttrs = extraAttrsFn ? extraAttrsFn(argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tspan.setAttribute('db.cf.do.has_result', !!result)\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentStorage(storage: DurableObjectStorage): DurableObjectStorage {\n\tconst storageHandler: ProxyHandler<DurableObjectStorage> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentStorageFn(fn, operation)\n\t\t},\n\t}\n\treturn wrap(storage, storageHandler)\n}\n","import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst dbSystem = 'Cloudflare KV'\n\nconst KVAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\tdelete(_argArray) {\n\t\treturn {}\n\t},\n\tget(argArray) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts = argArray[1]\n\t\tif (typeof opts === 'string') {\n\t\t\tattrs['db.cf.kv.type'] = opts\n\t\t} else if (typeof opts === 'object') {\n\t\t\tattrs['db.cf.kv.type'] = opts.type\n\t\t\tattrs['db.cf.kv.cache_ttl'] = opts.cacheTtl\n\t\t}\n\t\treturn attrs\n\t},\n\tgetWithMetadata(argArray, result) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts = argArray[1]\n\t\tif (typeof opts === 'string') {\n\t\t\tattrs['db.cf.kv.type'] = opts\n\t\t} else if (typeof opts === 'object') {\n\t\t\tattrs['db.cf.kv.type'] = opts.type\n\t\t\tattrs['db.cf.kv.cache_ttl'] = opts.cacheTtl\n\t\t}\n\n\t\tattrs['db.cf.kv.metadata'] = true\n\t\tconst { cacheStatus } = result as KVNamespaceGetWithMetadataResult<any, any>\n\t\tif (typeof cacheStatus === 'string') {\n\t\t\tattrs['db.cf.kv.cache_status'] = cacheStatus\n\t\t}\n\t\treturn attrs\n\t},\n\tlist(argArray, result) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts: KVNamespaceListOptions = argArray[0] || {}\n\t\tconst { cursor, limit } = opts\n\t\tattrs['db.cf.kv.list_request_cursor'] = cursor || undefined\n\t\tattrs['db.cf.kv.list_limit'] = limit || undefined\n\t\tconst { list_complete, cacheStatus } = result as KVNamespaceListResult<any, any>\n\t\tattrs['db.cf.kv.list_complete'] = list_complete || undefined\n\t\tif (!list_complete) {\n\t\t\tattrs['db.cf.kv.list_response_cursor'] = cursor || undefined\n\t\t}\n\t\tif (typeof cacheStatus === 'string') {\n\t\t\tattrs['db.cf.kv.cache_status'] = cacheStatus\n\t\t}\n\t\treturn attrs\n\t},\n\tput(argArray) {\n\t\tconst attrs: Attributes = {}\n\t\tif (argArray.length > 2 && argArray[2]) {\n\t\t\tconst { expiration, expirationTtl, metadata } = argArray[2] as KVNamespacePutOptions\n\t\t\tattrs['db.cf.kv.expiration'] = expiration\n\t\t\tattrs['db.cf.kv.expiration_ttl'] = expirationTtl\n\t\t\tattrs['db.cf.kv.metadata'] = !!metadata\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentKVFn(fn: Function, name: string, operation: string) {\n\tconst tracer = trace.getTracer('KV')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst attributes = {\n\t\t\t\tbinding_type: 'KV',\n\t\t\t\t[SemanticAttributes.DB_NAME]: name,\n\t\t\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t\t\t}\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes,\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`KV ${name} ${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrsFn = KVAttributes[operation]\n\t\t\t\tconst extraAttrs = extraAttrsFn ? extraAttrsFn(argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tif (operation === 'list') {\n\t\t\t\t\tconst opts: KVNamespaceListOptions = argArray[0] || {}\n\t\t\t\t\tconst { prefix } = opts\n\t\t\t\t\tspan.setAttribute(SemanticAttributes.DB_STATEMENT, `${operation} ${prefix || undefined}`)\n\t\t\t\t} else {\n\t\t\t\t\tspan.setAttribute(SemanticAttributes.DB_STATEMENT, `${operation} ${argArray[0]}`)\n\t\t\t\t\tspan.setAttribute('db.cf.kv.key', argArray[0])\n\t\t\t\t}\n\t\t\t\tif (operation === 'getWithMetadata') {\n\t\t\t\t\tconst hasResults = !!result && !!(result as KVNamespaceGetWithMetadataResult<string, unknown>).value\n\t\t\t\t\tspan.setAttribute('db.cf.kv.has_result', hasResults)\n\t\t\t\t} else {\n\t\t\t\t\tspan.setAttribute('db.cf.kv.has_result', !!result)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentKV(kv: KVNamespace, name: string): KVNamespace {\n\tconst kvHandler: ProxyHandler<KVNamespace> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentKVFn(fn, name, operation)\n\t\t},\n\t}\n\treturn wrap(kv, kvHandler)\n}\n","import {\n\ttrace,\n\tSpanOptions,\n\tSpanKind,\n\tAttributes,\n\tException,\n\tcontext as api_context,\n\tpropagation,\n} from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { Initialiser, setConfig } from '../config.js'\nimport { exportSpans, proxyExecutionContext } from './common.js'\nimport { instrumentEnv } from './env.js'\nimport { unwrap, wrap } from '../wrap.js'\nimport { versionAttributes } from './version.js'\n\ntype QueueHandler = ExportedHandlerQueueHandler<unknown, unknown>\nexport type QueueHandlerArgs = Parameters<QueueHandler>\n\nconst traceIdSymbol = Symbol('traceId')\n\nclass MessageStatusCount {\n\tsucceeded = 0\n\tfailed = 0\n\treadonly total: number\n\tconstructor(total: number) {\n\t\tthis.total = total\n\t}\n\n\tack() {\n\t\tthis.succeeded = this.succeeded + 1\n\t}\n\n\tackRemaining() {\n\t\tthis.succeeded = this.total - this.failed\n\t}\n\n\tretry() {\n\t\tthis.failed = this.failed + 1\n\t}\n\n\tretryRemaining() {\n\t\tthis.failed = this.total - this.succeeded\n\t}\n\n\ttoAttributes(): Attributes {\n\t\treturn {\n\t\t\t'queue.messages_count': this.total,\n\t\t\t'queue.messages_success': this.succeeded,\n\t\t\t'queue.messages_failed': this.failed,\n\t\t\t'queue.batch_success': this.succeeded === this.total,\n\t\t}\n\t}\n}\n\nconst addEvent = (name: string, msg?: Message) => {\n\tconst attrs: Attributes = {}\n\tif (msg) {\n\t\tattrs['queue.message_id'] = msg.id\n\t\tattrs['queue.message_timestamp'] = msg.timestamp.toISOString()\n\t}\n\ttrace.getActiveSpan()?.addEvent(name, attrs)\n}\n\nconst proxyQueueMessage = <Q>(msg: Message<Q>, count: MessageStatusCount): Message<Q> => {\n\tconst msgHandler: ProxyHandler<Message<Q>> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'ack') {\n\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('messageAck', msg)\n\t\t\t\t\t\tcount.ack()\n\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, msg, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else if (prop === 'retry') {\n\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('messageRetry', msg)\n\t\t\t\t\t\tcount.retry()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tconst result = Reflect.apply(fnTarget, msg, [])\n\t\t\t\t\t\treturn result\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop, msg)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(msg, msgHandler)\n}\n\nconst proxyMessageBatch = (batch: MessageBatch, count: MessageStatusCount) => {\n\tconst batchHandler: ProxyHandler<MessageBatch> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'messages') {\n\t\t\t\tconst messages = Reflect.get(target, prop)\n\t\t\t\tconst messagesHandler: ProxyHandler<MessageBatch['messages']> = {\n\t\t\t\t\tget: (target, prop) => {\n\t\t\t\t\t\tif (typeof prop === 'string' && !isNaN(parseInt(prop))) {\n\t\t\t\t\t\t\tconst message = Reflect.get(target, prop)\n\t\t\t\t\t\t\treturn proxyQueueMessage(message, count)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn wrap(messages, messagesHandler)\n\t\t\t} else if (prop === 'ackAll') {\n\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('ackAll')\n\t\t\t\t\t\tcount.ackRemaining()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else if (prop === 'retryAll') {\n\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('retryAll')\n\t\t\t\t\t\tcount.retryRemaining()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop)\n\t\t},\n\t}\n\treturn wrap(batch, batchHandler)\n}\n\nexport function executeQueueHandler(queueFn: QueueHandler, [batch, env, ctx]: QueueHandlerArgs): Promise<void> {\n\tconst count = new MessageStatusCount(batch.messages.length)\n\tbatch = proxyMessageBatch(batch, count)\n\tconst tracer = trace.getTracer('queueHandler')\n\tconst options: SpanOptions = {\n\t\tattributes: {\n\t\t\t[SemanticAttributes.FAAS_TRIGGER]: 'pubsub',\n\t\t\t'queue.name': batch.queue,\n\t\t},\n\t\tkind: SpanKind.CONSUMER,\n\t}\n\tObject.assign(options.attributes!, versionAttributes(env))\n\tconst promise = tracer.startActiveSpan(`queueHandler ${batch.queue}`, options, async (span) => {\n\t\tconst traceId = span.spanContext().traceId\n\t\tapi_context.active().setValue(traceIdSymbol, traceId)\n\t\ttry {\n\t\t\tconst result = await queueFn(batch, env, ctx)\n\t\t\tspan.setAttribute('queue.implicitly_acked', count.total - count.succeeded - count.failed)\n\t\t\tcount.ackRemaining()\n\t\t\tspan.setAttributes(count.toAttributes())\n\t\t\treturn result\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setAttribute('queue.implicitly_retried', count.total - count.succeeded - count.failed)\n\t\t\tcount.retryRemaining()\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tspan.end()\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function createQueueHandler(queueFn: QueueHandler, initialiser: Initialiser) {\n\tconst queueHandler: ProxyHandler<QueueHandler> = {\n\t\tasync apply(target, _thisArg, argArray: Parameters<QueueHandler>): Promise<void> {\n\t\t\tconst [batch, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, batch)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: QueueHandlerArgs = [batch, env, ctx]\n\n\t\t\t\treturn await api_context.with(context, executeQueueHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(queueFn, queueHandler)\n}\n\ntype SimpleQueueRequest = {\n\tmetadata: Record<string, string>\n}\n\nfunction propagateContext(argArray: unknown[]) {\n\tconst shouldPropagate = argArray?.length > 0 && typeof argArray[0] === 'object'\n\n\tconst request = shouldPropagate ? (argArray[0] as SimpleQueueRequest) : undefined\n\tif (request) {\n\t\trequest.metadata = request.metadata ? request.metadata : {}\n\t}\n\tif (request) {\n\t\tpropagation.inject(api_context.active(), request.metadata, {\n\t\t\tset: (h, k, v) => (h[k] = typeof v === 'string' ? v : String(v)),\n\t\t})\n\t}\n}\n\nfunction instrumentQueueSend(fn: Queue<unknown>['send'], name: string): Queue<unknown>['send'] {\n\tconst tracer = trace.getTracer('queueSender')\n\tconst handler: ProxyHandler<Queue<unknown>['send']> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\treturn tracer.startActiveSpan(`Queues ${name} send`, async (span) => {\n\t\t\t\tpropagateContext(argArray)\n\t\t\t\tspan.setAttribute('queue.operation', 'send')\n\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\tspan.end()\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nfunction instrumentQueueSendBatch(fn: Queue<unknown>['sendBatch'], name: string): Queue<unknown>['sendBatch'] {\n\tconst tracer = trace.getTracer('queueSender')\n\tconst handler: ProxyHandler<Queue<unknown>['sendBatch']> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\treturn tracer.startActiveSpan(`Queues ${name} sendBatch`, async (span) => {\n\t\t\t\tspan.setAttribute('queue.operation', 'sendBatch')\n\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\tspan.end()\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nexport function instrumentQueueSender(queue: Queue<unknown>, name: string) {\n\tconst queueHandler: ProxyHandler<Queue<unknown>> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'send') {\n\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentQueueSend(sendFn, name)\n\t\t\t} else if (prop === 'sendBatch') {\n\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentQueueSendBatch(sendFn, name)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(queue, queueHandler)\n}\n","import { isVersionMetadata } from './env.js'\n\nexport function versionAttributes(env: unknown): Record<string, string | undefined> {\n\tconst attributes = {} as Record<string, string | undefined>\n\n\tif (typeof env === 'object' && env !== null) {\n\t\tfor (const [binding, data] of Object.entries(env)) {\n\t\t\tif (isVersionMetadata(data)) {\n\t\t\t\tattributes['cf.workers_version_metadata.binding'] = binding\n\t\t\t\tattributes['cf.workers_version_metadata.id'] = data.id\n\t\t\t\tattributes['cf.workers_version_metadata.tag'] = data.tag\n\t\t\t\t// Version metadata bindings are identical, so we can stop after the first one found\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn attributes\n}\n","import {\n\tcontext as api_context,\n\tAttributes,\n\tpropagation,\n\tSpanKind,\n\tSpanOptions,\n\tSpanStatusCode,\n\ttrace,\n} from '@opentelemetry/api'\nimport { ResolvedTraceConfig } from '../../dist/index.mjs'\nimport { unwrap, wrap } from '../wrap.js'\nimport { FetcherConfig, instrumentClientFetch } from './fetch.js'\nimport { getActiveConfig } from '../config.js'\nimport { should } from 'vitest'\n\nexport function instrumentServiceBinding(fetcher: Fetcher, envName: string): Fetcher {\n\tconst fetcherHandler: ProxyHandler<Fetcher> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetcher = Reflect.get(target, prop)\n\t\t\t\tconst attrs = {\n\t\t\t\t\tname: `Service Binding ${envName}`,\n\t\t\t\t}\n\t\t\t\treturn instrumentClientFetch(fetcher, () => ({ includeTraceContext: true }), attrs)\n\t\t\t} else {\n\t\t\t\treturn instrumentClientRpcIfNeeded(target, envName, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetcher, fetcherHandler)\n}\n\nexport function instrumentClientRpcIfNeeded(target: any, envName: string, prop: string | symbol, thisArg?: any) {\n\tconst unwrappedTarget = unwrap(target)\n\tconst value = Reflect.get(unwrappedTarget, prop)\n\tif (typeof value === 'function') {\n\t\tif (value.constructor.name === 'RpcProperty') {\n\t\t\tconst attrs = {\n\t\t\t\tname: `RPC call ${envName}.${String(prop)}`,\n\t\t\t}\n\t\t\treturn instrumentClientRpc(value, () => ({ includeTraceContext: true }), attrs)\n\t\t}\n\t\tthisArg = thisArg || unwrappedTarget\n\t\treturn value.bind(thisArg)\n\t} else {\n\t\treturn value\n\t}\n}\n\ntype SimpleRpcRequest = {\n\tmetadata: Record<string, string>\n}\n\ntype getFetchConfig = (config: ResolvedTraceConfig) => FetcherConfig\nexport function instrumentClientRpc(\n\tfetchFn: Fetcher['fetch'],\n\tconfigFn: getFetchConfig,\n\tattrs?: Attributes,\n): Fetcher['fetch'] {\n\tconst handler: ProxyHandler<Fetcher['fetch']> = {\n\t\tapply: (target, thisArg, argArray): Response | Promise<Response> => {\n\t\t\tconst shouldPropagate = argArray?.length > 0 && typeof argArray[0] === 'object'\n\n\t\t\tconst request = shouldPropagate ? (argArray[0] as SimpleRpcRequest) : undefined\n\t\t\tif (request) {\n\t\t\t\trequest.metadata = request.metadata ? request.metadata : {}\n\t\t\t}\n\n\t\t\tconst workerConfig = getActiveConfig()\n\t\t\tif (!workerConfig) {\n\t\t\t\treturn Reflect.apply(target, thisArg, [request])\n\t\t\t}\n\t\t\tconst config = configFn(workerConfig)\n\n\t\t\tconst tracer = trace.getTracer('rpc')\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes: attrs }\n\n\t\t\tconst spanName = typeof attrs?.['name'] === 'string' ? attrs?.['name'] : `RPC call`\n\t\t\tconst promise = tracer.startActiveSpan(spanName, options, async (span) => {\n\t\t\t\tconst includeTraceContext = config.includeTraceContext ?? true\n\t\t\t\tif (request && includeTraceContext) {\n\t\t\t\t\tpropagation.inject(api_context.active(), request.metadata, {\n\t\t\t\t\t\tset: (h, k, v) => (h[k] = typeof v === 'string' ? v : String(v)),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn await Reflect.apply(target, thisArg, [request])\n\t\t\t\t} catch (err) {\n\t\t\t\t\tspan?.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\tthrow err\n\t\t\t\t} finally {\n\t\t\t\t\tspan.end()\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn promise\n\t\t},\n\t}\n\treturn wrap(fetchFn, handler, true)\n}\n","import { Attributes, SpanKind, SpanOptions, SpanStatusCode, Exception, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\n\nconst dbSystem = 'Cloudflare D1'\n\n// We need to peak into D1 \"internals\" to instrument batch queries\n// See: https://github.com/cloudflare/workerd/blob/5d27f8f7f1f9b584f673d2f11c9032f5a776ec55/src/cloudflare/internal/d1-api.ts#L173\ninterface D1StatementInternals {\n\tstatement: string\n\tparams: unknown[]\n}\n\nfunction metaAttributes(meta: D1Meta): Attributes {\n\treturn {\n\t\t'db.cf.d1.rows_read': meta.rows_read,\n\t\t'db.cf.d1.rows_written': meta.rows_written,\n\t\t'db.cf.d1.duration': meta.duration,\n\t\t'db.cf.d1.size_after': meta.size_after,\n\t\t'db.cf.d1.last_row_id': meta.last_row_id,\n\t\t'db.cf.d1.changed_db': meta.changed_db,\n\t\t'db.cf.d1.changes': meta.changes,\n\t}\n}\nfunction spanOptions(dbName: string, operation: string, sql?: string): SpanOptions {\n\tconst attributes: Attributes = {\n\t\tbinding_type: 'D1',\n\t\t[SemanticAttributes.DB_NAME]: dbName,\n\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t}\n\tif (sql) {\n\t\tattributes[SemanticAttributes.DB_STATEMENT] = sql\n\t}\n\treturn {\n\t\tkind: SpanKind.CLIENT,\n\t\tattributes,\n\t}\n}\n\nfunction instrumentD1StatementFn(fn: Function, dbName: string, operation: string, sql: string) {\n\tconst tracer = trace.getTracer('D1')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tif (operation === 'bind') {\n\t\t\t\tconst newStmt = Reflect.apply(target, thisArg, argArray) as D1PreparedStatement\n\t\t\t\treturn instrumentD1PreparedStatement(newStmt, dbName, sql)\n\t\t\t}\n\n\t\t\tconst options = spanOptions(dbName, operation, sql)\n\t\t\treturn tracer.startActiveSpan(`${dbName} ${operation}`, options, async (span) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\t\tif (operation === 'all' || operation === 'run') {\n\t\t\t\t\t\tspan.setAttributes(metaAttributes((result as D1Result).meta))\n\t\t\t\t\t}\n\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t\treturn result\n\t\t\t\t} catch (error) {\n\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\tthrow error\n\t\t\t\t} finally {\n\t\t\t\t\tspan.end()\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nfunction instrumentD1PreparedStatement(\n\tstmt: D1PreparedStatement,\n\tdbName: string,\n\tstatement: string,\n): D1PreparedStatement {\n\tconst statementHandler: ProxyHandler<D1PreparedStatement> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\tif (typeof fn === 'function') {\n\t\t\t\treturn instrumentD1StatementFn(fn, dbName, operation, statement)\n\t\t\t}\n\t\t\treturn fn\n\t\t},\n\t}\n\treturn wrap(stmt, statementHandler)\n}\n\nexport function instrumentD1Fn(fn: Function, dbName: string, operation: string) {\n\tconst tracer = trace.getTracer('D1')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tif (operation === 'prepare') {\n\t\t\t\tconst sql = argArray[0] as string\n\t\t\t\tconst stmt = Reflect.apply(target, thisArg, argArray) as D1PreparedStatement\n\t\t\t\treturn instrumentD1PreparedStatement(stmt, dbName, sql)\n\t\t\t} else if (operation === 'exec') {\n\t\t\t\tconst sql = argArray[0] as string\n\t\t\t\tconst options = spanOptions(dbName, operation, sql)\n\t\t\t\treturn tracer.startActiveSpan(`${dbName} ${operation}`, options, async (span) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t\t\treturn result\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tspan.end()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else if (operation === 'batch') {\n\t\t\t\t// Create span for each statement, requires peeaking into D1 internals ...\n\t\t\t\tconst statements = argArray[0] as D1StatementInternals[]\n\t\t\t\treturn tracer.startActiveSpan(`${dbName} ${operation}`, async (span) => {\n\t\t\t\t\t// Create a span per query in the batch\n\t\t\t\t\tconst subSpans = statements.map((s) =>\n\t\t\t\t\t\ttracer.startSpan(`${dbName} ${operation} > query`, spanOptions(dbName, operation, s.statement)),\n\t\t\t\t\t)\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = (await Reflect.apply(target, thisArg, argArray)) as D1Result[]\n\t\t\t\t\t\tresult.forEach((r, i) => subSpans[i]?.setAttributes(metaAttributes(r.meta)))\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t\t\treturn result\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubSpans.forEach((s) => s.end())\n\t\t\t\t\t\tspan.end()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn Reflect.apply(target, thisArg, argArray)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentD1(database: D1Database, dbName: string): D1Database {\n\tconst dbHandler: ProxyHandler<D1Database> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\tif (typeof fn === 'function') {\n\t\t\t\treturn instrumentD1Fn(fn, dbName, operation)\n\t\t\t}\n\t\t\treturn fn\n\t\t},\n\t}\n\treturn wrap(database, dbHandler)\n}\n","import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { wrap } from '../wrap.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst dbSystem = 'Cloudflare Analytics Engine'\n\nconst AEAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\twriteDataPoint(argArray) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts = argArray[0]\n\t\tif (typeof opts === 'object') {\n\t\t\tattrs['db.cf.ae.indexes'] = opts.indexes.length\n\t\t\tattrs['db.cf.ae.index'] = (opts.indexes[0] as ArrayBuffer | string).toString()\n\t\t\tattrs['db.cf.ae.doubles'] = opts.doubles.length\n\t\t\tattrs['db.cf.ae.blobs'] = opts.blobs.length\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentAEFn(fn: Function, name: string, operation: string) {\n\tconst tracer = trace.getTracer('AnalyticsEngine')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst attributes = {\n\t\t\t\tbinding_type: 'AnalyticsEngine',\n\t\t\t\t[SemanticAttributes.DB_NAME]: name,\n\t\t\t\t[SemanticAttributes.DB_SYSTEM]: dbSystem,\n\t\t\t\t[SemanticAttributes.DB_OPERATION]: operation,\n\t\t\t}\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes,\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`Analytics Engine ${name} ${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrsFn = AEAttributes[operation]\n\t\t\t\tconst extraAttrs = extraAttrsFn ? extraAttrsFn(argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tspan.setAttribute(SemanticAttributes.DB_STATEMENT, `${operation} ${argArray[0]}`)\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n\nexport function instrumentAnalyticsEngineDataset(\n\tdataset: AnalyticsEngineDataset,\n\tname: string,\n): AnalyticsEngineDataset {\n\tconst datasetHandler: ProxyHandler<AnalyticsEngineDataset> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentAEFn(fn, name, operation)\n\t\t},\n\t}\n\treturn wrap(dataset, datasetHandler)\n}\n","import { isProxyable, wrap } from '../wrap.js'\nimport { instrumentDOBinding } from './do.js'\nimport { instrumentKV } from './kv.js'\nimport { instrumentQueueSender } from './queue.js'\nimport { instrumentServiceBinding } from './service.js'\nimport { instrumentD1 } from './d1'\nimport { instrumentAnalyticsEngineDataset } from './analytics-engine.js'\n\nconst isJSRPC = (item?: unknown): item is Service => {\n\t// @ts-expect-error The point of RPC types is to block non-existent properties, but that's the goal here\n\treturn !!(item as Service)?.['__some_property_that_will_never_exist' + Math.random()]\n}\n\nconst isKVNamespace = (item?: unknown): item is KVNamespace => {\n\treturn !isJSRPC(item) && !!(item as KVNamespace)?.getWithMetadata\n}\n\nconst isQueue = (item?: unknown): item is Queue<unknown> => {\n\treturn !isJSRPC(item) && !!(item as Queue<unknown>)?.sendBatch\n}\n\nconst isDurableObject = (item?: unknown): item is DurableObjectNamespace => {\n\treturn !isJSRPC(item) && !!(item as DurableObjectNamespace)?.idFromName\n}\n\nexport const isVersionMetadata = (item?: unknown): item is WorkerVersionMetadata => {\n\treturn (\n\t\t!isJSRPC(item) &&\n\t\ttypeof (item as WorkerVersionMetadata)?.id === 'string' &&\n\t\ttypeof (item as WorkerVersionMetadata)?.tag === 'string'\n\t)\n}\n\nconst isAnalyticsEngineDataset = (item?: unknown): item is AnalyticsEngineDataset => {\n\treturn !isJSRPC(item) && !!(item as AnalyticsEngineDataset)?.writeDataPoint\n}\n\nconst isD1Database = (item?: unknown): item is D1Database => {\n\treturn !!(item as D1Database)?.exec && !!(item as D1Database)?.prepare\n}\n\nconst instrumentEnv = (env: Record<string, unknown>): Record<string, unknown> => {\n\tconst envHandler: ProxyHandler<Record<string, unknown>> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst item = Reflect.get(target, prop, receiver)\n\t\t\tif (!isProxyable(item)) {\n\t\t\t\treturn item\n\t\t\t}\n\t\t\tif (isJSRPC(item)) {\n\t\t\t\treturn instrumentServiceBinding(item, String(prop))\n\t\t\t} else if (isKVNamespace(item)) {\n\t\t\t\treturn instrumentKV(item, String(prop))\n\t\t\t} else if (isQueue(item)) {\n\t\t\t\treturn instrumentQueueSender(item, String(prop))\n\t\t\t} else if (isDurableObject(item)) {\n\t\t\t\treturn instrumentDOBinding(item, String(prop))\n\t\t\t} else if (isVersionMetadata(item)) {\n\t\t\t\t// we do not need to log accesses to the metadata\n\t\t\t\treturn item\n\t\t\t} else if (isAnalyticsEngineDataset(item)) {\n\t\t\t\treturn instrumentAnalyticsEngineDataset(item, String(prop))\n\t\t\t} else if (isD1Database(item)) {\n\t\t\t\treturn instrumentD1(item, String(prop))\n\t\t\t} else {\n\t\t\t\treturn item\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(env, envHandler)\n}\n\nexport { instrumentEnv }\n","import { SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { wrap } from '../wrap.js'\n\ntype CacheFns = Cache[keyof Cache]\n\nconst tracer = trace.getTracer('cache instrumentation')\n\nfunction sanitiseURL(url: string): string {\n\tconst u = new URL(url)\n\treturn `${u.protocol}//${u.host}${u.pathname}${u.search}`\n}\n\nfunction instrumentFunction<T extends CacheFns>(fn: T, cacheName: string, op: string): T {\n\tconst handler: ProxyHandler<typeof fn> = {\n\t\tasync apply(target, thisArg, argArray) {\n\t\t\tconst attributes = {\n\t\t\t\t'cache.name': cacheName,\n\t\t\t\t'http.url': argArray[0].url ? sanitiseURL(argArray[0].url) : undefined,\n\t\t\t\t'cache.operation': op,\n\t\t\t}\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes }\n\t\t\treturn tracer.startActiveSpan(`Cache ${cacheName} ${op}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tif (op === 'match') {\n\t\t\t\t\tspan.setAttribute('cache.hit', !!result)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nfunction instrumentCache(cache: Cache, cacheName: string): Cache {\n\tconst handler: ProxyHandler<typeof cache> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'delete' || prop === 'match' || prop === 'put') {\n\t\t\t\tconst fn = Reflect.get(target, prop).bind(target)\n\t\t\t\treturn instrumentFunction(fn, cacheName, prop)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(cache, handler)\n}\n\nfunction instrumentOpen(openFn: CacheStorage['open']): CacheStorage['open'] {\n\tconst handler: ProxyHandler<typeof openFn> = {\n\t\tasync apply(target, thisArg, argArray) {\n\t\t\tconst cacheName = argArray[0]\n\t\t\tconst cache = await Reflect.apply(target, thisArg, argArray)\n\t\t\treturn instrumentCache(cache, cacheName)\n\t\t},\n\t}\n\treturn wrap(openFn, handler)\n}\n\nfunction _instrumentGlobalCache() {\n\tconst handler: ProxyHandler<typeof caches> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'default') {\n\t\t\t\tconst cache = target.default\n\t\t\t\treturn instrumentCache(cache, 'default')\n\t\t\t} else if (prop === 'open') {\n\t\t\t\tconst openFn = Reflect.get(target, prop).bind(target)\n\t\t\t\treturn instrumentOpen(openFn)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\t//@ts-ignore\n\tglobalThis.caches = wrap(caches, handler)\n}\n\nexport function instrumentGlobalCache() {\n\treturn _instrumentGlobalCache()\n}\n","import { trace, SpanOptions, SpanKind, Exception, context as api_context, SpanStatusCode } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { Initialiser, setConfig } from '../config.js'\nimport { exportSpans, proxyExecutionContext } from './common.js'\nimport { instrumentEnv } from './env.js'\nimport { wrap } from '../wrap.js'\nimport { versionAttributes } from './version.js'\n\ntype ScheduledHandler = ExportedHandlerScheduledHandler<unknown>\nexport type ScheduledHandlerArgs = Parameters<ScheduledHandler>\n\nconst traceIdSymbol = Symbol('traceId')\n\nlet cold_start = true\nexport function executeScheduledHandler(\n\tscheduledFn: ScheduledHandler,\n\t[controller, env, ctx]: ScheduledHandlerArgs,\n): Promise<void> {\n\tconst tracer = trace.getTracer('scheduledHandler')\n\tconst attributes = {\n\t\t[SemanticAttributes.FAAS_TRIGGER]: 'timer',\n\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t\t[SemanticAttributes.FAAS_CRON]: controller.cron,\n\t\t[SemanticAttributes.FAAS_TIME]: new Date(controller.scheduledTime).toISOString(),\n\t}\n\tcold_start = false\n\tObject.assign(attributes, versionAttributes(env))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst promise = tracer.startActiveSpan(`scheduledHandler ${controller.cron}`, options, async (span) => {\n\t\tconst traceId = span.spanContext().traceId\n\t\tapi_context.active().setValue(traceIdSymbol, traceId)\n\t\ttry {\n\t\t\tawait scheduledFn(controller, env, ctx)\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tspan.end()\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function createScheduledHandler(scheduledFn: ScheduledHandler, initialiser: Initialiser) {\n\tconst scheduledHandler: ProxyHandler<ScheduledHandler> = {\n\t\tasync apply(target, _thisArg, argArray: Parameters<ScheduledHandler>): Promise<void> {\n\t\t\tconst [controller, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, controller)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: ScheduledHandlerArgs = [controller, env, ctx]\n\n\t\t\t\treturn await api_context.with(context, executeScheduledHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(scheduledFn, scheduledHandler)\n}\n","{\n  \"@microlabs/otel-cf-workers\": \"1.0.0-fp.52\",\n  \"npm\": \"10.9.2\",\n  \"node\": \"22.14.0\",\n  \"acorn\": \"8.14.0\",\n  \"ada\": \"2.9.2\",\n  \"amaro\": \"0.3.0\",\n  \"ares\": \"1.34.4\",\n  \"brotli\": \"1.1.0\",\n  \"cjs_module_lexer\": \"1.4.1\",\n  \"cldr\": \"46.0\",\n  \"icu\": \"76.1\",\n  \"llhttp\": \"9.2.1\",\n  \"modules\": \"127\",\n  \"napi\": \"10\",\n  \"nbytes\": \"0.1.1\",\n  \"ncrypto\": \"0.0.1\",\n  \"nghttp2\": \"1.64.0\",\n  \"nghttp3\": \"1.6.0\",\n  \"ngtcp2\": \"1.10.0\",\n  \"openssl\": \"3.0.15+quic\",\n  \"simdjson\": \"3.10.1\",\n  \"simdutf\": \"6.0.3\",\n  \"sqlite\": \"3.47.2\",\n  \"tz\": \"2024b\",\n  \"undici\": \"6.21.1\",\n  \"unicode\": \"16.0\",\n  \"uv\": \"1.49.2\",\n  \"uvwasi\": \"0.0.21\",\n  \"v8\": \"12.4.254.21-node.22\",\n  \"zlib\": \"1.3.0.1-motley-82a5fec\"\n}\n","import { setConfig, type Initialiser } from '../config'\nimport { wrap } from '../wrap'\nimport { exportSpans, proxyExecutionContext } from './common'\nimport { context as api_context, Exception, SpanKind, type SpanOptions, trace } from '@opentelemetry/api'\nimport { instrumentEnv } from './env'\nimport { versionAttributes } from './version'\nimport {\n\tATTR_FAAS_TRIGGER,\n\tATTR_MESSAGING_DESTINATION_NAME,\n\tATTR_RPC_MESSAGE_ID,\n} from '@opentelemetry/semantic-conventions/incubating'\n\ntype EmailHandler = EmailExportedHandler\nexport type EmailHandlerArgs = Parameters<EmailHandler>\n\nexport function createEmailHandler(emailFn: EmailHandler, initialiser: Initialiser): EmailHandler {\n\tconst emailHandler: ProxyHandler<EmailHandler> = {\n\t\tasync apply(target, _thisArg, argArray: Parameters<EmailHandler>): Promise<void> {\n\t\t\tconst [message, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, message)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: EmailHandlerArgs = [message, env, ctx]\n\t\t\t\treturn await api_context.with(context, executeEmailHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(emailFn, emailHandler)\n}\n\n/**\n * Converts the message headers into a record ready to be injected\n * as OpenTelemetry attributes\n *\n * @example\n * ```ts\n * const headers = new Headers({ \"Subject\": \"Hello!\", From: \"hello@example.com\" })\n * headerAttributes({ headers })\n * // => {\"email.header.Subject\": \"Hello!\", \"email.header.From\": \"hello@example.com\"}\n * ```\n */\nfunction headerAttributes(message: { headers: Headers }): Record<string, unknown> {\n\treturn Object.fromEntries([...message.headers].map(([key, value]) => [`email.header.${key}`, value] as const))\n}\n\nasync function executeEmailHandler(emailFn: EmailHandler, [message, env, ctx]: EmailHandlerArgs): Promise<void> {\n\tconst tracer = trace.getTracer('emailHandler')\n\tconst options = {\n\t\tattributes: {\n\t\t\t[ATTR_FAAS_TRIGGER]: 'other',\n\t\t\t[ATTR_RPC_MESSAGE_ID]: message.headers.get('Message-Id') ?? undefined,\n\t\t\t[ATTR_MESSAGING_DESTINATION_NAME]: message.to,\n\t\t},\n\t\tkind: SpanKind.CONSUMER,\n\t} satisfies SpanOptions\n\tObject.assign(options.attributes!, headerAttributes(message), versionAttributes(env))\n\tconst promise = tracer.startActiveSpan(`emailHandler ${message.to}`, options, async (span) => {\n\t\ttry {\n\t\t\tconst result = await emailFn(message, env, ctx)\n\t\t\tspan.end()\n\t\t\treturn result\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n","import { ReadableSpan } from '@opentelemetry/sdk-trace-base'\nimport { Initialiser, setConfig } from '../config'\nimport { exportSpans, proxyExecutionContext } from './common'\nimport { Exception, SpanKind, SpanOptions, SpanStatusCode, context as api_context, trace } from '@opentelemetry/api'\nimport { wrap } from '../wrap'\nimport {\n\tgatherIncomingCfAttributes,\n\tgatherRequestAttributes,\n\tgatherResponseAttributes,\n\tgetParentContextFromRequest,\n\tinstrumentClientFetch,\n} from './fetch'\nimport { instrumentEnv } from './env'\n\nexport type Cookies = {\n\t/**\n\t * Gets a cookie that was previously set with `cookies.set`, or from the request headers.\n\t * @param name the name of the cookie\n\t * @param opts the options, passed directly to `cookie.parse`. See documentation [here](https://github.com/jshttp/cookie#cookieparsestr-options)\n\t */\n\tget(name: string, opts?: import('cookie').ParseOptions): string | undefined\n\n\t/**\n\t * Gets all cookies that were previously set with `cookies.set`, or from the request headers.\n\t * @param opts the options, passed directly to `cookie.parse`. See documentation [here](https://github.com/jshttp/cookie#cookieparsestr-options)\n\t */\n\tgetAll(opts?: import('cookie').ParseOptions): Array<{ name: string; value: string }>\n\n\t/**\n\t * Sets a cookie. This will add a `set-cookie` header to the response, but also make the cookie available via `cookies.get` or `cookies.getAll` during the current request.\n\t *\n\t * The `httpOnly` and `secure` options are `true` by default (except on http://localhost, where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`.\n\t *\n\t * You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children\n\t * @param name the name of the cookie\n\t * @param value the cookie value\n\t * @param opts the options, passed directly to `cookie.serialize`. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)\n\t */\n\tset(name: string, value: string, opts: import('cookie').ParseOptions & { path: string }): void\n\n\t/**\n\t * Deletes a cookie by setting its value to an empty string and setting the expiry date in the past.\n\t *\n\t * You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children\n\t * @param name the name of the cookie\n\t * @param opts the options, passed directly to `cookie.serialize`. The `path` must match the path of the cookie you want to delete. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)\n\t */\n\tdelete(name: string, opts: import('cookie').ParseOptions & { path: string }): void\n\n\t/**\n\t * Serialize a cookie name-value pair into a `Set-Cookie` header string, but don't apply it to the response.\n\t *\n\t * The `httpOnly` and `secure` options are `true` by default (except on http://localhost, where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`.\n\t *\n\t * You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children\n\t *\n\t * @param name the name of the cookie\n\t * @param value the cookie value\n\t * @param opts the options, passed directly to `cookie.serialize`. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)\n\t */\n\tserialize(name: string, value: string, opts: import('cookie').ParseOptions & { path: string }): string\n}\n\nexport interface ResolveOptions {\n\t/**\n\t * Applies custom transforms to HTML. If `done` is true, it's the final chunk. Chunks are not guaranteed to be well-formed HTML\n\t * (they could include an element's opening tag but not its closing tag, for example)\n\t * but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components.\n\t * @param input the html chunk and the info if this is the last chunk\n\t */\n\ttransformPageChunk?(input: { html: string; done: boolean }): MaybePromise<string | undefined>\n\t/**\n\t * Determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`.\n\t * By default, none will be included.\n\t * @param name header name\n\t * @param value header value\n\t */\n\tfilterSerializedResponseHeaders?(name: string, value: string): boolean\n\t/**\n\t * Determines what should be added to the `<head>` tag to preload it.\n\t * By default, `js` and `css` files will be preloaded.\n\t * @param input the type of the file and its path\n\t */\n\tpreload?(input: { type: 'font' | 'css' | 'js' | 'asset'; path: string }): boolean\n}\nexport type SvelteLocals = Partial<Record<string, any>>\ntype Env = unknown\nexport type SveltePlatform = {\n\tenv: Env\n\tcf: CfProperties\n\tctx: ExecutionContext\n}\n\nexport type RequestEvent<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tRouteId extends string | null = string | null,\n> = {\n\t/**\n\t * Get or set cookies related to the current request\n\t */\n\tcookies: Cookies\n\t/**\n\t * `fetch` is equivalent to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch), with a few additional features:\n\t *\n\t * - It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request.\n\t * - It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context).\n\t * - Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.\n\t * - During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text` and `json` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](https://svelte.dev/docs/kit/hooks#Server-hooks-handle)\n\t * - During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.\n\t *\n\t * You can learn more about making credentialed requests with cookies [here](https://svelte.dev/docs/kit/load#Cookies)\n\t */\n\tfetch: typeof fetch\n\t/**\n\t * The client's IP address, set by the adapter.\n\t */\n\tgetClientAddress(): string\n\t/**\n\t * Contains custom data that was added to the request within the [`server handle hook`](https://svelte.dev/docs/kit/hooks#Server-hooks-handle).\n\t */\n\tlocals: SvelteLocals\n\t/**\n\t * The parameters of the current route - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object\n\t */\n\tparams: Params\n\t/**\n\t * Additional data made available through the adapter.\n\t */\n\tplatform: Readonly<SveltePlatform> | undefined\n\t/**\n\t * The original request object\n\t */\n\trequest: Request\n\t/**\n\t * Info about the current route\n\t */\n\troute: {\n\t\t/**\n\t\t * The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`\n\t\t */\n\t\tid: RouteId\n\t}\n\t/**\n\t * If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:\n\t *\n\t *\t```js\n\t *\t/// file: src/routes/blog/+page.js\n\t *\texport async function load({ fetch, setHeaders }) {\n\t *\t\tconst url = `https://cms.example.com/articles.json`;\n\t *\t\tconst response = await fetch(url);\n\t *\n\t *\t\tsetHeaders({\n\t *\t\t\tage: response.headers.get('age'),\n\t *\t\t\t'cache-control': response.headers.get('cache-control')\n\t *\t\t});\n\t *\n\t *\t\treturn response.json();\n\t *\t}\n\t *\t```\n\t *\n\t * Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once.\n\t *\n\t * You cannot add a `set-cookie` header with `setHeaders` — use the [`cookies`](https://svelte.dev/docs/kit/@sveltejs-kit#Cookies) API instead.\n\t */\n\tsetHeaders(headers: Record<string, string>): void\n\t/**\n\t * The requested URL.\n\t */\n\turl: URL\n\t/**\n\t * `true` if the request comes from the client asking for `+page/layout.server.js` data. The `url` property will be stripped of the internal information\n\t * related to the data request in this case. Use this property instead if the distinction is important to you.\n\t */\n\tisDataRequest: boolean\n\t/**\n\t * `true` for `+server.js` calls coming from SvelteKit without the overhead of actually making an HTTP request. This happens when you make same-origin `fetch` requests on the server.\n\t */\n\tisSubRequest: boolean\n}\n\nexport type MaybePromise<T> = T | Promise<T>\n\nexport type ExportedSvelteEventHandler = (input: {\n\tevent: RequestEvent\n\tresolve(event: RequestEvent, opts?: ResolveOptions): MaybePromise<Response>\n}) => MaybePromise<Response>\n\nexport type _Response = typeof globalThis extends { onmessage: any } ? {} : import('undici-types').Response\nexport interface ResponseEvent extends _Response {}\n\ntype PageHandlerArgs = Parameters<ExportedSvelteEventHandler>\n\nlet cold_start = true\nexport function executePageHandler(pagesFn: ExportedSvelteEventHandler, [input]: PageHandlerArgs): Promise<Response> {\n\tconst { event } = input\n\tconst spanContext = getParentContextFromRequest(event.request)\n\n\tconst tracer = trace.getTracer('pagesHandler')\n\tconst attributes = {\n\t\t['faas.trigger']: 'http',\n\t\t['faas.coldstart']: cold_start,\n\t\t['faas.invocation_id']: event.request.headers.get('cf-ray') ?? undefined,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(event.request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(event.request))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst promise = tracer.startActiveSpan(\n\t\t`${event.request.method} ${event.url.pathname}`,\n\t\toptions,\n\t\tspanContext,\n\t\tasync (span) => {\n\t\t\tconst readable = span as unknown as ReadableSpan\n\t\t\tconst method = event.request.method.toUpperCase()\n\t\t\ttry {\n\t\t\t\tconst response: Response = await pagesFn(input)\n\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\tif (readable.attributes['http.route']) {\n\t\t\t\t\tspan.updateName(`${event.request.method} ${readable.attributes['http.route']}`)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\n\t\t\t\treturn response\n\t\t\t} catch (error) {\n\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\tif (readable.attributes['http.route']) {\n\t\t\t\t\tspan.updateName(`fetchHandler ${method} ${readable.attributes['http.route']}`)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\t\t\t}\n\t\t},\n\t)\n\treturn promise\n}\n\nexport function createPageHandler(pageFn: ExportedSvelteEventHandler, initialiser: Initialiser) {\n\tconst pagesHandler: ProxyHandler<ExportedSvelteEventHandler> = {\n\t\tapply: async (target, _thisArg, argArray: Parameters<ExportedSvelteEventHandler>): Promise<Response> => {\n\t\t\tconst [input] = argArray\n\t\t\tconst { event } = input\n\t\t\t// @ts-expect-error\n\t\t\tlet { env, context } = event.platform!\n\t\t\tconst config = initialiser(env as Record<string, unknown>, event.request)\n\t\t\tconst configContext = setConfig(config)\n\t\t\t// @ts-expect-error\n\t\t\tevent.locals.env = instrumentEnv(env as Record<string, unknown>)\n\t\t\tevent.fetch = instrumentClientFetch(event.fetch, (config) => config.fetch)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(context)\n\t\t\t// @ts-expect-error\n\t\t\tevent.locals.ctx = ctx\n\n\t\t\ttry {\n\t\t\t\tconst args: PageHandlerArgs = [input] as PageHandlerArgs\n\t\t\t\treturn await api_context.with(configContext, executePageHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\tcontext.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(pageFn, pagesHandler)\n}\n","import {\n\tSpanKind,\n\tSpanOptions,\n\ttrace,\n\tcontext as api_context,\n\tException,\n\tpropagation,\n\tContext,\n} from '@opentelemetry/api'\nimport { Initialiser, setConfig } from '../config'\nimport { exportSpans, proxyExecutionContext } from './common'\nimport { instrumentEnv } from './env'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { WorkerEntrypoint } from 'cloudflare:workers'\nimport { instrumentClientFetch } from './fetch'\nimport { ResolvedTraceConfig } from '../types'\n\nconst traceIdSymbol = Symbol('traceId')\n\nexport abstract class InstrumentedEntrypoint<E extends Record<string, unknown>> extends WorkerEntrypoint<E> {\n\tprivate enhancedEnv: E\n\n\tconstructor(ctx: ExecutionContext, env: E) {\n\t\tsuper(ctx, env)\n\t\tthis.enhancedEnv = {} as E\n\t}\n\n\tpublic set instrumentedEnv(env: E) {\n\t\tthis.enhancedEnv = env\n\t}\n\n\tprotected entrypointContext<EntrypointContext>(): EntrypointContext {\n\t\treturn {\n\t\t\tenv: this.enhancedEnv,\n\t\t\tfetch: this.fetch,\n\t\t} as EntrypointContext\n\t}\n}\n\nexport function getParentContextFromMetadata(metadata: Record<string, string | string[] | undefined>): Context {\n\treturn propagation.extract<Record<string, unknown>>(api_context.active(), metadata, {\n\t\tget(headers, key) {\n\t\t\tconst value = headers[key] || undefined\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn value as string[]\n\t\t\t}\n\t\t\treturn value as string\n\t\t},\n\t\tkeys(data) {\n\t\t\treturn [...Object.keys(data)]\n\t\t},\n\t})\n}\n\nfunction getParentContextFromEntrypoint(\n\tworkerConfig: ResolvedTraceConfig | undefined,\n\trequest: Record<string, unknown>,\n) {\n\tif (workerConfig === undefined) {\n\t\treturn api_context.active()\n\t}\n\n\tconst acceptTraceContext = workerConfig.handlers.fetch.acceptTraceContext ?? true\n\treturn acceptTraceContext\n\t\t? getParentContextFromMetadata(request['metadata'] as Record<string, string | string[] | undefined>)\n\t\t: api_context.active()\n}\n\nexport function createEntrypointHandler<E extends Record<string, unknown>>(initialiser: Initialiser): MethodDecorator {\n\t// @ts-expect-error type checking\n\tconst decorator: MethodDecorator = <Target extends InstrumentedEntrypoint<E>>(\n\t\ttarget: Target,\n\t\tpropertyKey: string,\n\t\tdescriptor: PropertyDescriptor,\n\t) => {\n\t\tconst original = descriptor.value\n\t\tdescriptor.value = async function (...args: unknown[]) {\n\t\t\tconst request = args?.length > 0 ? (args[0] as Record<string, unknown>) : {}\n\t\t\tconst originalRef = this as InstrumentedEntrypoint<E>\n\t\t\t// @ts-expect-error type check\n\t\t\tconst orig_env = originalRef.env\n\t\t\t// @ts-expect-error type check\n\t\t\tconst orig_ctx = originalRef.ctx\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, this)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\t// @ts-expect-error type checking\n\t\t\toriginalRef.fetch = instrumentClientFetch(originalRef.fetch, (config) => config.fetch)\n\t\t\tconst { tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error type checking\n\t\t\t\toriginalRef.instrumentedEnv = env\n\t\t\t\tconst executeEntrypointHandler = (): Promise<unknown> => {\n\t\t\t\t\tconst spanContext = getParentContextFromEntrypoint(config, request)\n\t\t\t\t\tconst tracer = trace.getTracer('rpcHandler')\n\t\t\t\t\tconst options: SpanOptions = {\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t[SemanticAttributes.FAAS_TRIGGER]: 'rpc',\n\t\t\t\t\t\t\t'rpc.function.name': propertyKey,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkind: SpanKind.SERVER,\n\t\t\t\t\t}\n\t\t\t\t\tconst promise = tracer.startActiveSpan(\n\t\t\t\t\t\t`RPC ${target.constructor.name}.${propertyKey}`,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\tspanContext,\n\t\t\t\t\t\tasync (span) => {\n\t\t\t\t\t\t\tconst traceId = span.spanContext().traceId\n\t\t\t\t\t\t\tapi_context.active().setValue(traceIdSymbol, traceId)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst result = await original.apply(originalRef, args)\n\t\t\t\t\t\t\t\tspan.end()\n\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\t\t\t\t\tspan.end()\n\t\t\t\t\t\t\t\tthrow error\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t\treturn promise\n\t\t\t\t}\n\t\t\t\treturn await api_context.with(context, executeEntrypointHandler)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t}\n\t\treturn descriptor\n\t}\n\treturn decorator\n}\n","import { SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core'\n\n// First implementation, completely synchronous, more tested.\n\nexport class MultiSpanExporter implements SpanExporter {\n\tprivate exporters: Array<SpanExporter>\n\tconstructor(exporters: Array<SpanExporter>) {\n\t\tthis.exporters = exporters\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tfor (const exporter of this.exporters) {\n\t\t\texporter.export(items, resultCallback)\n\t\t}\n\t}\n\n\tasync shutdown(): Promise<void> {\n\t\tfor (const exporter of this.exporters) {\n\t\t\tawait exporter.shutdown()\n\t\t}\n\t}\n}\n\n// async\n\nexport class MultiSpanExporterAsync implements SpanExporter {\n\tprivate exporters: Array<SpanExporter>\n\tconstructor(exporters: Array<SpanExporter>) {\n\t\tthis.exporters = exporters\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tconst promises = this.exporters.map(\n\t\t\t(exporter) =>\n\t\t\t\tnew Promise<ExportResult>((resolve) => {\n\t\t\t\t\texporter.export(items, resolve)\n\t\t\t\t}),\n\t\t)\n\n\t\tPromise.all(promises).then((results) => {\n\t\t\tconst failed = results.filter((result) => result.code === ExportResultCode.FAILED)\n\t\t\tif (failed.length > 0) {\n\t\t\t\t// not ideal, but just return the first error\n\t\t\t\tresultCallback({ code: ExportResultCode.FAILED, error: failed[0]!.error })\n\t\t\t} else {\n\t\t\t\tresultCallback({ code: ExportResultCode.SUCCESS })\n\t\t\t}\n\t\t})\n\t}\n\n\tasync shutdown(): Promise<void> {\n\t\tawait Promise.all(this.exporters.map((exporter) => exporter.shutdown()))\n\t}\n}\n"],"mappings":"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","names":["propagation","ExportResultCode","state","action","exportSpans","action","state","ExportResultCode","span","context","trace","context","TraceFlags","SpanKind","trace","sanitizeAttributes","SpanStatusCode","init","context","trace","SpanKind","sanitizeAttributes","TraceFlags","span","trace","context","trace","SpanKind","propagation","api_context","SpanStatusCode","api_context","trace","SpanKind","SpanStatusCode","SemanticAttributes","trace","context","tracer","trace","SpanKind","trace","SemanticAttributes","tracer","trace","SemanticAttributes","SpanKind","state","tracer","trace","SemanticAttributes","SpanKind","SpanStatusCode","context","api_context","SpanKind","trace","SemanticAttributes","dbSystem","tracer","trace","SemanticAttributes","SpanKind","trace","SpanKind","api_context","SemanticAttributes","trace","target","prop","tracer","SemanticAttributes","SpanKind","api_context","context","api_context","propagation","SpanKind","SpanStatusCode","trace","fetcher","tracer","trace","SpanKind","propagation","api_context","SpanStatusCode","SpanKind","SpanStatusCode","trace","SemanticAttributes","dbSystem","SemanticAttributes","SpanKind","tracer","trace","SpanStatusCode","SpanKind","trace","SemanticAttributes","dbSystem","tracer","trace","SemanticAttributes","SpanKind","propagation","api_context","headers","tracer","trace","cold_start","SpanKind","SpanStatusCode","context","SpanKind","trace","trace","SpanKind","trace","SpanKind","api_context","SpanStatusCode","SemanticAttributes","traceIdSymbol","cold_start","tracer","trace","SemanticAttributes","SpanKind","api_context","SpanStatusCode","context","@microlabs/otel-cf-workers","api_context","SpanKind","trace","context","api_context","tracer","trace","SpanKind","SpanKind","SpanStatusCode","api_context","trace","cold_start","tracer","trace","SpanKind","SpanStatusCode","context","config","api_context","SpanKind","trace","api_context","propagation","SemanticAttributes","traceIdSymbol","propagation","api_context","config","context","tracer","trace","SemanticAttributes","SpanKind","@microlabs/otel-cf-workers","propagation","ExportResultCode"]}